"Witam. Mam pytanie, bo jesteście obznajomieni z nowymi technologiami. Myślę nad byciem grafikiem i nie wiem czy za mojego życia albo w bliższej przyszłości tego zawodu nie wyprze sztuczna inteligencja bo już teraz potrafi generować obrazy. :);"
Sądzę że ciebie wyprze. Już nie programowanie?;
A jak myślicie czy w przyszłości AI zastąpi grafika całkowicie?;
"oryginalny news: https://www.bloomberg.com/news/articles/2023-05-01/ibm-to-pause-hiring-for-back-office-jobs-that-ai-could-kill#xj4y7vzkg polski: https://www.computerworld.pl/news/W-ciagu-5-lat-IBM-zastapi-30-pracownikow-sztuczna-inteligencja,445372.html;"
"Nie no, co jak co, ale kiedy AI zastąpi twórców tych artykułów na polskich stronach to poziom wzrośnie diametralnie. Często jest to taka patologia, że grzechem jest czytać bez adblocka.;"
"Ta AI, która jest teraz, zastąpi sporo programistów, ale nie tyle ile nam się wydaje: a:) myli się b:) ma mały kontekst, kilkadziesiąt tysięcy słów? Oczywiście sytuacja jest dynamiczna;"
"Witam wszystkich, Ostatnio zainteresowało mnie zagadnienie sztucznej inteligencji a w szczególności sieci neuronowe. Szukam w tym celu materiałów i literatury, która przybliży mi te zagadnienia. Macie może jakieś książki lub inne źródła, które spodobały się wam i możecie polecić? Z góry wielkie dzięki.;"
"@mnygma: Zacznij od sieci neuronowych, później splotowe sieci neuronowe - convolutional neural networks - a a później rekurencyjne sieci neuronowe - RNN. To na początek. Materiałów nie szukaj w polskim internecie. Zacznij na courserze, potem sprawdź CS231N od stanforda.;"
"Na dzień dzisijeszy klienci mają zbyt niesprecyzowane potrzeby i zbyt popi$%dolone pomysły by ai to ogarniała. Jeszcze sporo wody w wiśle upłynie zanim ai nas zastąpi, ale o pracę się nie martwię, bo jak ai nas zastąpi to już nikt nie będzie pracował, będzie globalny komunizm :);"
"Lekcja na dziś: przetwarzanie języka naturalnego. Możesz zapisac się na kursy stanforda / mit z tego zakresu (z zakresu AI i uczenia maszynowego też) To się nazywa uczeniem maszynowym, patrz wyżej. Znów przetwarzanie języka naturalnego, patrz wyżej Biblioteki do rozpoznawania mowy są dostępne, ale żeby zinterpretować polecenia znów przetwarzanie języka naturalnego.  http://see.stanford.edu/see/courseinfo.aspx?coll=63480b48-8819-4efd-8412-263f1a472f5a http://see.stanford.edu/see/courseinfo.aspx?coll=348ca38a-3a6d-4052-937d-cb017338d7b1 http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-spring-2005/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-863j-natural-language-and-the-computer-representation-of-knowledge-spring-2003/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-864-advanced-natural-language-processing-fall-2005/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-867-machine-learning-fall-2006/ Co do samego pisania botów to zainteresuj się Google AI Challenge. To taki konkurs gdzie pisze się właśnie bota do jakiejś gry: http://aichallenge.org/ http://planetwars.aichallenge.org/;"
"Na uczelni mam przedmiot ""Narzędzia sztucznej inteligencji"" gdzie przedstawione są m.in. sztuczne sieci neuronowe, algorytmy generyczne/genetyczne(?), algorytm wspinaczkowy i takie tam. Oczywiście przedmiot zaliczany jest projektem. Pomyślałem, że zamiast zaimplementować, któreś z tym zagadnień na lewo na ""3"" to spróbuje czegoś ambitniejszego co mógłbym podpiąć pod pracę inżynierską. I tutaj pojawia się problem. Ze sztuczną inteligencją nigdy nie miałem wspólnego nic a nic. Myślę czy podjąć się pracy nad czymś w rodzaju ""chatbot""a typu ""Cleverbot"" lub ""Tay""? Czy może napisać program do gry w kółko i krzyżyk, który się ""uczy""?;"
"Obecnie masz tryliard zastosowań sztucznej inteligencji. Wpisz sobie ""applications of deep learning"" ""aplplications of machine learning"" ""applications of text mining"" itp.   albo zobacz konkursy na kaggle.com .  IT,finanse, inżynieria, marketing,medycyna. Z takich codziennych rzeczy można by wymieniać setki przykładów, pierwsze z brzegu : silnik rekomendacji walla facebooka, aplikacja prisma, filter spamu, detekcja twarzy w smarthponeach, cały text mining (chatboty w stylu TAI itp.), rozpoznawanie obrazu;"
"Ludzka świadomość, to nauczyciel, który sam sobie zleca zadania, których jego sieci neuronowe się uczą. W ogóle to wypadało by zrobić skany mózgu, w jego pierwszych stadiach rozwoju, i przeanalizować jego dynamiczny rozwój, bo to kluczowy element do zrozumienia całej tej idei.;"
"Hej, AI do składania zamówień, to raczej nie jest dobry pomysł :) Excel, plus jakieś zrzuty z (ewentualnego) systemu, plus zdrowy rozsądek. No i nic nie zastąpi rozmowy z drugim Człowiekiem, szczególnie w negocjacjach, mimo, że u nas to nie jest modny temat, i ludzie się bardziej targują (o ile to robią) niż negocjują :);"
"jest jakiś tam model zbudowany w oparciu o modelowanie statystyczne i uczenie maszynowe, który zwraca jakieś decyzje dla różnych sytuacji. Decyzje optymalne z punktu  widzenia statystycznego, przez co czasami ich logika jest trudna do zrozumienia i wydaje się absurdalna. Julia: Dlaczego tu jest taka decyzja skoro zadziało się tak i tak Julian: Tak wynika z algorytmu, zaoptymalizowanego pod tym kątem by dawać najlepsze wyniki dla dużej skali. To jest sztuczna inteligencja, Julia: Jaka sztuczna inteligencja skoro Ty zbierasz dane i Ty potem ten algorytm programujesz ...;"
"Sieci neuronowe rozwiązują problemy inteligencją geometryczną. Same potrafią w trakcie uczenia wyznaczać równanie prostej oddzielające jeden zbiór danych od drugich, przez co mogą je interpretować. Jak znasz jakiś język to następny element nauki to implementacja pierwszego neuronu i rozwiązanie pierwszego problemu z jednym neuronem, liniowe i nieliniowe, potem jak wiesz jak działa jeden możesz budować sieci wielowymiarowe. Już dzisiaj możesz zbudować swoją własną sieć, albo po 4 latach studiów, jak tam wolisz.;"
"Sieci neuronowe to zaledwie jedno z narzędzi stosowanych w uczeniu maszynowym, niekoniecznie najlepsze. Nie powinno się ich utożsamiać ze sztuczną inteligencją. Sieci sprawdzają się tam, gdzie nie wiadomo jakie wybrać cechy do klasyfikacji, więc bierze się jak leci i liczy się na to, że sieć się jakoś dostosuje. Nie wiem czy są dobre na początek, bo nie uczą istotnego etapu jakim jest ekstrakcja cech.  Same to nic nie potrafią, trzeba je wytrenować. A do oddzielenia jednego zbioru od drugiego linią prostą nie potrzeba budować sieci, wystarczą prostsze metody, jak PCA albo regresja logistyczna. Jeśli miałbym coś polecić z matematyki, to oprócz wspomnianej statystyki zdecydowanie algebra liniowa.;"
"Cechy są danym wejściowymi dla sieci, ale już niekoniecznie dla problemu, który pomagają rozwiązać. Sieci są zaledwie klasyfikatorem, a przed procesem klasyfikacji mamy nie mniej ważny proces ekstrakcji cech z tychże danych. Ekstrakcja cech jest istotna, bo redukuje przestrzeń danych wejściowych do tych, które mają potencjał dyskryminacyjny. Tymczasem sieci neuronowe, przez to że radzą sobie względnie dobrze z klasyfikacją obszarów przestrzeni, których nie da się odseparować liniowo albo wielomianowo, pozwalają zignorować ekstrakcję cech. Popatrz na pierwszy lepszy tutorial do sieci neuronowych, dotyczący np. rozpoznawania wzorca na obrazku. Czy uczy się tam ekstrakcji cech? Nie, zazwyczaj od razu karmi się sieć surowymi pikselami i liczy na to, że sieć odwali całą robotę.  Sieci wcale nie są najprostsze w zrozumieniu, są dużo prostsze i bardziej intuicyjne klasyfikatory, choćby klasyfikator k-NN. Tam od razu widać dlaczego coś powinno należeć do danej klasy, bo klasyfikacja sprowadza się do mierzenia odległości, a sieć działa trochę jak magiczne pudełko. Sam algorytm propagacji wstecznej jest moim zdaniem mniej intuicyjny niż analogiczny stosowany w programowaniu dynamicznym. Dla osoby, która nie miała nigdy do czynienia z uczeniem maszynowym, sieci neuronowe nie są dobre na początek, bo nie uczą jak należy podchodzić do tego typu zagadnień, nie uczą umiejętności doboru odpowiedniego narzędzia do konkretnego problemu. Brak tej umiejętności skutkuje antywzorcem ""złotego młotka"" https://sourcemaking.com/antipatterns/golden-hammer;"
"Robiłem projekt rozpoznający diagramy ERD na papierze i podejmujący decyzję, co to za encja etc. Pisałem to w pythonie, z użyciem OpenCV - tak naprawdę te libi do SI w Pythonie to wrapery na liby w C lub C++, więc nie ma znaczenia w czym piszesz. W zasadzie przepisałem projekt z pythona do czystego C, bo wrapery pythonowe miały błędy... to częste. Inna sprawa, że i tak to nie ma znaczenia - SI to nie język. Poczytaj o podejmowaniu decyzji, MIN/MAX, odcięcia Alfa/Beta, drzewa, lasy decyzyjne, klasyfikatory uczone, zbiory uczące, sieci neuronowe,  algorytmy genetyczne - to wszystko nawet w windowsowym BATcie zrobisz czy ASM, ale liczy się CO a nie W CZYM i JAK napiszesz. Część tych algorytmów to się robi nawet w VHDL .... Na zajęciach ze sztucznej inteligencji przez pół semestru jechaliśmy na kartkach, a potem w prologu. Na rozpoznawaniu i podejmowaniu decyzji, przez 2 semestry jechaliśmy na kartkach projektując sieci klasyfikatorów... ofc. na projekcie się implementowało - część w octave, część w matlabie, częśc w pythonie i C#, no a ja przepisałem potem wsio do C.;"
"TL;DR Nie wiem czy na pewno chcesz uczyć się SI. W zasadzie to ten termin już odszedł w zapomnienie. Aktualnie polecam szukać:  data mining data science predykcja, regresja, rozpoznawanie, optymalizacja uczenie maszynowe (machine learning) szeregi czasowe  I teraz: w zależności od tego co Cię interesuje, różne są rozwiązania:  jeśli użycie gotowych rozwiązań OSS, to Python raczej jest nie do pobicia (może jeszcze R, ale nie znam) jeśli chcesz coś pisać od nowa samemu, to masz do wyboru parę języków: a) Python b) Julia c) R d) Java e) Scala  Natomiast gdybyś naprawdę chciał się zająć sztuczną inteligencją (cognitive computing, typu gadający komputer dostosowujący rodzaj gry do nastroju gracza), to trzeba by pewnie postawić na wydajność:  C/C++ Julia Java  Jeśli chodzi o C# to nie wiem czy źle szukałem, czy te strony się ""źle"" indeksują, ale w tym języku materiałów na ww tematy jest bardzo mało. Do tego stopnia że aż to jest dziwne. Dla przykładu porównanie:  C# data mining: Około 636 000 wyników (0,53 s) Scala data mining: Około 3 740 000 wyników (0,33 s)  Tak samo jest z książkami o tej tematyce. Dla ludzi którzy stwierdzą że można to robić przecież w każdym języku, polecam obejrzenie poniższego filmiku a potem odpowiedzenie sobie na pytanie: w którym jeszcze z aktualnie topowych języków można pisać na C64 i jak to ma się do wydajności implementacji:;"
"Sztuczna inteligencja czy to tylko programowanie, czy może zbudowanie rozwiązania, które ów zostanie zaprogramowane wymaga zbudowania odpowiednich wzorów matematycznych? Dlaczego pytam? Przeglądając wczoraj notatki do wykładów prof. Włodzisław Duch oraz książkę prof. Ryszarda Tadeusiewicza ""Sieci neuronowe"" napotkałem całe mnóstwo przykładów matematycznych obrazujących sieci neuronowe. Przykładem może tu być Warstwa neuronów jako najprostsza sieć Z tego co wiem, a zaznaczam, że nie wiem jeszcze dużo o AI budując nawet prostego chatterbota należy zaprogramować neuron. Czy zatem chcąc zostać dobrym programistą AI należy pojąć wiedzę w takich dziedzin jak psychologia, budowa mózgu, wyższa matematyka, aby móc za pomocą matematyki zbudować właściwe wzory, a następnie je zaprogramować? Zbudowanie prostej sieci neuronowej będzie szybsze na etapie budowania wzoru matematycznego niż implementowanie. Będąc nowicjuszem pewne zbudowane matematycznie wzory mogą nie działać poprawnie po implementacji, ale z czasem człowiek to opanuje.;"
"Zaprogramowanie algorytmu sztucznej inteligencji / uczelnia maszynowego to jest szczegół. Wyzwanie stanowi wymyślenie reprezentacji oraz algorytmów, a tutaj bez matematyki może być raczej ciężko. Oczywiście jeśli chcesz tylko zaklepać istniejący algorytm to potrzeba raczej minimalnej wiedzy ;] Jeśli chodzi o budowę mózgu to raczej zbędna wiedza, bo już od lat próbowano zamodelować AI w oparciu o sieci neuronowe które miały przypominać te w mózgu i wielkich efektów to nie dało. Jest cała masa bardziej obiecujących metod uczelnia maszynowego niż sieci neuronowe jak choćby reguły asocjacyjne, drzewa decyzyjne, uczenie ze wzmocnieniem. Główny problem sieci neuronowych to ich absolutna nieczytelność. Nie da sie stwierdzić czemu sieć działa lub nie. Jak działa dla 9/10 przypadków to nie da sie jasno stwierdzić czemu dla tego 1 się myli. Jak już się sieć nauczy coś rozpoznawać to nie da się stwierdzić ""po czym rozpoznaje"", co czasem byłoby bardzo wartościowe.;"
"Nauką najbliższą sztucznej inteligencji jest KONGNITYWISTYKA - co zobrazować można dość prosto w schemacie 15 dziedzin nauki wchodzących w tę dziedzinę.  Matematyka Neurobiologia Statystyka Informatyka Biochemia Biologia Sztuczna inteligencja Biocybernetyka Antropologia Psychologia Filozofia umysłu Badania nad mózgiem Biofizyka Psychofizyka  Na podstawie książki Sztuczna Inteligencja autorstwa p. Marka Kasperskiego  Epistemologia Filozofia języka, filozofia umysłu Logika, matematyka, filozofia umysłu Informatyka, nauki o mózgu Psychologia kognitywna Psychologia rozwoju dziecka  Nie ma szerszej możliwości bycia specjalistą od sztucznej inteligencji nie posiadając interdyscyplinarnej wiedzy różnych dziedzin nauki. Są to zarówno nauki humanistyczne jak przykładowo filozofia umysłu a ścisłe matematyczne zakładając m.in. algebrę, analizę prawdopodobieństwa. Rozjaśniając temat Kognitywistyka zakładając przy tym, że nie każdy może mieć o tym pojęcie: Kognitywistyka jest syntezą wiedzy o umyśle pochodzącej z różnych źródeł. Składa się na nią:  Refleksja filozoficzna nad naturą umysłu. Wiedza o zachowaniu ludzi i zwierząt, oraz o ich stanach psychicznych. Biologiczne podłoże zjawisk psychicznych ‐ badania nad mózgiem. Psycholingwistyka, badanie języka. Modele matematyczne i podejście inżynierskie: zbudujmy sobie coś podobnego.  Na podstawie jednego z materiałów, które posiadam na ten temat: 5 dziedzin nauki o podstawowym znaczeniu dla zrozumienia umysłu to:  Psychologia poznawcza. Sztuczna inteligencja. Psycholingwistyka, lingwistyka kognitywna. Nauki o mózgu, neurobiologia, neuropsychologia i inne neuronauki. Filozofia umysłu. Przydatne nauki dodatkowe to: antropologia, psychofizyka, lingwistyka komputerową, sztuczne życie (artificial life), sieci neuronowe, algorytmy ewolucyjne, komputerowe widzenie (computer vision) i wiele innych.  Spora część w badaniu sztucznej inteligencji to neuronauki: Neuronauki na poziomie molekularnym i komórkowym: neurochemia, neuroendokrynologia, neurogenetyka, neurochirurgia, neurofarmakologia, neuropsychofarmakologia, neurobiologia neuronów, biofizyka neuronów ... Neronauki zajmujące się rozwojem i dojrzewaniem układu nerwowego, od stadium embrionalnego. Neuroanatomia, anatomia porównawcza mózgów. Konektonomika, badająca połączenia grup neuronów w mózgach. Neuronauki związane z chorobami układu nerwowego, takie jak neuropatologia, neurologia, neuropsychiatria, neuropsychologia, psycho‐neuro‐immunologia ... Neuronauki systemowe, specjalizujące się w badaniu działania poszczególnych zmysłów i kontroli ruchów. Chronobiologię, zajmującą się rytmami biologicznymi i subiektywnym postrzeganiem upływu czasu. Neurofizjologię ogólną, zajmującą się badaniem funkcjonowania układu nerwowego metodami elektrofizjologicznymi i innymi. Neurofizjologię zachowania (behawioralną), która jest nauką na pograniczu zagadnień mózg/umysł, zajmuje się badaniem związków stanów mózgu i zachowania. Neuronauki poznawcze, takie jak neurolingwistyka, szukające mechanizmów tworzenia się funkcji afektywno‐poznawczych, takich jak emocje, pamięć, uwaga, uczenie się ... Neurosocjologia, czyli neuronauki społeczne, próba uwzględnienia czynników społecznych w rozwoju zdolności komunikacyjnych, językowych, kulturowych, możliwości i ograniczeń wynikających z procesów ewolucyjnych i neurobiologicznych. Neuronauki komputerowe i systemowe, modelujące funkcje struktur neuronowych za pomocą symulacji komputerowych i teorii matematycznych. Informatyka neurokognitywna, próbująca czerpać inspiracje z analizy działania układu nerwowego do tworzenia użytecznych algorytmów. Neuroinżynieria, tworzenie interfejsów mózg‐komputer, neuroprotez współpracujących z układem nerwowym Neuroergonomia dążąca do zrozumienia i udoskonalenia relacji pomiędzy zdolnościami poznawczymi i artefaktami techniki i biznesu. Neuroobrazowanie i rozwój sprzętu do prowadzenia badań, pełniące rolę usługową w badaniach nad mózgiem. Aby móc pracować nad SI pisząc to dość skróconym przykładem trzeba pierw poznać samego siebie = jak działa Twój umysł. Zrozumienie umysłu == zrozumienie siebie. Przykład na sobie samym, tyczy się to jednak podejścia psychologicznego ludzi. Sztuczna inteligencja: umysł to maszyneria do przetwarzania informacji. Podstawa filozofii kognitywnej i psychologii kognitywnej. Proste procesy przetwarzania informacji tworzą procesy złożone, inteligentne działanie. Symbole + reguły manipulacji => nieskończenie wiele kombinacji. Algorytmy manipulowania symbolami => nieskończenie złożone zachowanie. Algorytmy + reprezentacje wiedzy pozwolą zrozumieć umysł. Przetwarzanie informacji nie musi zachodzić w białkowych mózgach. Podsumowując. Sztuczną inteligencje pod kątem programowania podzielić można na 1/ programowanie przy wykorzystaniu gotowych algorytmów lub 2/ budowę tychże algorytmów łącząc interdyscyplinarną wiedzę przy czym samo programowanie to najmniej skomplikowana czynność posiadając algorytm wyrażony matematycznie. Znaczenie ma też poziom na którym chce się budować SI.;"
"Jeszcze kilka miesięcy temu, testując GPT-3, w sporze pod tytułem ""czy AI zastąpi programistów"" byłem raczej po stronie twierdzącej ""nie sądzę"". Ale z biegiem czasu zaczynam mieć coraz więcej wątpliwości. Do napisania tego posta zainspirował mnie filmik pewnego dotnetowego youtubera, który użył go do napisania webowego API. O ile wcześniej trzeba było faktycznie ""popychać"" model w odpowiednim kierunku, sugerować mu rozwiązania, wytykać błędy, to tu właściwie mamy przykład utworzenia małego serwisu tak po prostu bez większych problemów. Był na filmie problem z hasłami w connection stringu, ale zauważcie że ze strony użytkownika nie trzeba było podpowiadać żadnych konkretów. Nick wpisał po prostu ""zrób żeby było bezpieczniej"" a GPT tak zrobiło. Problem ze skalowaniem? Wpisał ""zrób żeby się skalowało"". I tyle. Coś co zajęło mi długie lata nauki, testowania, prób i błędów, tutaj dostajemy w parę sekund. Ze skutkiem może i nawet lepszym. Ktoś mógłby powiedzieć: no dobra, ale tu jest tylko pokazane proste API. Ale czy mamy właściwie przesłanki żeby twierdzić, że z większym projektem nie będzie to działać podobnie? Ogranicza nas teraz liczba tokenów, które model jest w stanie przyjąć. Ale czy to faktycznie jest nie do przeskoczenia w ciągu najbliższych paru lat (a może miesięcy)? Czyżbyśmy właśnie byli świadkami momentu w którym nauka składni języków i algorytmów przestaje mieć sens? Czyżby stereotypowy, aspołeczny programista studiujący ficzery różnich języków właśnie przestał być potrzebny, a jedyne co zostanie na rynku to osoba definiująca wymagania biznesowe?;"
"artykuł:   Serio będziemy lykać propagandę, że już lada moment ""AI nas zastąpi"", skoro AI to ciągle matematyczny model statystyczny przewidujący kolejne słowa (nie tak działa nasz mózg) -ani ""sztuczna"" ani ""inteligencja"", na razie to matematyka z dużą mocą obliczeniową;"
"mam nadzieję, że chatgpt zastąpi programistę, który zastanawia się co zrobić, gdy chatgpt zastąpi programistów i wtedy nie będę musiał się zastanawiać;"
"Razem z kumplami z projektu zakładamy firmę budowlano-remontową. Na razie robimy kosztorys i panujemy zakupy. Myślimy ,że jeszcze 2,3 lata i AI nas zastąpi więc szykujemy się na najgorsze.;"
"Pytanie co rozumiesz przez ""sztuczną inteligencję"". Jeśli rozmawiamy z punktu widzenia techniczno-naukowego to jest tak:  deep learning to podzbiór działu zwanego ""sieci neuronowe"" sieci neuronowe to podzbiór działu zwanego ""uczeniem maszynowym"" uczenie maszynowe to podzbiór działu zwanego ""sztuczna inteligencja""  Więc jeśli ktokolwiek zajmuje się LLMami (a tym jest GPT) to zajmuje się także i AI, chociaż nie każdy, kto zajmuje się AI musi zajmować się akurat LLMami. Natomiast jeśli pytasz, czy ChatGPT jest inteligentny w sensie ludzkim to nie jest inteligentny w sensie ludzkim. Co więcej, obecnie nie wiemy jak taka sztuczna inteligencja miałaby działać bo to co w tej chwili mamy to po prostu AI działające na zasadzie chińskiej komnaty: https://en.wikipedia.org/wiki/Chinese_room . W skrócie: jeśli nie znasz angielskiego, ale gdy będziesz obrywał za każdym razem gdy ktoś powie ""give me a stone"", a ty tego kamienia nie dostarczysz, to w końcu na chybił-trafił odkryjesz, że gdy usłyszysz taki zwrot to masz dać komuś kamień. I nie będziesz wiedział, co oznacza ""give me"", ani ""a stone"", ale będziesz wiedział, że na hasło ""give me a stone"" musisz komuś podać kamień.;"
"Czemu podałeś link w taki sposób żeby nie dało się go kliknąć Powody są podane w tym artykule i bynajmniej nie jest to AI Przykład podany w artykule że ktoś był w stanie za pomocą AI w pojedynkę stworzyć grę przypominającą Angry Birds. Czy ktoś w ogóle miał wątpliwości że jedna osoba jest w stanie stworzyć klon angry birds nawet bez pomocy sztucznej inteligencji? Co to mają za sztuczną inteligencję że zastąpi 80% programistów? Znane mi narzędzia być może byłyby w stanie zastąpić może 20% i to tylko przy założeniu że robili jakieś powtarzalne bzdety. Nie pozostaje nic tylko życzyć tej firmie powodzenia. U mnie w firmie jakiś czas temu dano wszystkim copilota, od razu otwarcie powiedziano że mają nadzieję oszczędzić w ten sposób 0.5 miliona dolarów rocznie. Dzieląc to przez średnią pensję programisty w firmie wychodzi że liczą na zastąpienie 0.1% programistów co jest moim zdaniem dość realnym oczekiwaniem.;"
"Bo nie chcę promować tej strony. Ostatni punkt IA w tle przecież jest opisany na tamtej stronie, a moim zdaniem pewnie dominujący. Nie wiem tego, ale na pewno wystarczy mniej ludzi do ogarnięcia niż dawniej skoro wiele rzeczy można zautomatyzować i przyspieszyć. IA to nie tylko to co znamy a open IA ale także są dostosowane boty do zadań - niektóre gałęzie mają takie dostosowane do ich typów działalności w dużym zakresie. A jednak zastąpi w przypadku tej firmy - gdzie było ich 5 i robili na bazie potrzeby dostosowania do wykonywanych zadań przez urządzenia.  Myślę że to będzie się zmieniać, na pewno będą przemiany kultorowo pracownice dzięki takim rozwiązaniom. Powoli już je widać. Jak tutaj przykład wcale nie najnowszego generatora - co z 1 fotki robi film do podkładu.;"
"Odnoszę takie samo wrażenie. Połowa to boty hrowe, 1/4 jacyś frustraci życiowi, którzy nie zgadzają się z każdym autorem wątku o czymkolwiek by nie był aby tylko się nie zgadzać co do zasady, paru trolli i może z 10% to serio programiści, którzy opiniują obiektywnie dany temat, tak jak jest w rzeczywistości. To był mój ostatni wątek około karierowy na tym forum, bo widzę, że tutaj jakakolwiek poważna dyskusja nie ma sensu. To co jest na forum, czy linkedinie, a to z czym się spotykam na co dzień w pracy, w projektach, rozmawiając ze znajomymi z branży to jakby 2 różne światy. Nie znam nikogo kogo by zwolnili z projektu/z kontraktorni, nie znam nikogo komu by kazali przyjść do biura ze 100% remote, nie znam nikogo kto by pracy szukał dłużej niż tydzień. Jedyne co mnie boli to to, że samych ofert na linku dostaję coraz więcej w hybrydzie i tak jak ktoś wyżej napisał traktuję to jako zwykłe ""sprawdzam"" hr-owców, tak samo jak i większość tych wysrywów w niniejszym wątku. ps, ucinając jakieś powyższe spekulacje, nie szukam pracy i jestem świeżo po podwyżce, ale lubię mieć kontakt z rynkiem pracy i czasem chodzę na rozmowy dla sportu. Tak, kupiłem chatę na zadupiu, bo wolałbym się zastrzelić niż mieszkać w betonozie. Nie muszę pracować w IT, mam już inne źródła dochodu, których się dorobiłem ciężką pracą, także jak kiedyś stanę przed wyborem iść do pracy stacjonarnej czy olać IT to wypnę gołą dupę w stronę branży i tyle mnie widzieli. Na dzień dzisiejszy mam 30k papieru na fakturze z jednego projektu i kontraktornia prawie całowała mnie po rękach jak przedłużyłem kontrakt. Oczywiście o jakiejś hybrydzie nikt mi nigdy nawet nie wspomniał, bo bym się posikał ze śmiechu. Jak przychodziłem do firmy to powiedziano mi, że fajnie jakbym wpadał do firmy chociaż 2-3 roku się pokazać, na jakieś grubsze planningi. Zaznaczyłem od razu, że nigdy tam nie pojadę, bo nie ma takiej potrzeby i w żaden sposób nie wpłynie to moją pracę więc nie będę tracił czasu. Od tamtej pory temat nigdy się nie pojawił. Fakty są takie, że albo ktoś jest mężczyzną, fachowcem, albo popychadłem, który dzisiaj jest na remote, a jutro biegnie na hybrydę bo się boi, że ktoś go zastąpi, albo Pan manager okrzyczy.;"
"Ja do tej grupy dorzuciłbym jeszcze 'wanna be' programistów. Świetnie widać to w wątkach z chatgpt, gdzie namiętnie piszą jak to już za chwile całe działy IT zastąpi jedna osoba. Co do tematu, to mam podobne spostrzeżenia. Ustępstwa i zgadzanie się na kolejne durne pomysły to sranie do własnego gniazda. Jeśli w firmie dostarcza się 'wartość' i jest to w dodatku widoczne w jakimś backlogu to jest się bezpiecznym. Zwłaszcza jeśli poza wiedzą techniczną idzie wiedza domenowa.;"
"po 9-ciu latach pracy nie wiesz, że pisze się ""rekruterką"" a nie rekruterkom ?  Dziwiły bo może nie rozumiałaś wymagań.  Tego to nawet najtęższe umysły odpowiedzialne za rozwój sztucznej inteligencji nie są w stanie przewidzieć, bo równie dobrze mogą pojawić się nowe o których nie wiemy. PS. Podszywanie się pod autentyczną osobę jest w ogóle dopuszczalne ? Bo widzę, że jest rekruterka o takim imieniu i nazwisku na LN ale nie wierze żeby pod własnym imieniem i nazwiskiem robiła z siebie idiotkę przed potencjalnymi klientami.;"
"Uczyć się robić bardziej skomplikowanych rzeczy np właśnie tworzenia model AI, albo klepania bardzo dużych projektów itd Coś w czym sztuczna inteligencja nas nie zastąpi jeszcze przez długie lata. Ale w sumie nie wiem czy QA zastąpi AI bo oni mają testować to tak jakby było użytkownikami a nimi są ludzie, więc w tym wypadku AI nigdy nie zastąpi człowieka myślę;"
"AI to jest sztuczny twór, zastąpi najpewniej pewne zawody, ale tylko niektóre. Problem z AI jest taki, że to będzie czyjaś własność (przynajmniej na początku) i można ja sparametryzować - trochę to przypomina kontrolę nad szlakami handlowymi i przepływem pieniędzy. Drugi problem jaki dostrzegam - nie da się zastąpić dobrej jakości prac rzemieślniczych (nie mówie tu o stukaniu młotkiem w kawałek metalu) i już. Inspiracja i talent to jest jakby punktowe IQ na poziomie infinity, żadne AI nigdy temu nie dorówna. Odtwarzanie istniejących rzeczy w różnych permutacjach / wariantach - spoko, kreacja - to jest jakby niewykonalne z definicji, bo nigdy nie powstanie model działania przewyższający wyobraźnię. ""Pojemność"" umysłu i jego kwantowa natura jest niewyobrażalna.;"
"Opiszę sytuację z pracy mojego Kolegi. Zatrudnili gostka który nakłamał w CV, czego on nie umie do analizowania danych. Rozbraja mnie, że rekrutują człowieka bez sprawdzania wiedzy ale skoro firma chce wywalać pieniądze kto jej zabroni. Gostek młody jeszcze student, wciąż opowiada jak to AI zastąpi wszystko. Jest on totalnym głąbem który nic nie ogarnia. Ciężko mi to pisać bo to takie irracjonalne ale odkrycie znaku nowej linii to było dla typa coś nielada wielkiego. Wszystko co robi, robi używając chatGP. Jest właśnie w fazie wylotu z firmy. Bo szefostwo się pokapowało po sześciu( !!! ) miesiącach, ze zatrudnili idiotę. Także zbytnia wiara w Ai zdecydowanie może przybliżyć do bezrobocia. + generować tylko więcej problemów gdy jakiś przygłup traktuje to co wypluwa za prawdę objawioną;"
"Moim zdaniem obawa, że AI zabierze pracę programistom, jest słuszna jak na warunki 2023, ale w perspektywie np. dekady okaże się, że nie. Po prostu teraz dokonał się przełom i zobaczyliśmy cuda i wydaje się nam, że AI nas zastąpi. Ale potem spowszednieje to i trzeba będzie wrócić do prawdziwej roboty. I dokonać jakiejś reewaluacji tego, co to znaczy być programistą (bo już nie można będzie powiedzieć, że ""programista pisze kod"", tylko trzeba będzie się szerzej zdefiniować np. ""projektuję architekturę rozwiązań technologicznych"") Swoją drogą ja się zastanawiam, czy ChatGPT mogłoby pomóc również w architekturze - np. tutaj gościu kazał napisać AI 5 mikroserwisów: https://twitter.com/joeprkns/status/1635933638725451779 a jeśli tego byłoby więcej - czyli co jeśli ChatGPT pisałoby 100 mikroserwisów (albo jakiś złożony monolit podzielony na wiele modułów). Czy zaprojektowałoby dobrą architekturę do tego? Na ile to jest utrzymywalne na większą skalę? Czy ChatGPT umiałby się poruszać we własnym spaghetti czy jednak jego własne spaghetti by go powstrzymywało i nawet apka pisana w 100% przez AI musiałaby być dobrze zaprojektowana?;"
"W ""Programiście"" 111: Sieci neuronowe od podstaw. ""Mam wrażenie, że wokół sieci neuronowych narosło wiele mitów. Nawet niektórzy starsi członkowie mojej rodziny na hasło „sztuczna inteligencja” robią posępną minę, niezależnie od tego, czy mowa jest o generowaniu obrazów czy – na przykład – o rozpoznawaniu odręcznego pisma czy też tłumaczeniu tekstu z jednego języka na drugi. Tymczasem sieć neuronowa, czy bardziej precyzyjnie wielowarstwowy perceptron, jest stosunkowo prostym matematycznym konstruktem, do zrozumienia którego powinna wystarczyć wiedza na poziomie szkoły średniej..."" Więcej o tym artykule i jego fragment do pobrania Poza tym w numerze:  HAL9000 @ localhost, czyli programujemy lokalne LLMy; LLM w użyciu – automatyczne podsumowywanie konwersacji email; Kafka w .NET i Docker; Sieci neuronowe od podstaw; Passkey, klucze fizyczne i passwordless; Podatność w Vim modeline; Kolory (dla opornych); Kierowanie kierownikiem.  Szczegółowy spis treści ""Programista"" nr 111 obecenie jest w Empikach lub można go zamówić w prenumeracie (też elektroniczne wydania). Życzmy miłej lektury. A okładka wygląda tak:;"
"15 minut gadania o czymś co może trwać 30 sekund byle żeby wcisnąć więcej reklam. Nie obejrzałem całości bo mam ciekawsze rzeczy do roboty ale zgaduję, że to ten sam typ gadania który wraca do kilka miesięcy, wiec strzelam że nadal potrafi pisać tylko nowe rzeczy. Nie naprawi buga w programie na 2mln linii kodu, więc czuję się bezpiecznie. Prędzej AI zastąpi ludzi którzy produkują filmy na 10+minut żeby algorytm YT mógł proponować ich filmiki.;"
"Do tej pory podchodziłem mocno sceptycznie do tego, że AI zastąpi programistów ale coraz bardziej jestem przekonany, że eldorado w IT skończy się, a zarobki bardzo mocno spadną.;"
"Tutaj masz ciekawy artykuł o rozpoznawaniu pisma: Sieci neuronowe, aproksymacja i rozpoznawanie pisma;"
"Sztuczna Inteligencja to dużo więcej niż sztuczne sieci neuronowe, chociażby: algorytmy genetyczne, systemy eksperckie, algorytmy gier (np. mini-max), zbiory rozmyte, logika predykatów, itd. Na początek można chyba polecić książkę ""Metody i techniki sztucznej inteligencji"" autorstwa Leszka Rutkowskiego.;"
Proponuję sieci Backpropagation. Sztuczne sieci neuronowe i algorytmy genetyczne Możesz też poczytać o systemach wieloagentowych.;
"Można powiedzieć że chodzi mi po głowie zrobienie doktoratu z wolnej stopy, tematyka możliwe że sztuczna inteligencja, możliwe, że sieci neuronowe. Jeszcze nie zastanawiałem się dokładnie nad tematem pracy.;"
Ma ktos info kiedy wreszcie AI zastapi dzialy reklamacji w bankach?   ai.png (44 KB) - ściągnięć: 5;
"Jeśli dobrze myślę masz na myśli tą grę co są 4-5 pasów i jeżdżą samochody, to z góry widać, że najlepiej w pamięci(policzyć parę ruchów do przodu), czyli masz grid, nie musisz go sobie wyobrażać akurat, ale masz każdy samochód z danego pasa na jakiejś pozycji i co klatkę o ileś się przesuwa kratek, teraz musisz znaleźć taką kombinację, ruchów, która przejdzie na drugą stronę i nie trafi na żadne auto. Najlepiej całą grę zrobić dyskretną do minimalnych kroków i robisz przejście grafu, czyli idziesz, idziesz i jak trafisz na auto, to cofasz jedną klatkę się do tyłu i wybierasz inne działanie np. czekanie 1-2 ruchy, aż przejdzie auto i dalej do przodu, aż nie przejdziesz na drugą stronę, kombinacja, która przejdzie to będzie twoje rozwiązanie. Oczywiście co krok żaby aktualizujesz położenie samochodów, ale realną żabą nie ruszasz to robisz w pamięci dopiero jak wynik w pamięci przejdzie to wykonujesz ruchy żaby daną ścieżką. To najprostsze co mi przychodzi do głowy i na pewno zadziała. Jak sieci neuronowe chcesz użyć, to byś musiał dawać jakieś informacje sieci gdzie są położone wszystkie samochody, jeśli mają jednakową prędkość to tyle informacji starczy, jeśli nie to położenie + prędkość lub nawet i przyspieszenie. Następnie podejmować decyzję czy do przodu, do tyłu, czy czekać w miejscu jeden tick. Jeśli chcesz dać screena z gry zamiast położeń samochodów to sieć znacznie dłużej i znacznie więcej danych uczących będzie potrzebować żeby się nauczyć przechodzić grę. Rozwiązanie bez użycia sieci neuronowych jest najłatwiejsze i powinno się od tego zacząć i potem zrobić z sieciami neuronowymi jako następne rozwiązanie tego samego problemu.;"
"Nie czaję. Masz jakieś pytanie? Co chcesz kompresować? Bo aproksymacja funkcji za pomocą SN to zagadnienie już całkiem dobrze poznane. W sumie jeśli się zastanowić to sieci neuronowe nie są niczym innym niż funkcjami aproksymującymi, tj. takimi, które na podstawie zbiorów wejścia I = {I(0), I(1), I(2), I(3)... I(n)} i wyjścia O = {O(0), O(1), O(2), O(3)... O(n)} tworzą funkcję F, taką, że F(I(n))=P(n), gdzie fit(P(n), O(n)) = min (lub max, w zależności jak się ją zdefiniuje).;"
"Sieci neuronowe to kolejne ""narzędzie"" i jak widać na niektórych poletkach się sprawdza, na niektórych nie. Inteligencji w tym zero ... Ja nawet przyrównałbym to do młotka. No bo co w tym młotku szczególnego jest : kawał metalu z przyczepionym jakimś drewnem - no nic szczególnego. Ściany tym nie pomaluje, samochodu nie poprowadzę - ale np. już gwoździa wbiję, wykorzystam jako instrument muzyczny i zastosuję jako ""mocny"" argument perswazji w konfrontacjach międzyludzkich :) A jak ten młotek źle zastosuję - to sobie palca obiję i skończy się to moją wielką krytyką tego narzędzia ( , oczywiście bólem ) i nawet pomyślę o wbijaniu gwoździ np. butem !;"
"Nie wiedziałem, co to takiego. Sprawdziłem. To zdanie, które zacytowałeś to wyraz mojego żalu. Jestem amatorem w AI, nie zajmuję się tym zawodowo, ale mam kilka pomysłów, trochę kodu. I nikt z akademików nie chce ze mną nawet porozmawiać! Próbowałem na uniwersytecie w Helsinkach (mieszkam w Finlandii), w Polsce, w Rosji, w Niemczech, nawet w Chinach. Jedna z ciekawszych odpowiedzi (z Helsinek) brzmiała tak: Thanks for asking, but we do not arrange appointments unless it is clear how/why the matter should concern our university. Odpisałem, że uniwersytet będzie niewątpliwie trwać, z moim algorytmem czy bez niego. No bo się trochę zdenerwowałem (co mi się rzadko zdarza). Akademicy od tego są, żeby się tym zajmować. Wracając do sieci neuronowych - nie neguję ich możliwości, tylko zauważam czym naprawdę (tj. z punktu widzenia matematyki) są. Według mnie problem inteligencji można rozwiązać stawiając najpierw zadanie, a nie architekturę rozwiązania. Zadaniem powinna być maksymalizacja wartości oczekiwanej zysku. Funkcji wypłaty. I wszystko jedno, czy rozwiązanie będziemy się starali znaleźć w przestrzeni możliwych sieci o zadanej architekturze czy w czymś innym. Sieci neuronowe to tylko marketingowa nazwa szczególnej klasy programów. Z ich struktury nie wynika, że będą się starały zmaksymalizować wartość oczekiwaną zysku, przeciwnie, mogą aproksymować dowolny automat.;"
"gdzie przeczytałam takie zdanie i nie mogę sobie przypomnieć gdzie to było? ""sztuczna inteligencja nie jest inteligencją , tak uczenie maszynowe nie jest uczeniem"" ale się z nim zgadzam, a ludziom się wydaje że sztuczna inteligencja to naprawdę coś jak z filmów o superbohaterach;"
"No, ale wtedy w ogóle odsieje 99,9% pytań, no i też nie zastąpi tych profesjonalnych programistów, których ma niby zastąpić.;"
"Uwaga studenci !!! Portal Praca.pl ogłosił konkurs pisarski dla uczniów i studentów z atrakcyjnymi nagrodami pt. „Rozwój sztucznej inteligencji (AI) i jej wpływ na rynek pracy w przyszłości” Więcej informacji na temat konkursu można znaleźć na stronie internetowej: https://www.praca.pl/konkurs-dla-studentow-i-uczniow Na zwycięzców czekają atrakcyjne nagrody, a trzy najlepsze prace zostaną dodatkowo zaprezentowane szerokiej publiczności na portalu Praca.pl. Cel Konkursu Chcemy poznać opinie młodych osób na rozpowszechnianie się nowych technologii, które niewątpliwe mają duży wpływ na rynek pracy, ale i nasze codzienne funkcjonowanie. Czy sztuczna inteligencja budzi w nas strach czy entuzjazm? Nagrody konkursowe: 1 miejsce – nagroda pieniężna: 1500 złotych 2 miejsce – tablet Samsung Galaxy Tab A7 Lite 8.7″3/32 GB Wi-Fi Szary 3 miejsce – słuchawki dokanałowe SONY WFC500 Czarne Jak wziąć udział? W konkursie mogą wziąć udział studenci oraz uczniowie szkół średnich, którzy ukończyli 18. rok życia. Należy wypełnić formularz kontaktowy i wyrazić zgodę na przetwarzanie danych osobowych. Należy napisać artykuł na wyznaczony temat z liczbą znaków nie mniejszą niż 5000 (wraz ze spacjami). Artykuł musi być unikalny. Gotowy tekst trzeba przesłać wraz z formularzem kontaktowym na adres e-mail: konkurs@praca.pl. Temat maila powinien brzmieć “Praca konkursowa”. Warunki i tryb przeprowadzenia konkursu* Rozpoczęcie konkursu – 22.05.2023 Termin składania prac konkursowych – 24.07.2023 Ocena prac i wyłonienie zwycięzcy – 28.08.2023 Ogłoszenie wyników – 04.09.2023 *Organizator zastrzega sobie prawo do zmiany warunków konkursu. Strona konkursu: https://www.praca.pl/konkurs-dla-studentow-i-uczniow Regulamin konkursu: https://www.praca.pl/praca2/assets/files/konkurs-dla-studentow-i-uczniow-regulamin.pdf;"
"OK! Rozumiem. Czy po swoich dotychczasowych doświadczeniach poleciłbyś coś innego dla C++? Ja ogólnie wiem o co chodzi ze SI jednak na studiach inżynierskich nie miałem SI (w PL uważa się, że to poziom magisterski). Czy mógłbyś nakreślić w skrócie ścieżkę rozwojową jaką należy przebyć by swobodnie posługiwać się SI? Chodzi mi o konieczną lekturę, aparat matematyczny i zalecane ćwiczenia. Co uważasz za konieczne, a co za zalecane? W procesie opanowywania SI. Przypominam, że zależy mi na uczeniu bez nauczyciela (zarówno ja tak chce się uczyć jak i sztuczne sieci neuronowe jakie mam zamiar używać).;"
"Oj tam zaraz bezmyślni. Gdyby dziennikarze pisali to co Ty piszesz, to nikt poza programistami nie chciałby tego czytać i taki dziennikarz nic by nie zarobił. Ten problem nie tylko dotyczy AI. Na przykład w polityce jest taki Jacek Bartosiak i Marek Budzisz, a nawet niektórzy generałowie, którzy pierniczą straszne głupoty na temat Rosji, Putina i armii rosyjskiej, a dziennikarze te bzdury chętnie podchwytują bo one dobrze się sprzedają i biznes się kręci. Tak samo Konfederacja i Mentzen opowiadają straszne debilizmy, ale że więcej jest ludzi głupich niż mądrych to dzięki temu kanał Mentzena na youtube się rozwija. Ostatnio szef Nvidii Jensen Huang powiedział żeby młodzi ludzie nie uczyli się programować tylko żeby zajęli się rolnictwem. Myślę, że sztuczna inteligencja zastąpi tzw. ""klepaczy kodu"", a do rozwiązywania skomplikowanych problemów programistycznych będzie potrzebny człowiek, który będzie umiał korzystać z pomocy sztucznej inteligencji.  Projekty w całości nie składają się wyłącznie z monotonnych, powtarzalnych ticketów, ale myślę, że w Polsce takie tickety stanowią przeważającą większość.;"
To co - zastąpi czy nie?;
zastąpi;
nie zastąpi;
"Pytanie jest niejasne bo jeśli okaże się że Devin w 2024 wykona w teamie 10 osób (wliczając scrum mastera) pracę dwóch juniorów to nie zastąpi. Jeśli jednak w 2030 wykona w teamie pracę 6 seniorów to też nie zastąpi bo team będzie liczył 20 osób (10 analityków, scrum mastera + 10 QA);"
"Niby jak to miałoby działać? Fizyka powstała po to, żeby móc przewidywać pewne zjawiska. Tzn. wiemy, że jeśli włożymy piłkę o objętości V i ciężarze Q do wody to jesteśmy w stanie wyliczyć, czy piłka zanurzy się całkowicie czy nie. Takie teoretyczne modele powstają w dwojaki sposób:  albo ktoś tworzy sobie równanie i potem sprawdza, czy pasuje do rzeczywistości. Czyli najpierw zakłada, że Q = g x ro x V i potem wrzuca różne piłki żeby sprawdzić, czy mu się to zgodzi. albo ktoś robi pomiary i na ich podstawie tworzy model. Czyli najpierw wrzuca piłkę, potem obserwuje i wybiega nago krzycząc ""EUREKA"" by w końcu zapisać równanie.  W obu przypadkach sieć neuronowa nie nadaje się jako zamiennik pomiarów z prostej przyczyny - nigdy przewidywania sieci nie będą bardziej prawdziwe od poprawnie przeprowadzonych pomiarów. Natomiast jest jeszcze kwestia symulacji. Mając jakiś dobrze opisany model, np. sieć krystaliczną, można patrzeć co się stanie gdy zaaplikujemy jakieś dodatkowe warunki. Tutaj sieci neuronowe mogą się przydać, przy czym nie mogą one w całości zastąpić modelu.;"
"Odpowiedź brzmi ""nie"" z trzech powodów:  model jest opisem rzeczywistości, sieć neuronowa to po prostu przetworzone w jakiś sposób dane. sieć neuronowa będzie zawsze obciążona rzeczywistością, tj. błędem pomiarowym pochodzącym z danych empirycznych i niedoskonałością badanych obiektów dodatkowo jest jeszcze odwrotność - chaos deterministyczny i niedeterministyczny to fakt, więc sieci neuronowe będą głupieć gdy spróbujesz takimi chaotycznymi danymi nakarmić sieć;"
"Tu jest coś na podobnej zasadzie, tylko sieci neuronowe uczyły się z wyników symulacji a nie pomiarów z rzeczywistości.  A co do rozumienia przez ludzi w podobnej sytuacji, a właściwe nawet znacznie dalej posuniętej, to przypomniało mi się krótkie opowiadanko Teda Chianga. https://www.nature.com/articles/35014679;"
"No to jeszcze raz - mając model matematyczny, tj. np. a = dv/dt jesteś w stanie łatwo przeliczyć, że skoro F = ma to F = mv/t. Znając ten model i mając przebieg F(t) oraz znając m jesteś w stanie łatwo wyznaczyć, jak zmieniała się prędkość danego ciała. Takie coś możesz podstawić do kolejnego modelu, i do kolejnego, i do kolejnego itp. itd.  Ja też.  Nie. Podstawą każdej sieci neuronowej są pomiary empiryczne więc nie ma potrzeby nic ""konfrontować"".  Podpowiem ci coś: przy każdym eksperymencie empirycznym istnieje coś takiego jak ""błąd pomiaru"" i każda hipoteza jest testowana z pewnym prawdopodobieństwem. Różnica jest taka, że model matematyczny powstaje bez udziału błędu pomiaru, sieci neuronowe powstają z ich udziałem. Powiem jeszcze coś więcej: prawo fizyki jest czymś bardzo ""słabym"". Tzn. dowolne prawo fizyki może zostać podważone jeśli tylko znajdziesz lepszy sposób opisu. Przykładowo - stwierdzenie, że Słońce się kręci wokół Ziemi jest prawdą. Tak samo jak to, że Ziemia kręci się wokół Słońca. To jedynie kwestia tego, gdzie ci wygodniej postawić obserwatora.  Tak, ale na podstawie właśnie przewidywań teoretycznych wiadomo, gdzie szukać. Wspomniana przeze mnie transformacja Lorentza - przekształcenie stricte matematyczne - doprowadziło do tego, że Einstein opracował teorię względności (któr  Wartość tego modelu jest większa ponieważ pozwala na przewidywanie co się stanie. I jeśli to dla ciebie ""numerologia"" to tak, to jest numerologia.  Nie można tego tak podsumować.  Modele matematycznie nie są ""w tej chwili lepsze"" bo tutaj nie ma czegoś takiego jak ""lepsze"" czy ""gorsze"". Kwestia jest taka, że nie możesz zastąpić modeli matematycznych sieciami neuronowymi bo są to rzeczy, które służą do innych rzeczy.  Tłumaczyłem ci już, że istnieją zachowania chaotyczne gdzie z powodu błędów pomiarowych sieć neuronowa nie będzie w stanie zwrócić ci prawidłowego wyniku.;"
Owszem - tylko co to ma wspólnego z rzeczywistością?  Więc jakim cudem istnieją już w rzeczywistości sieci neuronowe które tworzą modele na podstawie samych tylko obserwacji?  Jak wyżej.  Jak wyżej.  Więc oba stwierdzenia mają zerową wartość poznawczą z punktu widzenia opisu rzeczywistości.  Powiedzmy tak. Szansa trafienie szóstki rzucając kostkę to 1/6. Jeśli trafiłem 1000 razy pod rząd szóstkę to znaczy że model opisujący szansę trafienia jest błędny czy nie jest błędny ale tylko dlatego że znam liczbę ścianek sześciościennej kostki?  Do czego służą w takim razie modele matematyczne a do czego służą sieci neuronowe. Weź pod uwagę że obecnie sieci neuronowe bazując na danych empirycznych tworząc modele matematyczne i konfrontują je z kolejnymi obserwacjami :)  Jaka jest zatem wartość poznawcza modelu matematycznego przy opisie zjawiska gdzie nie możesz przewidzieć ewolucji układu ani w przód ani w tył z powodu jego inherentnej chaotyczności?;
"W moim rozumieniu strategia ma różnicować zachowanie pomiędzy obiektami tej samej klasy. Pierwszy z brzegu przykład jaki mi przychodzi, to gra, np. taka:https://play.google.com/store/apps/details?id=com.aso.tdf2012int Gracz kieruje tam drużyną kolarzy i ustawia im zużywaną moc. W grze ""uczestniczy"" też ileś tam NPC mających różne cele ustalane przez ""trenera"", w zależności od celu drużyny i roli konkretnego zawodnika w drużynie Każdy NPC, to ta sama klasa, ale jak widać wyżej, ma kierować się specyficzną logiką. Załóżmy, że jest dostaje jakieś dane na wejściu (sytuacja wyścigu) i do określenia jest wyłącznie % mocy jaką zawodnik ma generować. Czyli uproszczona klasa zawodnika to: public class Npc{ private int stamina; private PlayerAi playerAi ......   public float calculateCurrentPerformance(RaceState raceState){     return playerAi.calculateCurrentPerformance(raceState)   } }  gdzie PlayerAi to dla uproszczenia interface funkcyjny: public interface PlayerAi{   float calculateCurrentPerformance(RaceState raceState) }  Do tego mamy różne implementacje tego Ai, np. oparte o jakieś sieci neuronowe wyliczenia co najlepiej robić, żeby osiągnąć wyznaczony przez trenera cel. W zależności od sytuacji druzyny, trener ustawia różne priorytety dla ""zawodnika"", poprzez wstrzyknięcie odpowiedniej implementacji. Nie wiem jak to jest zrobione w zeszłorocznej edycji, ale parę lat temu było zaimplementowane mniej więcej tak jak napisałem wyżej. Przykład wybrany z myślą o @renderme, bo programowanie to nie tylko front i back end ;);"
"Cześć, jako że to mój pierwszy post na tym forum chciałbym serdecznie wszystkich przywitać :) Od października planuję rozpocząć studia. Chciałbym kiedyś pracować w analizie danych. Zależy mi żeby program studiów uwzględniał także nowe technologie jak np. uczenie maszynowe, sieci neuronowe, data mining, technologie z Big Daty itd. Niedawno natrafiłem na nową specjalność na matematyce stosowanej: analiza danych na Politechnice Krakowskiej. Program wydaje się być na pierwszy rzuć oka bardzo korzystny: http://www.syllabus.pk.edu.pl/plan/show/html.pk?id=3829 Niestety ostatnio przeczytałem kilka opinii niepochlebnych na temat PK, że albo przedmioty realizowane są na zbyt niskim poziomie (tzn np. pół semestru liczenie całek jednej zmiennych zamiast iść na przód z materiałem) albo prowadzący niewiele tłumaczą albo zadania zaliczeniowe są na poziomie kilku pierwszych stron tutoriali. Czy to ma znaczenie? W końcu studia, to podobno tylko miejsce gdzie prowadzący wskazują drogę, a cała nauka odbywa się we własnym zakresie i tylko ode mnie zależy ile po tych studiach będę umiał. A może opinie o PK są przesadzone? Podzielcie się swoimi opiniami albo opiniami swoich znajomych którzy tam studiują lub studiowali. Inna ścieżka jaka mnie interesuje, to matematyka na UJ (bardzo solidna podstawa probabilistyczna, co ma znaczenie w AD) + możliwość dobierania przedmiotów wg zainteresowań. Na informatykę na UJ jestem za słaby, więc nie biorę takiej opcji pod uwagę. Na AGH także jest kierunek Inżynieria i Analiza Danych, na wydziale Geologii i Ochrony środowiska, przejrzałem syllabus i jednak nie jest on zachwycający. O ile jest sporo przedmiotów odnośnie baz danych ML, BD to analiza dotyczy głównie danych w nauce o ziemi. Pod uwagę biorę tylko Kraków, niby teraz jest zdalne nauczanie, ale i tak pewnie ryzykownie byłoby studiować na uczelni we Wrocławiu czy Warszawie siedząc w Krakowie, bo pewnie od czasu do czasu trzeba się na miejscu pojawić. A może nie? Macie jakieś informacje jak to w praktyce wygląda?;"
"@siabal04:  Wiesz dokladniej co bys chcial robic czy na razie tylko tak ogolnie? W jakiej konkretnie branży to jeszcze nie wiem, możew finansowej, biznesie.  Chciałbym robić coś związanego z  analizą danych, ewentualnie zarządzanie ryzykiem finansowym, prognozowaniem. Tak żeby wykorzystać kilka metod typu regresje, szeregi czasowe i inne procesy stochastyczne, sieci neuronowe, machine learning, deep learning, data mining, ekonometria itp.   Myślę, że z taką opinią ktoś przesadził i nie jest aż tak źle.;"
"Na początek dzieki że nie uznałes mojego pomysłu za idiotyzm. Hmm jak opisac moja wiedze, ciężko dosyc. Wiem tylko ze sieci neuronowe podejmuja decyzje na podstawie obliczeń prawdopodobienstwa, a znajmosc jezyków programowania jest tez dosc nikła, C++ jedynie dosc dobrze znam, umie, jednak nie potrafie jeszcze pisac aplikacji okienkowych. Głownie oczekuję, np tytułów ksiazek o sterowaniu głosem, rozpoznawaniu głosu oraz jakis pdf czy innych a reszte bede sam uzupełniał swoja wiedze.;"
"Każdy z tematów ""rozpoznawanie głosu"", ""rozpoznawanie twarzy"", ""cały silnik sztucznej inteligencji"" jeżeli potraktowany poważnie mógłby być tematem na pracę doktorską. Jeszcze nikt nie stworzył idealnego systemu do rozpoznawania twarzy (chociaż są prowadzone nad tym badania - głównie w USA). Nikt też nie stworzył, ani zapewne nie stworzy w najbliższym czasie systemu, z którym można by pogadać i po dłuższej rozmowie na wybrany przez nas temat nie zorientować się, że rozmawiamy z maszyną. Najprościej chyba zrobić rozpoznawanie głosu (przynajmniej jeżeli chodzi o jakiś stały zestaw komend). Daj sobie spokój - na SI na studiach poznasz jakieś proste algorytmy do gier (mini-max, alpha-beta, może jakiś zrandomizowany, wyszukiwanie ścieżki) oraz systemy decyzyjne (np. sieci neuronowe, programowanie z więzami, klasyfikacja obiektów). I to wszystko. Nie oczekuj cudów.;"
"To jest nowy kierunek więc raczej nikt nie będzie ci w stanie pomóc za bardzo ;) Różnica jest głownie w przedmiotach i blokach obieralnych z tego co widzę w syllabusie - a przypadku ""zwykłej"" infy masz dużo szersze spektrum przedmiotów, przykład: Zasady wyboru: Student wybiera 2 przedmioty Kryptografia Rozwiązania IT w inżynierii produkcji Design Patterns Grafika komputerowa Programowanie systemowe Usability Engineering Wprowadzenie do systemów ERP Wstęp do cyfrowego przetwarzania obrazów Wstęp do programowania grafiki komputerowej  W tym samym czasie na tym drugim kierunku: Zasady wyboru grup/modułów: Studenci muszą wybrać co najmniej dwa przedmioty z puli przedmiotów do wyboru za minimalnie 6 pkt. ECTS. Wprowadzenie do sieci neuronowych Metody podejmowania decyzji Inżynieria kolektywnej inteligencji Przetwarzanie języka naturalnego w systemach sztucznej inteligencji Programowanie genetyczne Zastosowanie transformacji grafowych w AI  I dalej kolejny semestr analogicznie: Zasady wyboru: Student wybiera 2 przedmioty Bezpieczeństwo sieci komputerowych Działalność w kole naukowym Optymalizacja kodu na różne architektury Podstawy uczenia maszynowego Przetwarzanie i analiza obrazów cyfrowych Systemy czasu rzeczywistego Systemy wbudowane Złożone systemy cyfrowe  vs. Zasady wyboru grup/modułów: Studenci muszą wybrać co najmniej dwa przedmioty z puli przedmiotów do wyboru za minimalnie 8 pkt. ECTS.  Głębokie sieci neuronowe i zaawansowane techniki ich uczenia Wykrywanie anomali sieciowych z wykorzystaniem uczenia maszynowego Inteligencja obliczeniowa w analizie danych cyfrowych BigData i uczenie maszynowe Inteligentne Systemy Sterowania Inteligentne systemy sensoryczne  Więc generalnie jak wiesz ze chcesz koniecznie robić tylko i wyłącznie AI/ML, to te Systemy Inteligentne będą jak znalazł. A jak sam jeszcze nie wiesz co chcesz robić i chcesz móc spróbować różnych rzeczy, to Informatyka pewnie będzie trochę lepsza. Weź też pod uwagę że 1 rok studiów jest praktycznie taki sam, więc jest spora szansa że będzie się dało przepisać jakby co.;"
"Sztuczne inteligencja zastępuje programistów Javy. https: // www .dobreprogramy.pl/Sztuczna-inteligencja-juz-dzis-pisze-kod-za-programiste-czy-jutro-go-zastapi,News,87796.html;"
"Do szeroko rozumianej sztucznej inteligencji nie zaliczają się tylko i wyłącznie sztuczne sieci neuronowe (które i tak mają niespecjalnie dużo wspólnego z prawdziwymi), ale także wymienione przeze mnie systemy ekspertowe. Zobacz na https://pl.wikipedia.org/wiki/Sztuczna_inteligencja (tam figurują pod nazwą systemy eksperckie).;"
"W sensie, że uczysz sieć rozpoznawać kwiatki, ale zdjęcia które jej dasz sieć nigdy nie widziała, a programista nie stworzył reguły decyzyjnej opartej na charakterystyce jasności pikseli danych wejściowych. Taką regułę sieć wypracowała sobie sama, w sposób dla człowieka nie do końca jasny. To są właśnie znamiona owej sztucznej inteligencji. Gdybyś jednak napisał program oparty o rozpoznawanie obrazu klasycznymi metodami, typu wykrywanie cech i dopasowywaniu cech do wzorca, a potem jakiś klasyczny klasyfikator, to niekoniecznie będzie to SI. Różnica jest dość płynna. W każdym razie, o takie rozróżnienie mi chodziło, gdy pisałem, że NIE chcę sztucznej inteligencji stosować do prawa.;"
"Witam serdecznie, Poszukuje informacji z zakresu analizy danych (moze byc tez cos o formach reprezentacji danych w kontekscie AI). Interesuje mnie zastosowanie sztucznej inteligencji lub narzedzi statystycznych uzytecznych przy analizie. Dane, ktore zamierzam analizowac to kod HTML. Tworze system samouczacy sie, ktory ma produkowac reguly dla crawlerow/botow do indeksowania okreslonego zestawu informacji na roznych stronach. Z gory dziekuje za wszelka pomoc, linki i tytuly ksiazek. Pozdrawiam;"
"Jak już wyżej wspomniano, studia są z informatyki czyli nauki o przetwarzaniu informacji a ty chyba pomyliłeś to z kursem programowania. Swoją drogą jak dla mnie to strasznie wyrobniczo wyglądają te przedmioty i raczej spodziewałbym się ich na inżynierce. Ale jednocześnie tym samym są właśnie bardzo praktyczne i programiście na pewno się przydadzą. Dla kontrastu, u mnie na mgr mieliśmy przedmioty w stylu:  obliczenia kwantowe uczenie maszynowe algorytmy i budowa systemów bazodanowych data mining inteligencja obliczeniowa przetwarzanie języka naturalnego jakieś wprowadzenie do prowadzenia badań i pisania publikacji...  To są dopiero rzeczy mało przydatne z punktu widzenia szarego programisty ;) Niemniej jednocześnie są to rzeczy bardzo ciekawe i jeśli kogoś interesuje informatyka to raczej nie będzie tego uważać za stracony czas albo dno :);"
"Musisz napisać coś więcej na temat tej gry.  Wszystko zależy od tego, co konkretnie robi się w tej grze, na czym gameplay polega. Dynamicznie dostosowujący się poziom trudności co prawda brzmi bardzo interesująco, ale trzeba pamiętać, że nie jest to standard, nie do każdej gry będzie pasować.  Tak czy siak każdą grę należy ręcznie zbalansować, bo to musi być fundament dla mechaniki zmieniającego się poziomu trudności, aby wiedziała, jakie są granice trudności — dolna, dla niedzielnych graczy (również dla dzieci) oraz górna, dla hardkorowców. Te granice musisz znaleźć samodzielnie, jako punkt startowy do dalszego balansowania.  Zależy co masz na myśli pisząc o pomocy AI. IMO bez beta-testów się nie obejdzie, dlatego że żadne oprogramowanie nie zastąpi człowieka w tej kwestii. Powinieneś skorzystać z pomocy beta-testerów i finalnie zbalansować grę na podstawie ich feedbacku. Natomiast nic nie stoi na przeszkodzie, aby wersja beta przeznaczona do testów gromadziła dane telemetryczne. Takie dane są bardzo cenne, bo nie tylko dostarczą mnóstwo dodatkowych informacji, których człowiek nie wyłapie i nie zgromadzi, ale i będą one zdecydowanie bardziej wiarygodne i bardziej precyzyjne, niż prosty feedback. Pamiętać trzeba, że człowiek to nie maszyna, nie zauważy mnóstwa szczegółów, może i będzie się mylić, ale też może mieć zły humor, być uprzedzonym czy po prostu kłamać dla własnych korzyści. A telemetria nie kłamie, nie myli się i niczego nie pomija.  To zależy czym ta gra jest, jak istotny jest globalny ranking i czego w ogóle dotyczy. Ale nic nie stoi na przeszkodzie, aby użyty w trakcie gameplay'u poziom trudności wykorzystywać do obliczenia końcowego wyniku gracza (jeśli miałby to być wynik punktowy).;"
"Najważniejsze:   Matematyka dyskretna.  Algorytmy i struktury danych. Znajomość ze 2-3 języków programowania. Interesuje Ci machine learning to oczywiście statystyka, rachunek prawdopodobieństwa, sztuczna inteligencja, uczenie maszynowe. Poza tym: Systemy operacyjne. Bazy danych. Sieci komputerowe i systemy Internetowe. Programowanie rozproszone i równoległe. Inżynieria oprogramowania.;"
"No tak, Ale nikt nie twierdzi, że docelowo ma wymieść wszystkich programistów. To tak jak w fabrykach, automatyzacja może i być i w 90% procesu, ale jednak są też zatrudnieni jacyś ludzie. I tak zawsze będzie. Ja rozumiem, że zagrożenie automatyzacją dla programistów też będzie szło tą drogą. Z potrzebnych 10, zostanie dwóch, a 8 klepaczy się zastąpi.;"
"Najwyżej wrócimy (w przypadku niektórych: pójdziemy) na studia. Przecież Pan Profesor wyraźnie powiedział, że każdego programistę można zastąpić skończoną liczbą studentów, więc miejsc pracy można łatwo namnożyć :)  Dokładnie, w takim Sabre to już w ogóle wszyscy są na 100% przekonani, że nigdzie nie ma tak stabilnie, jak w korpo.  Ale wiesz, że podstawowe CRUDy można już teraz generować i bez sztucznej inteligencji? Co ma robić ta sztuczna inteligencja, tworzyć algorytm robienia inner joina? Zresztą to bardzo dobrze, klepanie CRUDa zwiększa zużycie kawy o połowę, bo trzeba jakoś nie zasnąć.  Eldorado się skończy, jak powstanie coś co zastąpi komputery i software w postaci znanej nam dzisiaj i trzeba się będzie przebranżawiać. W sumie to chętnie bym się nauczył korzystać np. z komputerów kwantowych, choć w tej chwili mój mały móżdżek jeszcze nie objął, co konkretnie mogę osiągnąć manipulując stanem kilku qubitów. Widziałem chyba nawet kiedyś jakieś przykłady, ale bez przełożenia na praktykę. Tak samo jak wraz z silnikiem spalinowym czy elektrycznym skończyło się eldorado dorożek i omnibusów, ale przy nowych zajęciach i tak trzeba było rąk do pracy.;"
"Nie możesz pracować na sieciach neuronowych bez znajomości zasad ich funkcjonowania. To znaczy możesz, ale będzie to nieefektywne. Ja zacząłem od książki Tadeusiewicza o sieciach neuronowych. Taka podstawa z sieci neuronowych uczonych z nauczycielem to oczywiście algorytm wstecznej propagacji błędu. Poczytaj o nim. Ważne są też metody przyśpieszające uczenie, jak np. metoda adaptacyjnego współczynnika uczenia. Sieci neuronowe naprawdę są niezwykle ciekawe, ale i trudne. Przygotuj się na sporo matmy.;"
"http://otworzksiazke.pl/ksiazka/odkrywanie_wlasciwosci_sieci_neuronowych/  i jest gdzieś jeszcze ""Sieci neuronowe"", ale nie mogę teraz znaleźć, na YT są też jakieś jego pogadanki też warto zobaczyć. Dobrym pomysłem jest też poczytać ""Neurocybernetyka teoretyczna"";"
"Czytałem jakiś czas temu ""Odkrywanie właściwości sieci neuronowych przy użyciu programów w języku C#"" R.Tadeusiewicza, jednak wiedza tam zawarta była przekazywana w bardzo teoretyczny sposób. Ogólnie jest sporo kursów i raczej te sieci opisywane są ogólnikowo i to było powodem stworzenia tego tematu. Zastanawiałem się, czy to nie jest jak z nauką programowania, ponieważ dużo szybciej przyswajam sobie wiedzę oglądając tutoriale i ćwicząc od razu na kodzie, zamiast przerabiać jakąś wielostronicową książkę. Ale wychodzi na to, że sieci neuronowe to trochę inna sprawa i jednak warto poświęcić czas na naukę teorii, ponieważ implementacja to nie problem, w przeciwieństwie do dobrania odpowiedniego rodzaju sieci, metody uczenia itd.? Akurat właśnie ostatnio sporo czasu spędziłem na poszukiwaniu materiałów i mam ściągnięte między innymi kursy z Coursera. Może znajdzie się osoba, która już przerabiała ten temat, ma doświadczenie i doradzi w jaki sposób powinienem rozwijać się w tym kierunku? Z góry dzięki.;"
"Ja mam trochę inne pytanie bo wiadomo, że sieć neuronową można stworzyć w jakimkolwiek języku programowania, trochę słabo ogarniam te sieci neuronowe, ale przykładowo jak już piszę jakiś algorytm, który liczy coś skomplikowanego związanego ze sztuczną inteligencją to jak poznać czy nie stworzyłem jakiejś prostej sieci neuronowej.;"
"Witam Mieszkam w Anglii i znam paru studentów, którzy chcą założyć własny startup i poszukują developerów. W związku ze specyfiką takich projektów nie jest wymagane doświadczenie, ale będą to projekty bez wynagrodzenia, płatność wyłącznie akcjami. Skądinąd studenckie projekty mają szanse na finansowanie. Wymagana jest znajomość angielskiego i samodyscyplina. Jeżeli ktoś byłby zainteresowany, to proszę się do mnie zgłaszać. Projekt nr 1: Stworzenie CADa do projektowania robotów. Wymagania: grafika komputerowa, algebra liniowa, przekształcenia geometryczne, podstawowa znajomość robotyki, tworzenie interfejsów użytkownika. Projekt nr 2: Stworzenie systemu do rankingowania CV. Wymagania: uczenie maszynowe, przetwarzanie języka naturalnego, praca z bazami danych, prawne aspekty prywatności. Kolega ma dostęp do bazy danych CV dużej firmy, która może posłużyć za dane treningowe.;"
"Poruszając się w potocznym znaczeniu słów ""Programista"" to pojęcie szerokie niemal jak ""informatyk"". Przecież dla rodziny jesteśmy informatykami a nie programistami czyli naprawiamy komputery umiemy zainstalować u cioci na tablecie Skype'a i zrobić Internet. Zawężając się jednak do podzbioru ""informatyków"" czyli samych programistów nadal pozostajemy w ogromnym zbiorze stanowisk, zakresów kompetencji czy zwyczajnie różnych charakterów i osobowości. Pośród tych wszystkich ""normalnych"" i ""dziwaków"" są programiści, których praca jest ważna, bardzo odpowiedzialna są wartościowi dla dużej grupy ludzi a czasem nawet dla całego społeczeństwa. Są też tacy, których istnienie uzasadnione jest jedynie zrealizowaniem nieznaczącego drobnego zlecenia, poza którym właściwie nie musieli by istnieć. Nawet gdyby zniknęli jak czarownik zamieniając się w parę to nikt by tego nie zauważył... Może osoba siedząca obok widząc to powiedziałaby Wow! Co z tego wynika a no nic -  są różni programiści i tyle. Sama inteligencja to nie jest magiczna moc pozwalająca robić rzeczy, których mniej inteligentni nie potrafią. Inteligencja nie jest synonimem mądrości, głupoty, doświadczenia ani posiadania wiedzy. Praktyka pokazuje, że podczas pracy programisty najważniejszą rolę odgrywają właśnie cechy t.j. (subiektywnie w kolejności od najważniejszej): wiedza, doświadczenie, mądrość ... Dodałbym jeszcze mało docenianą wśród umysłów ścisłych komunikatywność. Inteligencja to ostatnia rzecz, która jest nam potrzebna. Ta jednak bywa świetnym spoiwem między wymienionymi cechami jeśli posiadamy je już na wyższym niż przeciętny poziomie. To daje nam większe szanse na sukces, niestety osiągnięcie go nadal wymaga ogromnego nakładu pracy. Inteligencja idzie trochę w parze z intuicją i to jest moim zdaniem istota rzeczy. To taki łącznik między sposobem i skutkiem podejmowanych decyzji odrobinę rozróżniający osoby inteligentne od tych mniej inteligentnych. Ci pierwsi rzadziej się mylą a ich decyzje podejmowane na szybko lub w stresie[1] także w mniejszej ilości przypadków kończą się porażką. To przekłada się na lepszą skuteczność w działaniu i oszczędność czasu a to już bardzo dużo jeśli poprzeczkę stawiamy wysoko. Jeśli jednak nie planujemy kariery ""od zera do milionera"" to inteligencja może nam pomóc np. w tym, żeby w pracy mniej się męczyć albo wyrwać ładniejszego partnera/partnerkę (zawsze coś)... Generalnie cudów, laserów, matrixa i statków kosmicznych nie ma w żadnym przypadku:-) Nawet mało inteligentna osoba może programować. Będzie jej trudniej - prawdopodobnie będzie lubić zadania bardziej żmudne niż wymagające umiejętności dalekosiężnego projektowania i przewidywania zachowania systemu. Nadrobi to jednak skrupulatnością, czytelnością kodu być może będzie dobrze testować a to przyczyni się to tego, że program wychodzący spod jej ręki będzie dla użytkownika równie dobry jak ten napisany przez geniusza. Oczywiście jak ktoś jest leniwy, wyjątkowo tępy lub nie chce się uczyć to szans nie ma to jednak zasada w każdym zawodzie nie tylko programisty. @Spearhead napisał, że Ludzie z wysokim IQ zostają naukowcami lub milionerami, a nie programistami. ... Mogą ale nie muszą. Tak samo jak tępy, który też może zostać milionerem wykorzystując takie cechy jak komunikatywność, spostrzegawczość, pracowitość i upór w dążeniu do celu. Odnoszę zresztą wrażenie, że tak właśnie jest w większości przypadków. Bo do bogactwa prowadzi konsekwentność i pracowitość a nie inteligencja. Tych błyskotliwych inteligentnych co zrobili karierę znamy z amerykańskich filmów ale w rzeczywistości to są jednostki. Inteligencja może pomóc zostać najlepszym, może pomóc w zdobyciu wysokich zarobków niższym nakładem pracy niż u mniej inteligentnych ale nigdy nie zastąpi pozostałych niezbędnych do pracy w zawodzie cech i umiejętności. [1] - nie chcę tu wnikać w analizę odporności na stres więc załóżmy, że chodzi o osoby o podobnej odporności.;"
"Zauważyłem, że na 4p o wszystkim co nie jest klepaniem crudów w javie mówi się bańka i hype, a w tym czasie na zachodzie robią z tego dosłownie miliardy.... Pamiętam parę lat temu, data science i uczenie maszynowe to też był hype dla elity 4p.;"
"Natomiast ciekawe byłoby zastosowanie AI do gier... W zależności od umiejętności gracza, wzrastałby poziom gry, ale to raczej chyba dość trudne zagadnienie, bo nie myślę tu o kółku i krzyżyk :);"
"Ponieważ mam styczność z AI w szachach i coś tam sobie kodzę, to opiszę, z mojego punktu widzenia, jak to ""AI"" wygląda z punktu widzenia szachów, czyli poletka, w którym maszyny pokazały nam gdzie nasze miejsce. Teraz na topie są 2 rodzaje silników szachowych:  ""klasyczne"", stosujące algorytmy alpha-beta pruning/minmax, w tej grupie znajduje się uznawany za najsilniejszy obecnie silnik szachowy - stockfish (C++) ""nowoczesne"", czyli NN+MCTS, najsłynniejszy oczywiście to ten ""scam"" od Google/DeepMind - AlphaZero, a obecnie Leela Chess Zero, Komodo też coś ma (bo rodowodowo to klasyczny silnik)  Generalnie dzisiejsze silniki szachowe są niesamowicie silne, najsilniejsi szachiści nawet nie próbują grać z nimi bez handicapów, jednakże istnieją pozycje, w których taki silnik jest ""głupi"" - w sensie rzecz oczywista dla człowieka jest nie do rozwiązania dla programu, najczęściej się to przytrafia właśnie silnikom opartym o alfa-beta pruning. Oczywiście, sztuką jest doprowadzenie do takiej ""problematycznej"" pozycji w normalnej grze, niemniej jednak są osobniki, które nie mają wielkich osiągnięć szachowych w grze z ludźmi, a potrafią sobie często poremisować z takimi supersilnymi programami, właśnie z powodu takich alogrytmicznych niuansów. LC0 też mimo swojego rankingu obecnego, potrafi czasem zagrać z kosmosu coś i niezrozumiale dla nikogo, w sensie, że doprowadza do porażki, a nie zagrałby tak klasyczny silnik ani zdrowo myślący gracz. Można to oczywiście zrzucić na barki wciąż trwającego procesu uczenia. Poza oczywistym scamem od Google, który jest nijak nieweryfikowalny w tej materii poza hypem marketingowym, głównie pod inny cel niż szachy, niby ""AI"" jest LC0, którą ""buduje"" społeczność, ale to wciąż ML, tylko pięknie nazwany. W sumie widzę tu ciekawe zastosowanie dla blockchaina z tą siecią LC0... Generalnie, jakieś algorytmy NN w ""nowoczesnych"" silnikach są odpowiednikami ifów w klasycznych silnikach i mają wady/zalety klasycznych silników, a wymagają do działania sprzętów typu TPU, w najlepszym przypadku silnych kart graficznych. Na razie absolutnie nie widać, aby ML w szachach jakoś się szczególnie czymś wyróżniał - obecnie LC0 nawet nie dotarło do ""1szej"" ligii i zabraknie jej w starciu najsilniejszych silników w TCEC. Może w następnym sezonie, bo postępy są, trzeba to przyznać, ale nie wierzę, że pewnego dnia ML wyprze alpha-beta, tylko dlatego, że to jakieś AI. Póki co ML się świetnie sprawdza w układaniu playlist na YouTube i Spotify albo w rozpoznawaniu czegoś lepiej od ludzi (no dziwne żeby nie, skoro człowiek nie będzie pamiętał ileś milionów przypadków różnych danych i potem to korelował). Także nie ekscytowałbym się jakimś ML, bo AI to chyba nawet za 500 lat nie stworzymy. Oczywiście pewnie to bardziej ciekawe, niż pisanie kolejnego CRUDA, ale nie robiłby z tego sprawy, dla której warto oddać nerkę przy rekrutacji. Potem ktoś będzie bez nerki i okaże się, że maks to będzie debugował, dlaczego fanowi pornoanime, czy innego takiego zakręcenia, dostało się rekomendacjami telenowel z argentyny w jego playliście/profilu/feedzie/whatever. Nie sądze, by rozwiązywanie takich ""problemów"" świadczyło o tym, że na zachodzie jest dobrze w IT bo robią ML, a u nas tylko CRUDY.;"
"długo AI nie zastąpi programisty, poza tym człowiek jest tańszy w utrzymaniu :-) Coraz trudniej projektuje się procesory z uwagi na ograniczenia materiałów z jakich są robione, a takie AI przecież nie będzie chodzić na celeronie :-P w sumie to długa droga do stworzenia AI, na razie to tylko algorytmy ale i tak człowiek je wymyśla i implementuje :-);"
"No właśnie Shalom, jak to sieci neuronowe nie są zbyt popularne? Przecież to fundament dzisiejszej technologii. Nawet można już ten dobrze brzmiący slogan wrzucać do reklam smartfonów bo aparaty faktycznie opierają się w jakimś stopniu o decyzję podjętą przez AI co do retuszu czy nasycenia zdjęcia w nocy. cleverbot.com to zwykła amatorka jaką można było zrobić w BASIC na Atari :) Bo chyba nikt nie zrobił nic lepszego dostępnego w necie?;"
"Mój wykładowca zwykł mawiać że ""sieci neuronowe to drugie najlepsze rozwiązanie danego problemu"". Co można wytłumaczyć następująco:  sieć nie jest świadoma problemu który rozwiązuje bo jest narzędziem generycznym. sieć jedyne co potrafi to aproxymacja (przybliżanie) nieznanej funkcji wy = f(we) jeżeli poświęcimy wystarczająco dużo uwagi dla danego zagadnienia X to najprawdopodobniej znajdziemy sposób jego rozwiązania znacznie lepszy niż to co jakakolwiek sieć może osiągnąć  PS. AI w reklamach to często regresja liniowa z bardzo dużą liczbą zmiennych. Wiele wymiarów robi różnicę :P;"
"Żeby taka sztuczna inteligencja naprawdę umiała się porozumiewać, trzeba jej dać dostęp do większej ilości zmysłów. Sieci neuronowe są elastyczne, jedną umiejętność mogą wykorzystać do innej. Jak sieć nauczy się rozpoznawać wzrokowo daną sytuacje i odpowiednią dla niej znaczenie logiczne, leksykalne. To taka sieć będzie mogła robić co chce i uczyć się jak człowiek. Teoretycznie wzrok i słuch wystarczy, ale jest też potrzebny dotyk, bo fizycznej pracy jest dużo. Te 3 zmysły wystarczą żeby sztuczna inteligencja, stała się prawdziwą.;"
"Nie wiem jak jest na PolSl ale mam trochę znajomych po UŚu i raczej nikomu bym nie polecał.  Z racji względnie niewielkiej odległości, nie myślałeś o AGH? Praktycznie wszystkie przedmioty są wybierane przez ciebie, spokojnie można ogarnąć jednym porządnym projektem 2-3 przedmioty na raz, w pewnych dziedzinach są tam całkiem ogarnięci prowadzący u których możesz pisać pracę (np. przetwarzanie języka naturalnego, analiza sieci społecznych, data mining, inteligencja obliczeniowa).;"
"Witam, zastanawiałem się ostatnio, jak zrobić sztuczną inteligencję do gry ""Koło Fortuny"" - dla gracza komputerowego ;) Czy będą to sieci neuronowe? Jakoś do końca mi to nie pasuje. O ile chodzi o zgadywanie literek w haśle to jeszcze jakoś można to zrobić, ale co z odgadywaniem całych haseł i strategią gry(kręcę kołem - nawet jeśli znam już hasło; kupuję samogłoskę; zgaduję hasło). Czy może będzie to jakiś system ekspertowy? W moim odczuciu wydawałoby się to najbardziej logiczne. Ale jak się zabrać za taki system? Oczywiście Prolog odpada, pytanie dotyczy czystego Delphi :P Kiedyś napisałem ""Kółko i Krzyżyk"" z na tyle ""mądrym"" komputerem, że sam mam problemy z wygraniem :D To bazuje właśnie na takim pseudo systemie ekspertowym. Tzn. komputer najpierw sprawdza, czy musi się bronić, a jeśli nie, to próbuje atakować.;"
"uczenie maszynowe, statystyka, probabilistyka, c++;"
"Ja rozumiem jak z grubsza działa mózg, ale to że pod spodem mamy tylko chemiczne reakcje nie zmienia faktu, że to nie jest deterministyczna maszyna, która potrafiłaby precyzyjnie wyjaśnić wszystkie nasze zachowania. A ta symulacja świadomości to na razie wyłącznie hipoteza. Poza tym, załóżmy, że uda się stworzyć komputerowo sztuczną świadomość, to jej decyzje pozostaną wciąż jej decyzjami, a nie decyzjami jej programisty, tak jak już teraz decyzje dokonywane przez sztuczne sieci neuronowe nie są decyzjami programistów tych sieci. Można powiedzieć więc, że już teraz sieć ma ""wolną wolę"" w podejmowaniu decyzji.  To dlaczego mamy wciąż przestępców?;"
"Na pewno **nie **za kilka lat xD ale w odległej przyszłości - 5-30 lat może to być możliwe, niestety.  Taka duża rozpiętość, bo nie jest wiadome na jakim obecnie etapie jest Google/Microsoft. Coraz więcej wychodzi prognoz na ten temat, nie tylko na głupkowatych polskich portalach, ale również na nieco poważniejszych anglojęzycznych portalach, jakby coś wisiało w powietrzu... w każdym razie temat jest gorący. Jak na razie, tworzone są narzędzia, które znacznie ułatwiają/automatyzują pracę programisty, takie jak np. Developer Assistant (dla C#), które korzystają z rozmaitych algorytmów wyszukiwania rozwiązań z Git'a. Nawet po stworzeniu jakiegoś wielkiego narzędzia przez znane korpo to zawód programisty nie ""wyginie"", ale może znacznie zmniejszyć się zapotrzebowanie, jak i zarobki - tak, że będzie to nieopłacalne... tylko co wtedy stanie się ze wszystkimi programistami ? pewnie niektórzy załapią się na jakieś koło-informatyczne stanowiska pracy, a niektórzy wrócą na jakieś studia magisterskie. Natomiast studenci informatyki poczują się oszukani... ale równie dobrze może być tak, że nawet w przeciągu 50 lat praca programisty nie zostanie zautomatyzowana do takiego stopnia. Byłoby śmieszne gdyby programiści zostali szybciej wyparci przez maszynę niż kasjerzy... bo jak na ironie, wiele ludzi woli jak ktoś za nich kasuje ich zakupy - darmowa obsługa. Natomiast dla firm byłaby to ogromna oszczędność, gdyby programistów dałoby się zastąpić jakimś inteligentnym narzędziem, tak że z kilkudziesięciu/kilkuset koderów zostało by w danej firmie 2-5 programistów.;"
"Ale tutaj w artykule pisze jasno, że Google pracuje nad sztuczną inteligencją, która zastąpi klepaczy kodu, a nie programistów xD;"
"Oczywiście to wszytko co piszę jest hipotetyczne... moim zdaniem jeszcze przez wiele lat programiści będą tzw ""elitą"" jeśli chodzi o zarobki ;) a może nawet nie dożyjemy czasów automatyzacji naszej pracy :D Ale rozważmy też pesymistyczną wersje, czyli jeśli jednak pojawi się na rynku jakieś SUPER narzędzie, takie które wyprze 90% programistów z rynku to będzie krucho. Czym Twoim zdaniem różni się klepacz od programisty ? każdy korzysta z stackflow i robi copy-paste. Większość programistów się rozwija - uczy nowych technologii, ale posiada naprawdę małą znajomość algorytmiki (tylko materiał ze studiów albo jeszcze mniej). Front-end jest teraz ""trendy"", więc nie wiem czy zaliczają się do zwykłych klepaczy xD jednak ja cały czas piszę o backend, bo głównie pod ten segment IT tworzone są różne narzędzia automatyzacji, jak  np. wcześniej wspominany Developer Assistant.;"
"obejrzałem zajawkę   i wydaje mi się, że to narzędzie (podobnie jak np. Kite) to rozwiązywanie złego problemu, nawet jeśli w dobry sposób (tj. te narzędzia rozwiązują problem typu nie chce mi się samemu wyszukać w Google ogólnodostępnych informacji na temat przykładów użycia frameworków a powinny moim zdaniem skupiać się na rozwiązaniu problemów typu nie wiem jak połączyć ze sobą dwa moduły z firmowego frameworka, do którego jest zero dokumentacji, jego kod to syf, a kolega, który go pisał, juz tu nie pracuje. Bo w pierwszym przypadku (nie chce mi się wyszukać czegoś w internecie) to wydaje się, że jest to minimalna oszczędność czasu (bo ile zajmuje wyszukanie czegoś w internecie? Raczej nie wiele...), natomiast rozwiązanie problemu drugiego (jak sprawnie poruszać się w legacy kodzie) mogłoby być naprawdę killer ficzerem, jeśli ktoś coś takiego by zrobił. Wydaje mi się, że to narzędzie Microsoftu prędzej jest konkurencją dla wyszukiwarki Google'a (jeśli chodzi o szukanie dokumentacji, przykładów użycia frameworków itp.), a nie czymś, co zastąpi programistów (prędzej ich ogłupi, bo metoda pracy kopiuj-wklej będzie jeszcze łatwiejsza niż była dotychczas, skoro z poziomu IDE będzie można znaleźć kod do wklejenia).;"
"Że AI dobrych programistów nie wyprze to się zgodzę, ale powszechne wykorzystywanie AI do pisania programów nastąpi raczej duuuuużo wcześniej niż za 300-400 lat;"
"Jestem w stanie sobie wyobrazić, że powstanie jakieś rozwiązanie Enterprise, które zastąpi pisarzy crudów i formatek (zarówno front, jak i backendowych). Tyle tylko, że powstanie inna nisza, do której będzie się spokojnie można przesiąść. Co do AI to raczej bym się nie martwił, w tej chwili to po prostu kolejne fajne hasełko w stylu ""robimy Big Data/jesteśmy Agile/korzystamy z AI"" które trafiło do mediów. Pamiętam, jak w jednej dużej firmie wprowadzono chat-bota, który miał rozwiązywać ponad połowę zgłoszeń z pierwszej linii. Bardzo fajna prezentacja pokazywała, jak świetnie bot sobie radzi z odczytem nastroju ludzkiego (cztery możliwe parametry), jak świetnie się uczy i jak dobrze dobiera odpowiedzi. Wynik tej operacji jest raczej łatwy do przewidzenia, tzn. skończyło się totalną porażką, bot nic nie umie poza przekierowywaniem ludzi zgłaszających do ludzkiej pierwszej linii. Szef projektu twierdzi, że bot się jeszcze musi uczyć, całe korpo już zdążyło zapomnieć o sprawie.;"
"Na AGH nie uczą rzeczy z 2001, a aktualnych. Pewnie znajomi odpadli po pół roku i sobie ten fakt musieli wytłumaczyć, albo faktycznie natrafili na jakieś przedpotopowe podejście. Natomiast to studia inżynierskie i masz wiele przedmiotów inżynierskich. Przez cały ich zakres nie nauczysz się profesjonalnie programować (to musisz rozwijać na boku), a zostanie Ci przedstawione wszystkiego po trochu, od sieci komputerowych, do języków programowania, przez sieci neuronowe po szyfrowanie w matematyce dyskretnej. Zadbaj o dobry wydział EiT albo samogłoski, w innym wypadku pozostanie Ci nauka wielu najpewniej nieprzydatnych przedmiotów jak w moim wypadku. Co do Informatyki na UJ, słyszałem dobre opinie, ale moim zdaniem najlepiej mieć papier z AGH - to przepustka na start niemal wszędzie. Co do prywatnych uczelni, nie mają one opinii porównywalnej z publicznymi i nigdy mieć nie będą. Często to nieformalny układ o przejściu bezpiecznie studiów po zapłaconych pieniądzach i to wszystko. Pominę już możliwość przetłumaczenia strony na ukraiński (oczywiście nic do naszych rówieśników po drugiej stronie granicy nie mam), co tylko świadczy o tym, w jaką grupę docelową celują właściciele uczelni (bogaci synowie Ukraińców, którzy mają pieniądze, żeby ich dziecko wychowało się w Krakowie).;"
"Cześć, jestem w sumie zielony w tym temacie i zastanawiam się czy właściwie w dziedzinach typu Data science ( a w tym uczenie maszynowe, bo to się chyba łączy ) łatwo czy ciężko znaleźc pracę, i jaki jest próg wejścia. Znam teraz podstawy java + spring, i nieźle front-end z angularem, ale nigdy w sumie nie zagłębiałem się w temat uczenia maszynowego chociaż zawsze wydawało mi się to ciekawe i dlatego pytam, bo chciałbym się dowiedzieć jaki jest potencjalnie próg wejścia do takiej dziedziny, i jak potem wygląda rynek. Z góry dzięki;"
"Masz na myśli sztuczne sieci neuronowe ? bo z tym tematem to mi się kojarzy. Co jakiś czas widzę że samsung szuka do działu związanego z sztuczną inteligencją, ale ogólnie ogłoszeń jest bardzo niewiele w porównaniu do ogłoszeń związanych z programowaniem zwykłych aplikacji, więc pewnie i z pracą ciężko.;"
"Żeby zajmować się uczeniem maszynowym, trzeba być w tym oblatanym choć trochę. Co komu po tym, że znasz Springa i angulara (chyba, że będziesz pracował w warstwie prezentacji tychże danych)? Tutaj w grę wchodzi bardziej matematyka (często metody numeryczne), statystyka i sama wiedza o tym jak to działa na poziomie zarządzania danymi (Data Warehousing and Data Mining). Pojęcia takie jak chociażby clustering i cała otoczka z nim powiązana. Sieci neuronowe, drzewa decyzyjne to narzędzia stosowane, ale muszą być stosowane umiejętnie. Próg wejścia do czegoś takiego jest ""ciut"" wyższy niż dla zwykłego Juniora.;"
"Uczenie maszynowe to przede wszystkim matematyka. Niezależnie od tego pod jakim kątem na to spojrzeć (sztucznej inteligencji, czy stricte inteligencji obliczeniowej) jest w tym jej więcej lub mniej. Jeżeli chcesz pracować przy big data, to skup się na statystyce i metodach probabilistycznych. Uczenie maszynowe to nic innego jak dopasowywanie czegoś do klas określonych na podstawie danych z przeszłości. Najczęściej są to po prostu statystyki, lub prawdopodobieństwo wyciągnięte właśnie z dużych zbiorów treningowych. Zdarzają się również sieci neuronowe zapuszczone na obraz, a dopiero później następują te wszystkie wyliczenia statystyczne na podstawie innych wyników. Zdarzają się również skomplikowane szeregi równań różniczkowych wykonywane na superkomputerach. W związku z tym niestety, ale bez wiedzy matematycznej ani rusz, a umiejętność tworzenia aplikacji na popularnych frameworkach nic nie da. Powodzenia!;"
"95% pracy w IT nie wymaga znajomości zaawansowanej matematyki. Pozostaje jednak to 5%. Są to zwykle tematy gdzie znajomość zaawansowanej matematyki bardzo pomaga lub jest wręcz niezbędna, ale przeciętny pracownik IT się tym nie zajmuje:  grafika 3d - trzeba znać algebrę macierzy, bez tego ani rusz (poziom trudności średni) kryptografia kompresja danych analiza obrazów analiza sygnałów sztuczna inteligencja, uczenie maszynowe i wiele innych dziwnych tematów  Czyli jak chcesz w przyszłości robić coś ciekawego idź na studia, gdzie pokażą ci jak wygląda naprawdę ciekawa i niesamowita matma. Wcale nie musisz być następcą Einsteina by sobie z tym poradzić.;"
"@Berylo: Powiem tak, nie wyobrażam sobie być programistą wiele lat, tak sie po prostu nie da, ponieważ wiem, że młodsze pokoleni zrobi to lepiej i Ci programiści co sa obecnie stną się mniej wydajni lub zastąpi nas sztuczna inteligencja. Kiedyś myslałem, że trzeba dążyć do pieniedzy jednak jak widzę jak ludzie i znajomi się zabijaja dla pieniedzy, tracą zdrowie, czas spedzony z rodziną itd to coraz bardziej jestem przekonany, że trzeba to równomiernie rozgraniczyć, mniej stresu, może mniejsze zarobki ale wydaje mi sie ze szcześliwsze życie z rodziną (którą zamierzam założyć). Jeżeli chodzi o to 100zł/MD to tyle to jestem w stanie wynegocjować w obecnej firmie, co do auta to posiaadm już fajne auto za około 90-100k i mam gdzie mieszkać w domu, w tym lub pryszłym roku planuje kupic mieszkanie zeby ulokowac pieniadze. Mam też innte małe biznesiki z których czerpie troche kasy ale to nie jest nic związane z IT tylko z tym co uwielbiam robić poza pracą. W tym tyg musze podjąc decyzje czy przejśc do nowej firmy i sie katować dojazdami, spotkaniami, statystykami, i mając nad głowa inne osoby w zamian za kase która będzie rosła czy zostać, wynegocjować trochę wyższą stawke a miec spokojną, dobrze płatną prace i żyć szczęślwie....;"
"Mam takie pytanie gdzie znajdę gdzieś w sieci dokładny opis jak stworzyć prostą sieć neuronową bo kupiłem sobie książkę ""python uczenie maszynowe"" i nic z tej książki nie rozumiem, myślałem, że jak kupię książkę, która będzie opisywała sztuczną inteligencje i kody programów to łatwiej mi bendzie, a jednak tak nie jest, czyli szukam coś o sieciach neuronowych dla użytkownika słabego z matmy.;"
"Jeśli chcesz naprawdę zrozumieć jak działają sieci neuronowe to nauka matematyki Cię nie ominie. Bez tego nie zrozumiesz takich pojęć jak np. BIAS. Tak naprawdę rozumiejąc matematykę sieci neuronowych dojdziesz do wniosku, że to tak naprawdę żadna inteligencja. Serio, serio. Podczas ""uczenia się"" neuronu bardzo dużo zależy od zastosowania odpowiednich funkcji matematycznych. Inteligencja i prawdziwa nauka polega na tworzeniu się nowych połączeń pomiędzy neuronami w mózgu, a tego sztuczna inteligencja nie potrafi robić. Co do artykułów to nawet tutaj, na forum coś jest: Sztuczne sieci neuronowe i algorytmy genetyczne No i jest jeszcze to, z kodem: http://www.if.uz.zgora.pl/~mdudek/siecineuronowe.pdf Książki są w komentarzach do tego artykułu. W ogóle poszukaj sobie informacji o tym jak zbudować pojedynczy neuron i sterować jego nauką, przykładając odpowiednie funkcje matematyczne. Kod w tym drugim linku wydaje się odrobinę przekombinowany.;"
Jeszcze jedno. Jeśli chodzi o sieci neuronowe to koniecznie zajrzyj na stronę Jasona Brownle: https://machinelearningmastery.com/start-here/;
"Pod jaka dziedzine (sztuczna inteligencja, uczenie maszynowe) podchodzi budowanie inteligentnych programow np. Program do ktorego user wprowadza tresc zadania powiedzmy matematycznego a program je rozwiazuje.;"
"Z pół roku temu zacząłem naukę programowania i obrałem pewien kierunek w którym docelowo chciałbym pracować, a przynajmniej spróbował swoich sił w przyszłości: Inżynieria wsteczna Inteligencja obliczeniowa Programowanie genetyczne Programowanie ewolucyjne Sieci neuronowe (sztuczna inteligencja) Kryptografia, steganografia, bezpieczeństwo Czy poza matematyką warto uczyć się powiedzmy fizyki bądź czegoś innego, bardzo proszę o pomoc i wskazanie tego, co może być dla mnie pomocne.;"
"Będzie jeszcze ciekawiej jak Biden nie przeżyje całej kadencji i zastąpi go Harris :D Zostaje popcorn i kanapa. Jedyny minus, że dolar będzie spadał, no ale jakoś przeboleję.;"
Pozostało nam tylko czekanie aż AI całkowicie nas zastąpi ;__; O żegnaj piękny zawodzie programisty!;
"Za 30 lat umiejętności programowania na poziomie podstawowym staną się powszechne. Zresztą będzie to głownie integracja istniejących rozwiązań. Należy sie zatem spodziewać dalszego rozwarstwienia dochodów. Zarobki początkujących spadną prawdopodobnie do poziomu sprzątaczki. Jednocześnie wąska grupa informatyków zajmujących się bardzo zaawansowanymi projektami będzie miała ogromny wpływ na życie milionów, ich dochody wzrosną do poziomu prezesów banków a z czasem uzyskają dużą władzę. Prawdopodobnie ta grupa doprowadzi do tego że dostęp do zawodu zostanie znacznie ograniczony. Będzie to można łatwo uzasadnić zapewnieniem bezpieczenstwa publicznego po tym jak bląd w oprogramowaniu autonomicznych samochodów doprowadzi do serii katastrof. Bootcampy oczywiście znikną bo zastąpi je nauka w szkole. Poza tym ludzi nie będzie już zbyt pociągać kariera programisty. Aby awansować konieczne będzie ukończenie trudnych studiów, zdanie branżowych oraz państwowych egzaminów i pewnie znajomości - podobnie jak jest teraz z zawodami typu lekarz czy adwokat. Dla zdecydowanej  większości będzie to zbyt trudne. Zreszta sztuczna inteligencja zastąpi mnóstwo zawodów. Paradoksalnie zacznie sie właśnie od tych, które wymagają dużej encyklopedycznej wiedzy. Sztuczna inteligencja porówna w sekundę objawy u pacjenta z milionami innnych kart chorobowych i postawi diagnozę trafną na na 95 % gdy lekarze pewnie mają 50 % trafności. Z drugiej strony zawody gdzie wymagana jest sprawność manualna jak kucharz czy sprzątaczka tak szybko nie znikną. Bardzo cenioną grupą bedą specjaliści od cybersecurity bo terroryzm czy nawet wojna będzie polegała na atakach na systemy informatyczne. Poza tym widze jeszcze miejsce dla naukowców i artystów - ich profesji nie da sie tak łatwo zautomatyzować.;"
"hmmm... 30 lat... to prawie jak era w IT... pytanie co będzie za 5 lat... ja myślę, że AI nie zastąpi człowieka, to pewne... ale może go wspomóc w podejmowanu decyzji... a programowanie będzie bardziej modelowaniem procesów i objektów programistycznych niż pisaniem tysięcy linijek kodu... ale pożyjemy, zobaczymy... :);"
"Nie wiem skąd pomysł, że programowanie będzie w powszechne w podstawówkach? Chyba nie każdy do tego się nadaje. Poza tym szybciej się rozwijają usługi niż IT. Będzie potrzeba więcej kelnerek. Wg mnie dalsza ewolucja człowieka to dalsza informatyzacja. Ciągły rozwój sieci IT. Będą powstawać narzędzia które ułatwią ich tworzenie, frameworki, biblioteki, języki, whatever, by kodowanie było bardziej intuicyjne. Tylko po to, żeby oszczędzić zasoby, czas, których ciągle będzie brakować. Też można się spodziewać, że tani daleki wschód przejmie sporą częśc rynku, też w ramach oszczędności. Powstaną narzędzia które poprawią jakość ich pracy oraz dostęp do tanich zasobów ludzkich. P.S. AI nie zastąpi człowieka. Sami widzicie, że coraz większy nacisk się kładzie na frontend w webie. A czemu? Bo estetyka ma znaczenie, konkurencja tego wymaga. A tego się nie zautomatyzuje. AI jedynie pomoże zautomatyzować niektóre powtarzalne czynności i tyle, ewentualnie uprościć. Ludzkość przeszła od zer-jedynek do miejsca w którym jesteśmy.;"
"Chyba że manuale kompletnie znikną z użycia i zastąpi je StackOverflow. Już teraz jest tak że projekt typu Zeal jest jakimś ewenementem za który wstyd brać kasę (OSS), a jakość dokumentacji wiodących projektów systematycznie spada (Vue.js chwalony jest za to że ma...dokumentację!). Edit: jednak zrobili możliwość wsparcia tego projektu (Zeal): https://www.bountysource.com/teams/zealdocs;"
"To się raczej rozczarujesz bo na mgr raczej możesz się spodziewać przedmiotów w stylu: przetwarzanie języka, sztuczna inteligencja, uczenie maszynowe czy data mining. Każdy z tych przedmiotów wymaga oczywiscie programowania ale jako ""narzędzia"" a nie ""celu"". Na przedmioty ""uczymy się języka X"" to nie masz raczej co liczyć.;"
"EiT to inna bajka jeśli chodzi o ilość matmy i jej pochodnych na studiach. Na infie jest cała masa przedmiotów których bez matmy się nie ruszy. Kryptografia, teoria wspolbieznosci, teoria obliczeń i złożoności obliczeniowej, automaty i języki formalne, kompilatory, metody numeryczne, uczenie maszynowe, sztuczna inteligencja, przetwarzanie języka naturalnego... Niemniej do większości z nich bardziej przydaje się algebra i matematyka dyskretna niż analiza.;"
"Mam takie pytanie w programowaniu jakoś sobie radzę, ale mam takie pytanie czy warto się zabierać za sieci neuronowe jak ma się duże zaległości z matemnatyki na poziomie liceum, bo ja generalnie mam takie myślenie algorytmiczne, ale nie wiem czy się ono przyda w sieciach neuronowych ? I czy w sieciach neuronowych trzeba mieć wysokie IQ ?;"
"Witam, zdaję sobie sprawę, że proszę o wiele, ale mimo wszystko liczę, że ktoś pomoże i doradzi. Mianowicie bardzo zainteresowały mnie sieci neuronowe i chciałbym zająć się nimi w przyszłości. Jednak nie jestem jeszcze na tyle zorientowany w temacie, żeby samemu zdecydować, które zajęcia wiążą się z interesująca mnie tematyką. Jako, że na studiach mam możliwość wyboru przedmiotów, byłbym niezmiernie wdzięczny osobom znającym się na rzeczy za pomoc w ich doborze. Oto lista - https://ramy15.wmi.amu.edu.pl/Sylabusy.aspx (po kliknięciu w dany przedmiot zostanie wyświetlona jego specyfikacja). Jest to dla mnie bardzo ważna kwestia, więc gdyby była możliwość, to proszę o wypisanie nazw przedmiotów, które przydadzą mi się przy sieciach neuronowych w przyszłości i mogę je spokojnie zamieszczać w swoim planie. Z góry dziękuję za pomoc osobom zorientowanym w temacie.;"
Ale czemu konkretnie sieci neuronowe? To jest raczej słaba działka i są lepsze metody uczenia maszynowego... A do samego uczenia maszynowego może być przydatne:  logika algebra statystyka matematyka dyskretna a z tych tam bardziej specjalistycznych przedmiotów które masz w rozpisce to m.in. statystyczne systemy uczące algorytmy przetwarzanie języka naturalnego teoria gier sztuczna inteligencja;
"Właściwie to interesuje mnie cała sztuczna inteligencja, ale zdecydowanie najbardziej zaciekawiły mnie sieci neuronowe.;"
"Nie no tak całkiem poważnie to nie wkopuj się w RDF(S) ani OWL bo to jest mogiła ;) Od 10 lat to jest ""technologia przyszłości"" i nikt poważny chyba nie ma złudzeń że to sie absolutnie do przyjmie. To jest strata czasu. Sugerowałbym raczej coś bardziej życiowego jak przetwarzanie języka naturalnego albo uczenie maszynowe/sztuczna inteligencja. Przynajmniej nauczysz sie czegoś praktycznego czym można potem zarobić na chleb :P;"
"Bardzo trudno powiedzieć co to będzie, bo pewnie generalnie dużo się zmieni w ciągu następnych 5 lat i dopiero okaże się w którą stronę to pójdzie. Myślę, że skrajną głupotą byłoby stawiać wszystko na jeden rozwój wypadków. Jeśli nie będzie większych perturbacji i wszystko pójdzie w stronę, na którą nakierowała świat pandemia to pewnie będzie sporo pracy w branży, cyfryzacja będzie postępować. Więcej infrastruktury do zarządzania przeniesienie dużej części procedur wszelkiej maści do sieci, dużo wyzwań w zakresie bezpieczeństwa. Przemysł cyberwojenny — już na dobrą sprawę, wojny przeniosły się w sferę informacyjną, strzelanie i niszczenie stało się wręcz dodatkiem, a nie daniem głównym. Co do AI, jestem raczej sceptyczny. W niektórych zastosowaniach się przyjmie, autonomiczne samochody pewnie będą jeździć, tak jak jest używane w analizie danych, pewnie będzie używane, ale przypuszczam, że koniec końców nie będzie tu rewolucji na skalę jaką wielu sobie wyobraża. Podstawowy problem polega na tym, że jak na razie trzeba sztuczną inteligencję przyuczać do określonych zadań co jest bardzo dużym ograniczeniem. To może wykosić plankton, ale poważnych specjalistów raczej prędko nie zastąpi. Moja obserwacja jest taka, że AI dobrze sobie radzi tam gdzie szlaki są ostro przetarte, jak nie są, produktywność sztucznej inteligencji jest żałosna, często to widzę na google translate, albo jak google nie potrafi wyłapać oczywistej dla człowieka literówki w mało popularnym wyrazie. To wszystko oczywiście przy założeniu, że gospodarka się nie posypie zupełnie, obawy ekologów okażą się bezpodstawne, a USA odda hegemonię bez większej draki. Jak gospodarka się rypnie to już moze już nie być dla kogo pisać programów. Przyszło nam żyć w ciekawych czasach i na moje, równie prawdopodobne zdają się zarówno katastroficzne jak i  świetliste scenariusze. Z drugiej strony, jeśli jesteś dobrym programistą, pewnie jesteś dość inteligentny, masz dość pokory i ogarniętą cyfrozę, w każdej sytuacji ułożysz sobie jakoś życie dopóki będziesz żyć. ;);"
"Nadziany Mleczarz Próba losowa 80 ""data scientistów""  jest śmieszna biorąc pod uwagę, że zawód ten wykonuje obecnie pewno parenaście tysięcy osób. Druga sprawa to jaką definicję przyjęto definiując ""data scientista"" w tym badaniu, http://visit.crowdflower.com/rs/416-ZBE-142/images/CrowdFlower_DataScienceReport_2016.pdf sądząc po podrozdziale ""Whats next for data science?"", wrzucili zupełnie nieuzasadnienie do jednego worka deweloperów zajmujących się obróbką danych czy innymi sqlami/hadoopami, analityków biznesowych, a nie data scientistów w ścisłym tego słowa znaczeniu, czyli ludzi zajmujących się implementacją i rozwojem rozwiązań opartych na uczeniu maszynowym, sieciach neuronowych czy uczeniu ze wzmocnieniem w róznych dziedzinach życia +oczywiście statystyka ( oczywiście, bo te dziedziny są nierozerwalnie połączone na gruncie teoretycznym i praktycznym w sumie też). Często niestety popełniany jest w różnych publikacjach ten błąd, wynika z młodości tej dziedziny ( w pewnym sensie oczywiście, bo samo uczenie maszynowe jest z nami od wielu dekad) i po prostu z niedouczenia osób, które takie artykuły piszą. Wiele osób niestety nadal nie rozróżnia data scientista od data engineera, deweloperów zajmujących się bazami danych, statystyków, matematyków, analityków biznesowych. Dlatego jeszcze raz radzę dokładnie przeczytać artykuł wrzucony przez @karolinaa , gdzie wszystko jest wyjaśnione (też w podartykułach). Co do umiejętności matematycznych, to oczywiście jest to totalną brednią. Teoria sieci neuronowych i uczenia maszynowego jest spokojnie do opanowanie dla przeciętnego studenta politechniki, statystyki, ekonomi matematycznej itp. To półka niżej niż matematyka czy fizyka teoretyczna.;"
"Tak tylko gwoli uściślenia. Teoria uczenia maszynowego, sieci neuronowych itp. jak już wcześniej wspomniano to nie wyższa matematyka, tylko poziom przeciętnego studenta jakiegokolwiek ścisłego kierunku (od automatyki, przez informatykę do statystyki,matematyki finansowej i ekonometrii). Druga ważna rzecz to to że teoria uczenia maszynowego i pochodnych ma bardzo mało wspólnego z matematyką dyskretną, a bardzo dużo ze statystyką, rachunkiem prawdopodobieństwa, analizą i algebrą. Dlatego też chyba  najwazniejsza ksiązka w historii dotycząca uczenia maszynowego nazywa się ""The elements of Statistical Learning"", a do niedawna termin Statistical Learning był używany tak samo często jak Machine Learning (w odniesieniu do tej samej dziedziny, którą dziś utarło się nazywać Uczenie Maszynowe). Ale to tak tylko chciałem dodać dla uściślenia ;);"
"Zdecyduj się, czy chcesz studia, na których liźniesz wszystkiego ""płytko a szeroko"", czy takie na których nic, tylko tłukł byś w opór programowanie, inżynierię oprogramowania itp. :P Poza tym pierwszy rok to jest na ogół głównie matematyka, ale ciężko wejść w takie tematy jak grafika komputerowa, metody numeryczne, algorytmy, kryptografia, sztuczna inteligencja etc. bez matematyki. Tam bez algebry czy matematyki dyskretnej po prostu ani rusz, chyba że Twoja wiedza o sztucznej inteligencji miałaby się sprowadzać do tego, jaką bibliotekę do SSN zainstalować w tym całym Pajtonie, a nie jak faktycznie działają takie i śmakie sieci neuronowe.  Co to za studia zaoczne, że musisz brać urlop by pójść na WF? o.O  Nie chcę nic mówić, ale taka już chyba specyfika studiów zaocznych. Mniej chętnych, bo trzeba za nie płacić, to i łatwiej się dostać... no tym mniej bystrym.  Może i jest mniej nauki (pomijając to, że za 20 lat zapewne obecne wersje Javy i Springa będą żyć tylko na najstarszych serwerach w starym legacy) ale satysfakcji z pracy też jest jakby niewiele ;)  A co to za uczelnia?  To czemu nie próbowałeś poprawiać matury? Znam takich, którzy próbowali rok w rok do skutku, ćwiczyli do oporu rozwiązywanie matur pod klucz aż po 3-4 próbach się dostawali.  Tak;"
"Jak już wspomniano, studia z informatyki niewiele maja wspólnego z kursem programowania w javie. Trudno mi sobie wyobrazić kogoś po studiach innych niż informatyka/automatyka/elektronika (lub pasjonata) na magisterce z informatyki. Chyba ze na jakiejś wyższej szkole żonglowania ryżem. Bo dostajesz do zaklepania np. jakiś symulator do prezentowania uczenia maszynowego - dla wszystkich problemem jest tylko doczytanie jak to uczenie maszynowe zrobić, bo samo klepniecie symulatora to pikuś, a dla kogoś kto zna tylko jakieś podstawy już nie bardzo.  Dodatkowo nie wiem czy taka magisterka moze ci sie jakoś specjalnie przydać, oprócz kwestii formalnych, w pracy jako PM w projektach IT. Jakbyś miał doświadczenie jako programista/architekt to co innego.;"
"Ja bym tylko wspomniał że Sztuczna Inteligencja != Uczenie Maszynowe. Utarło się tak myśleć w ostatnim czasie, ale Machine Learning to tylko pewien fragment AI. W efekcie to co napisał kolega @Świetny Terrorysta nie jest prawdą.;"
"Problem jest bardzo skomplikowany. Zresztą pamiętam, miałem kiedyś tego typu problematykę na etyce na pierwszym roku studiów. Zagadnienia dotyczyły np. tego czy pozostawić kogoś w stanie wegetatywnym przy życiu czy nie, w zamian jednak ratując kogoś innego, przeszczepiając mu narządy od tej osoby w stanie wegetatywnym. Sprawa jest o wiele bardziej skomplikowana niż się Wam tutaj wydaje. Ale weźmy dla przykładu taki system ekspertowy w oparciu o sieć neuronową typu multilayer perceptron, czy tam feed forward jak kto woli. Skoro mamy tego starszego mężczyznę i tą dziewczynkę a szanse na przeżycie zależą od wielu czynników, weźmy to wszystko na wejścia tej sztucznej sieci neuronowej, zaś na wyjściu mamy tylko jedno wyjście które przyjmuje wartości logiczne: 0 = ratować mężczyznę, 1 = ratować dziewczynkę albo 2 wyjścia przyjmujące jedno wartość 1 a drugie 0, co by odpowiadało kogo ratować. Dość trudny problem, jako że MLP jest tak naprawdę uniwersalnym aproksymatorem funkcji, więc należałoby tu założyć, że szanse są uzależnione od bliżej nieznanej funkcji wielu zmiennych. Sieć ma sobie z tym poradzić, algorytmy albo jaka jest to funkcja nas tu raczej nie interesuje. Jeśli nawet (na bazie już wiarygodnych danych) taka sieć bardzo trafnie podejmowałaby decyzje (to chyba może być problem optymalizacji szans), to tylko zastanawiam się co do tego czy program ma być tym ostatecznym ogniwem decyzyjnym o jak by się to przełożyło na rzeczywistość? Póki co jest czynnik ludzki, tego chyba nie da się tak prosto zaprogramować bo sieci neuronowe w praktycznej realizacji o tak są dość uproszczonym modelem.;"
"grafika 3d, coś ze sztucznej inteligencji (sieci neuronowe, algorytmy genetyczne), coś z multimediów (formaty graficzne, audio, video);"
"Java: Spring + Hibernate. Mam również styczność (jakieś 20% mojej pracy) z Angularem. W planach mam Scalę, jeżeli chodzi o programowanie. Oprócz tego chcę się pobawić Arduino i elektroniką, by wiedzieć z czym to się je. Bazy danych koniecznie, sieci neuronowe i algorytmy genetyczne również brzmią ciekawie. Przemyślę wszystko co podacie, następnie utworzę listę i będę powoli przez nie brnął. :);"
"Doktor pyta ""robotników"" o radę w sprawie..czy warto po 30-stce? Podobno nie ma w Polsce bezrobotnych doktorów, więc chyba można przejść ze złotej góry w przemysłowe błoto korporacji..hehe. A co to R&D?..bo kodowanie dla doktora, to jakieś dno totalne.Nie od dziś wiadomo,że doktorzy myślą rok nad jednym algorytmem, zamiast w tym czasie kosić kasę klepiąc kod np. w Java. Może dla doktora jakiś R byłby odpowiedniejszy, bo to doświadczenie z AI, a wiec również uczenie maszynowe itp.;"
"A ja powrócę do głównego tematu. Czy AI zastąpi programistów? Tych myślących, raczej nie. Tych trzaskających WP: być może. Całkiem fajny wykład na ten temat udzielił Andrzej Krzywda:   temat poboczny: Hindusi w IT -> temat wałkowany od wielu lat, raczej nam to nie grozi. Aktualnie jest raczej trend przenoszenia produkcji z Chin / Indii do Polski niż odwrotnie.;"
"Podsumowując programiści boją się, że to AI ich zastąpi, to się raczej nie stanie, zastąp ich zwykły kowalski :) Samo 'programowanie' wróci do swoich korzeni to znaczy do algorytmiki, matematyki i cybernetyki. 'Programiści' będą tworzyć narzędzia dla zwykłych ludzi by ci sami automatyzowali swoją pracę i tworzyli systemy z których będą korzystać.;"
"Do zastąpienia programistów przez sztuczną inteligencje jeszcze daleka droga... Najpierw z rynku wyparci zostaną pracownicy fizyczni, później na odstrzał pójdą inne zawody. ale wzrośnie zapotrzebowanie na zawody - takie jak: elektroników, grafików (twórcze myślenie), inżynierów materiałowych, inż budownictwa, inż. zarządzanie produkcją itp. Programiści od web'a pewnie też zostaną wyparci (nawet dobrzy)... natomiast, nie wiadomo czy programiści od gier i aplikacji mają się czego obawiać... z pewnością zostaną dłużej na rynku niż web. Wniosek z tego taki, że trzeba trzymać się zawodu, który jest na topie... obecnie to programowanie, później nie wiadomo co będzie ""trendy"". Być może czeka nas przebranżowienie... no chyba że kogoś będą zadowalać niskie zarobki.;"
"Mam pytanie, która z metod poniższych jest najlepsza do zastosowania, gdy chcę rozrzucić na mapie pewne elementy, biorąc pod uwagę inne elementy np podłoże wodę, drzewka etc(w sumie nie ważne co). Nie mogę użyć algorytmu genetycznego. To dostępne dla mnie algorytmy:  Drzewa decyzyjne Sieci neuronowe algorytm uczenia symbolicznego;"
"Ze swojej strony mogę zaproponować sieci neuronowe, data mining - http://en.wikipedia.org/wiki/Data_mining;"
"@onuc:  Ale nie wystarczy. Jest bardzo wiele podatności kryptografii wynikających z technicznej realizacji a nie z matematyki -> różne side channele, cache leak, timing attack...  Ten podlinkowany pdf tylko potwierdza to o czym mówiłem -> nie zawsze można sobie zrobić 2 stopień po jakimś innym kierunku. Nawet na liście którą podałeś widać że na 3 wydziały z informatyką tylko na 2 można się dostać po fizyce lub matematyce. Inne uczelnie mają inne wymagania co do tego. Warto o tym pamiętać żeby się nagle nie zdziwić ;)  Jasne, tylko ile czasu ci to zajmie? Szczególnie jeśli ktoś nie klepał po nocach samodzielnie kodu tylko sobie lajtowo studiował tą fizykę czy matmę. Nie ma szans zrobić wtedy tych studiów ""w terminie"". Bo po prostu projekty są tak dobrane że zakładają pewną podstawową wiedzę i umiejętności studenta, której ktoś mieć nie będzie. Bo tu nagle zamiast kilkudziesięciu linijek kodu z obliczeniami numerycznymi dostaniesz do zrobienia w 10x2 osoby jakiś złożony projekt który trzeba jakoś zaprojektować a potem zintegrować. Albo dostaniesz do napisania kompilator, kiedy w życiu na oczy nie widziałeś nawet żadnej gramatyki formalnej.  Tylko że spora część studiów informatyczych to jest matematyka, tylko trochę inna. I mam wątpliwości czy teoria automatów, teoria współbieżności, teoria obliczeń i złożoności obliczeniowej, kryptografia, obliczenia kwantowe czy przetwarzanie języka naturalnego są jakoś specjalnie łatwiejsze od przedmiotów które ktoś będzie miał na matematyce czy fizyce. Za łatwiejsze można by uznać jakieś przedmioty czysto ""praktyczne"", ale przecież i takie przedmioty spotkasz na tych innych kierunkach.;"
"Podstawowy problem jest taki, żeby ta praca programisty była na tyle stabilna żeby można było z powodzeniem później utrzymać rodzinę. I to jest wydaje mi się główny czynnik składowy, który to może zaważyć nad tym czy dany programista będzie miał szanse na założenie rodziny i stabilny związek. Oczywiście można szpanować że się zarabia te 10k na łapkę, pytanie czy to będzie stabilne i jak długo takie eldorado będzie trwało? Bajera to raczej tylko środek do osiągnięcia pewnego celu. Wiadomo że takie typowe informatyczne nerdy będą miały pod tymi względami przerąbane jeśli chodzi o wszelkie relacje, co nie znaczy że od razu powinni być spisani na straty. Gdzieś czytałem, że dla mężczyzny idealną partnerką będzie taka o cechach jego matki, dla kobiety będzie to ktoś o cechach jej ojca, taka jest przynajmniej teoria. Miało by to jakieś logiczne wytłumaczenie, partnerka zastąpi matkę, partner zastąpi ojca, oczywiście mówię o pewnym obszarze odpowiedzialności i funkcji. Nie wiem jak pod tym względem jest w praktyce. Zawód programisty ma to do siebie, że jest na tyle trudny, że żeby być tym dobrym to trzeba wiele lat nauki, poświęcenia i wyrzeczeń, możliwe że to ostatnie ma jakieś istotne znaczenie w tych sprawach, zwłaszcza jeśli chodzi o sytuacje, kiedy to ktoś taki, kto jest bardzo dobrym programistą nie radzi sobie w relacjach towarzyskich bo olał to poświęcając się nauce. Choć wydaje mi się że to wszystko ma źródło tak naprawdę w dzieciństwie a potem to wszystko się zacznie utrwalać przez lata i mamy oto efekty.;"
"@Yukichan mało przedmiotów z serii ""uczymy się języka X"" ;) Takie to może 1-2 będą. Oprócz tego masz przedmioty typu Uczenie Maszynowe, gdzie niby programujesz, ale ważna jest tu sztuczna inteligencja którą zrobisz, a nie samo programowanie jakie takie ;) Ogólnie większość przedmiotów na studiach będzie z programowania korzystać jako ze ""środku"" a nie ""celu"".;"
"o_O od kiedy Dijkstra jest heurystyczny? Bo A* to jeszcze, ale zwykle heurystyka jest zadana i uzależniona od dziedziny problemu, a nie wymyślana przez jakieś uczenie maszynowe, chociaż pewnie można i tak zrobić...;"
"Z Łodzi dojeżdżają do pracy do Warszawy ale polecam po studiach zamieszkać w Warszawie  Szkoda czasu, bo najprawdopodobniej tych studiów nie ukończysz. Za głęboka woda, tylko 1,5 roku. Po dyplomie z finansów idź do pracy w... finansach :), rozwijaj się, pomyśl o programowania jaku uzupełnieniu finansów. W W-wie możesz w tym układzie zarabiać lepiej od programisty. Zakładam, że zdajesz sobie sprawę, iż słuchanie światłych rad ""programista nie musi mieć nawet matury"" z łączeniem finansów międzynarodowych i programisty fin-tech to nie jest dobra opcja. PS Przykładowa pozycja gdzie możesz się rozwijać MASZ JAK W BANKU: dobór modeli do rozwiązywania zagadnień analitycznych; mierzenie i bieżącą optymalizację efektywności biznesowej modeli; współpracę z programistami implementującymi rozwiązania; przygotowywanie i wstępne przetwarzanie danych; przygotowywanie dokumentacji do tworzonych modeli; proponowanie oraz udział we wdrażaniu narzędzi opartych o rozwiązania sztucznej inteligencji oraz uczenia maszynowego; poszukiwanie nowej wartości dla biznesu na podstawie skomplikowanych algorytmów analitycznych; TWÓJ KAPITAŁ: minimum 4 lata doświadczenia w analityce danych (w tym w uczeniu maszynowym) i wdrażaniu biznesowym zaawansowanych modeli; doświadczenie w stosowaniu modeli matematycznych lub algorytmów wykorzystywanych w Data Science (Machine Learning, Artificial Intelligence) np. deep learning, sieci neuronowe, regresja liniowa/logistyczna, drzewa decyzyjne, random forest; doświadczenie we wdrożeniach biznesowych modeli z dobrymi wynikami biznesowymi; praktyczne umiejętności tworzenia zapytań do baz danych; wiedza z zakresu produktów bankowych; doświadczenie w stosowaniu narzędzi programistycznych takich jak Python (IPython, Jupiter Notebooks) lub R (R Shiny); doświadczenie w pracy na narzędziach analitycznych klasy IBM SPSS/SAS EG; umiejętność negocjacji oraz prezentowania wyników analiz w formie zrozumiałej dla partnerów biznesowych; doświadczenie lub znajomość statystyki w zakresie stawiania i testowania hipotez statystycznych;"
"To jakiś troll? :D :D :D Ja wiem ze ludzie lubią opowiadać takie bajki, że lepiej iść na słabe studia, to będziesz miał czas samodzielnie się uczyć ale 99 na 100 osób wcale tego nie robi.  I dobrze, informatyka nie ma wiele wspólnego z komputerami, oprócz tego że czasem sie ich używa.  Uroki każdych studiów ścisłych. Bez podstaw z matematyki i fizyki potem możesz równie dobrze darować sobie studiowanie, bo zwyczajnie nic nie zrozumiesz. Bo przyjdzie jakaś Teoria Współbieżności czy Automaty i Języki Formalne i nagle bez opanowanej Algebry klękniesz. Albo będziesz chciał robić modne teraz uczenie maszynowe i sztuczna inteligencje albo przetwarzanie języka naturalnego a tu się okaże że bez statystyki i matematyki dyskretnej to możesz co najwyżej skopiować przykład z tutoriala...  Idea jest taka sama. Asemblerów jest wiele, równie dobrze mógłbyś narzekać ze uczą cie x64 a nie ARMa albo AVRa albo PPC albo RISC-V. Konkretnego dialektu i instrukcji i tak musiałbyś sie douczyć, ale ważne żeby rozumieć ""idee"" i umieć poskładać z takich bazowych klocków coś sensownego. Anegdotka: Ocado ma w ramach rekrutacji taki fajny test, gdzie masz dostępny wymyślony asembler z kilkoma (3 czy 4) instrukcjami (inkrementacja, zerowanie, potwórzenie N razy i może cos jeszcze) i masz jakieś 20-30 zadań żeby na bazie tych kilku instrukcji napisać coraz bardziej skomplikowane funkcje, aż do czegoś na poziomie szukania liczb pierwszych. Też będziesz płakać że takiego asemblera cię nie uczyli? ;)  Pytanie co jest twoim celem. Bo faktycznie klepanie formatek u Janusza wymaga obcykania z modnego dziś frameworka. Ale z moich obserwacji wynika, że dobre firmy w ogóle o takie rzeczy nie pytają. Pytają za to właśnie o to, co ty nazywasz głupotami :D Bo oni wiedzą że frameworki przychodzą i odchodzą, ba wiele firm ma swoje wewnętrzne frameworki i guzik ich obchodzi jakiś Hibernate. Więc jeśli ten twój pomysł ze studiami jest w odpowiedzi na opowieści z cyklu #programista20k to pamiętaj, że podejscie ""nauczyć sie szybko frameworka X"" ani trochę cię do tego nie zbliży.  Poszedłem i nie żałuje, ale mnie zwyczajnie informatyka interesuje...;"
"Danie wag na starcie jest taką dodatkową pomocą dla sieci neuronowej - prawdopodobnie dobraną eksperymentalnie. W rzeczywistości sieci neuronowe są przereklamowane i mnóstwo wysiłku trzeba włożyć w odpowiednie przekształcenia danych wejściowych, by sieć zrobiła z nich jak najlepszy użytek - bez tych startowych współczynników też będzie działała, ale - jeśli autor dobrał je dobrze - uzyskasz gorsze wyniki. Z kolei możliwe jest, że jeśli przed wejściem do sieci neuronowej zrobisz zupełnie inne przekształcenie, uzyskasz lepsze wyniki od autora.  Nie rozumiem pytania.  Bardzo dawno (10 lat temu) dotykałem się sieci neuronowych, ale:  funkcję aktywacji wykonuje się na wyniku po zsumowaniu funkcja aktywacji nie powinna być prostą, bo sieć się nie nauczy - można zastosować jakiś wariant funkcji wykładniczej - nie napiszę bardziej szczegółowo, bo nie pamiętam.;"
"@Tvix to zależy od przedmiotu. Są przedmioty ""technologiczne"", szczególnie na początku, których celem jest zapoznanie cię z pewnym zagadnieniem teoretycznym (np. algorytmika, metodyka programowania, modelowanie i programowanie obiektowe albo zasada działania komputera) i jednocześnie nauka konkretnej technologii. Na takich przedmiotach zwykle z góry jest narzucona technologia w której masz pracować. Z drugiej strony masz też całą masę przedmiotów, które są związane juz tylko z pewnym zagadnieniem (np. sztuczna inteligencja, sieci neuronowe, uczenie maszynowe, symulacje, agenty, współbiezność, obliczenia symboliczne) gdzie nikt nie narzuca ci konkretnego języka/technologii, o ile to co wybierzesz znajduje zastosowanie w danej dziedzinie.;"
"Po pierwsze sieci neuronowe nie mają z tym za bardzo nic wspólnego. Można co prawda użyć ich jako klasyfikatora, tj. sieć z 3 wyjściami, ale to jest raczej bez sensu -> nie do takiego problemu... Po drugie tutaj lepszym rozwiązaniem byłoby zmierzenie odchylenia standardowego liczb i porównanie danej liczby do odchylenia => np. jeśli liczba > 3xodchylenie to znaczy, że jest bardzo duża, gdy liczba>2xodchylenie tzn. że jest duża, gdy liczba > odchylenie tzn. że jest średnia, gdy liczba < 0.5*odchylenie tzn. że jest mała. Jeśli rozkład jest normalny to 99% liczb będzie < 3xodchylenie Po trzecie jeśli to ma być ""sztuczna inteligencja"" to zainteresuj się tematem logiki rozmytej.;"
"To o czym piszesz jest jak najbardziej możliwe. Uczenie maszynowe pozwala na nauczenie się przez program wykonywania jakichś czynności, grania w jakąś grę, rozpoznawania obrazów etc. Problem raczej w tym żeby program sam potrafił tak jak ludzki mózg ""kojarzyć"" ze sobą te elementy. No i rzecz też w tym ze ludzie potrafią coś ""wymyślić"" samodzielnie - tego komputer nie potrafi.;"
"Dobrze powiedziane. Maszyna nie rozumie tego co właśnie dostała na wejściu i co przetwarza. Maszyna, na podstawie algorytmów, dokonuje stosownych obliczeń czego wynikiem jest takie, a nie inne wyjście. Maszyna nie potrafi uczyć się poprzez nabieranie doświadczenia, nie potrafi twórczo wykorzystać ""wiedzy"". Takie sztuczne sieci neuronowe np. Przecież cała ""wiedza"" zawarta jest w wagach poszczególnych neuronów. Taki mechanizm nie potrafi tworzyć nowych połączeń pomiędzy nimi w zależności od potrzeby organizmu, którym tutaj jest komputer. To jest tylko i wyłącznie matematyka i algorytmika i nic poza tym. Zresztą wystarczy wziąć jakąkolwiek definicję pojęcia uczenia się, żeby się o tym przekonać. Maszyna nie uczy się przez zrozumienie danej czynności. Maszyna po prostu ją wykonuje i nie ważne dla niej czy robi to dobrze czy źle. Wyniki SSN również Ty jako nauczyciel musisz zinterpretować np. to czy litera 'A' to rzeczywiście litera 'a', a nie np 'b'. Komputer nie zastanawia się: ""A może źle mówi nauczyciel?"" To jest inteligencja właśnie.;"
"@somekind Sztuczne sieci neuronowe przecież też potrafią uczyć się właśnie na podstawie wcześniejszych doświadczeń. Jeżeli komputer, tak jak w przykładzie, który podałeś wygeneruje wszystkie możliwe teksty o zadanej długości, składające się z liter podanego alfabetu i przy okazji wyjdzie mu parę wierszy to oczywiście nie czyni z niego poety. Jeżeli jednak komputer na podstawie wcześniejszych doświadczeń z głoskami, składnią zdań i na podstawie zebranych danych o rymowaniu, symbolice itp. utworzy wiersz - a przy użyciu sztucznych sieci neuronowych jest to możliwe to zrobi dokładnie to samo co człowiek - poeta. Czy niemowlę potrafi układać wiersze ? Też musi poznać dźwięki, głoski, składnie itd... Myślący komputer zaraz po stworzeniu byłby właśnie mniej więcej jak niemowlę (zakładając, że nie wklepałoby mu się od razu jakiejś wiedzy na start). Nie umiałby pisać wierszy, malować, czy nawet dodawać. Musiałby się tego nauczyć. Pytanie tylko, czy świadomie napisałby ten przykładowy wiersz, w jakimś celu, z jakimś przesłaniem, czy po prostu kopiował zachowanie ludzi.;"
Uczenie maszynowe i data mining - kroluje Matlab oraz R do prototypowania i wizualizacji. Kod produkcyjny to glownie Java (bo sa frameworki do przetwarzania duzej ilosci danych jak Hadoop) ale takze C++.;
"Do sieci świetnym źródłem jest https://www.owasp.org . Ogólnie to bym zaczął od podstaw, nie od konkretów, czyli kryptografia, architektura komputerów, reverse engineering, sztuczna inteligencja i uczenie maszynowe. Dużo materiałów jest w internecie, bardzo dobre można znaleźć na podsieciach, jak Tor, czy freenet.;"
"Gościu jaki Comarch? Nikt normalny nie pójdzie po AGHu do firmy, w której nic się nie nauczy. Ludzie po AGHu pracują w Google-u, Intel-u, IBM a nawet Facebooku. Naczytałeś się jakichś głupot i powtarzasz. Ludzie po AGH to elita na rynku juniorskim. Nie mówię o jakichś stosowanych informatykach, które są na poziomie bootcampu. Statystyki mówią same za siebie - po AGHu 90% ludzi dostaje zatrudnienie nie płacąc ani złotówki. Po waszym śmiesznym kursie 25% osób dostaje praca jak ma farta i musi spłacić 16.000 kredytu. Większość uczelni to jest chłam, zgadzam się ale AGH to jest elita w Polsce i każdy kto tam nie studiował niech się nie wypowiada o poziomie studiów. Bo absolwenci AGH przewyższają każdego bootcampowicza pod każdym względem. Wy się uczucie na tym kursie wstawiania przycisków i kolejnego CRUDa według określonego schematu. Nas nie uczą konkretnej technologii, ale kładą ogromny nacisk na nasz rozwój intelektualny, umiejętność samodzielnego myślenia, rozwiązywania problemów. Nikt nam nie tłumaczy jak robić CRUDa bo to nie ma sensu, po AGHu wychodzą ludzie myślący, a trzymani za rączkę jak na kursie. To właśnie wy po kursie jedyne co możecie zrobić to klepać tego cruda czy tam szabloniki do wordpressa. A my absolwenci AGH rozwijamy sztuczną intelegencję, która takich klepaczy jak wy umiejących jedynie klepać kod w danej technologii, prowadzonych za rączkę na kursie, za parę lat zastąpi :);"
"Mam takie wrażenie, że niektórzy myślą, że ja po bootcampie online spodziewałem się robić algorytmy w dla Googla. Nie o to było moim celem. Klepie crud-y, ale zarabiam 800 zł więcej niż w poprzedniej pracy. Mogę zacząć pracę między 7-10, spokojnie dzieci do szkoły zawiozę. Nikt  nade mną z batem nie stoi i nie robi wrzutów, że plan nie zrobiony. Pracuje spokojniej. No i jakaś podwyżka po nowym roku będzie, odgórnie tak jest w firmie co rok. Nie muszę się prosić. I tak prawdę powiedziawszy jak będziesz sobie robił dla tego FB, czy innego Googla algorytmy, za 20K, czy 30K to na zdrowie mnie nic z tego tytułu nie ubędzie i gratuluję wyboru drogi życiowej w młodości. Pewnie kiedyś SI zastąpi takich klepaczy jak ja, ale na teraz jest super. I taki drobny niuans, nawet jak czujesz się lepszy i elitarny jak zwał tak zwał, to zachowaj to dla siebie. Gdyż z mojego wieloletniego doświadczenia w różnych pracach i firmach, wiem że aroganci (bez pleców) nie są mile widziany. Jakie umiejętności by nie mieli. To jest często praca zespołowa i z takim podejściem to ... No nikt nie chcą ludzie pracować z dupkiem. Nie daj Ci Boże, żebyś trafił na przełożonego z kompleksem małej uczelni z krańca świata i wygłosił taką mądrość. Jeżeli to będzie mały człowiek to Cię zniszczy i pójdziesz z łatką ""trudnego"" w świat. Zdziwisz się jakie małe potrafi być środowisko dużych korpo. Tak przy okazji znam programistę, który dawno temu nie dokończył jednej z prestiżowych uczelni, bo go normalnie nudziło i miała za niski (w jego odczuciu) poziom. Od kilkunastu lat pracuje w firmie na M, nie w Polsce, nie mam pojęcia ile zarabia. Człowiek ten jest jednostką wybitną i myślę, że przerasta o epokę 90% populacji z którą pracuje. Przy tym jest miłym, uczynnym i pomocnym człowiekiem. Nigdy nie da Ci odczuć, że uważa się za lepszego. Jak czegoś nie rozumiesz wytłumaczy jak małemu dziecku najbardziej zawiłe sprawy. Dla mnie on jest elitą.;"
"Witam. Od ostatniego czasu na stronie pojawiło się trochę nowych treści m.in.:  artykuł o SVM opis działania strategi ewolucyjnych wizualizacja działania perceptronu z wykozystaniem PyQt4 oraz portowaniem canvansa matplotliba(żeby nie było za łatwo) Opisanie algorytmu gazu neuronowego W dziale z filmami: wizualizacja działania perceptronu animacja działania metaheurystyki niedawno przeze mnie opracowanej (możliwe, że nie ktoś wcześniej to badał, lecz nie mogę znaleźć tego w literaturze) wizualizacja ""autka"" sterowanego logiką rozmytą wizualizacja symulacji fizycznych (matplotlib + scipy) seria filmów ukazujących ewolucję projektu (dla rozrywki) traktującego o uczeniu sieci neuronowych za pomocą mojej nowej metaheurystyki. Dokładniej uczone są sieci neuronowe sterujące pszczołami, których zadaniem jest zebranie jak największej ilości nektaru z kwiatów Animacja uczenia sieci neuronowej W dziale ze źródłami można zaleźć podstawkę do algorytmów aglomeracyjnych, klasyfikacji oraz klasteryzacji, która implementuje kilka przydatnych klas takich jak CPoint, CCluster, CMetric, CDistance oraz CHelper z wykożystaniem numpy oraz matplotlib'a, oraz kody źródłowe do większości treści prezentowanych na stronie.  Na dniach zostanie dodane:  segmentacja oraz kompresja obrazu z wykorzystaniem algorytmu gazu neuronowego, wstęp do logiki rozmytej, coś o teorii gier oraz pisaniu własnego programu do gry w GO.  Serdecznie zapraszam do odwiedzania strony, komentowania, wytykania błędów, dawania propozycji. Z chęcią dokładniej wytłumaczę to co jest niejasne, bądź niezrozumiałe. Polecam także subskrybowanie kanału RSS lub Like'owanie Facebookowego fun-page stronki, gdyż pojawiają się tam na bieŻąco (Boże, widzisz takie błędy i nie grzmisz) informacje o nowych treściach.;"
"Ok, ale nie każdy lubi się uczyć i co wtedy? Gorszy jest? Poza tym gdyby się wszyscy tak uczyli, to kto pracował by fizycznie? Mam wrażenie, że wiele osób tutaj czuje się lepsza od innych bo ma prace umysłową. Ja tam też uważam, że nie każdy musi być wielkim fanem wiecznego rozwijania się, pracowania, rozwijania się, pracowania itd. Każdy ma inne priorytety i o ile zgadzam się, że normlane jest to, zę ten kto ciężko pracuje i się rozwija zarabia więcej, ale to nie znaczy, że pracownik fizyczny ma żyć jak śmieć. Ja osobiście w przeciwieństwie do aurel uważam, że to własnie coś normalnego, że każdego pracującego powinno być stać na mieszkanie i samochód, bo to nie są żadne dobra luksusowe. Poza tym aurel, żebyś się na tych swoich dość radykalnych poglądach nie przejechała. Teraz jesteś młoda, masz ochote, siły i czas na uczenie sie, zwiedzanie świata. Ale pamiętaj, że Ty też sie zestarzejesz. Myślisz, że jak będziesz po 40 to nadal będziesz miała tyle sił? Pamiętaj, światopogląd może CI sie zmienić. Wiem, że za młodu można odłożyć pieniądze i potem zainwestować w jakiś choćby mały biznes, który z powodzeniem zastąpi emeryture, ale należy pamiętać, żę nie każdy ma predyspozycje do prowadzenia firmy, nie każdy ma pomył na biznes. Poza tym co by było, gdyby nagle wszyscy firmy pozakladali? Państwo potrzebuje każego rodzaju ludzi, i tych wykszałconych naukowców, ale i tych po zawodówce. To dzięki współpracy wielu ludzi technologia się rozwija. Jedni opracowywują jakieś pomyły, ale ktoś musi to też wykonać/zbudować.;"
"Jemu nie chodzi o narzedzia, a konkretny cel jaki osiagnie uzywajac ich. Jezyki sa jedynie narzedziami. W informatyce masz wiele specjalizacji, wybierz sobie 1-2 i w nich sie ksztalc. Tak z glowy moge wymienic: sieci, grafika, gry, telekomunikacja, inzynieria oprogramowania, analiza danych, technologie webowe. Wiekszosc wydaje sie jasna i kierunki rozwoju czy pracy tez. Inzynieria op. i analiza danych to  m.in. sztuczna inteligencja, sieci neuronowe, kryptografia itp. Jest sporo wiecej, ale to sa chyba takie podstawowe. @spartanPAGE Akurat java moim zdaniem jest najlatwiejszym jezykiem do nauki na start. Pelna obiektowosc i poczatkujacy nie musi martwic sie wieloma rzeczami, ktore wiaza sie np. z pisaniem w c/c++.;"
"Czyli, czytając to, co Cię interesuje, nie radzisz sobie z tego ogarnięciem, ale i tak prosisz nas, byśmy polecili Ci materiały na tematy, na które już materiały znalazłeś? :) Polecane materiały nie będą się zapewne różnić od tego, co sam znajdziesz w sieci. Problem w tym, że sam chyba nie wiesz o co się pytasz i co chcesz osiągnąć. Wiem, że fajnie się zadaje pytanie zawierające ""sieci neuronowe"" w tytule, ale jeszcze fajniej zadać pytanie, na które można udzielić konkretnej i wartościowej odpowiedzi.;"
"Poszukaj jakiś prac naukowych na ten temat: http://www.hindawi.com/journals/isrn/2013/156540/ Wg. mnie bez informacji o ciśnieniu ciężko coś takiego przewidzieć. Z różnicy ciśnień masz wiatr, a ten powoduje duży wpływ na klimat. Jeśli masz do dyspozycji tylko temperaturę lokalną to odpuściłbym sieci neuronowe i raczej poszedłbym w metody czysto numeryczne: http://www.cs.ccsu.edu/~markov/ccsu_courses/DataMining-8.html;"
"Od jakiegoś czasu interesuję się Sztuczną Inteligencją. Jak wiadomo większość algorytmów ma przeróżne parametry. Sieci neuronowe mają ilość neuronów, warstw etc. Algorytmy  genetyczne mają ilość pokoleń, początkową populację etc. Tak naprawdę to konfigurowalność takich algorytmów jest niemal nieograniczona. Szukam jakiegoś oprogramowania które pozwoli na przetestowanie wybranych parametrów czyli krótko mówiąc odpali algorytmy z zadanymi grupami parametrów (lub zakresami parametrów) i przedstawi w jakiś sensowny sposób wyniki (do głowy przychodzą mi tylko wykresy różnych wartości), tak żeby później użytkownik mógł stwierdzić że dane zakresy parametrów są korzystne, a inne nie. Na pewno takie systemy istnieją, jeżeli nie dla AI to przecież jest szereg problemów z różnych dziedzin, jak choćby szeroko rozumiana inżynieria/przemysł. Jest tu bardzo wiele algorytmów czy nawet nie algorytmów ale problemów które rozwiązuje się za pomocą różnych algorytmów. Weźmy np. inżyniera który ma dobrać średnicę, grubość, materiał (i co tam jeszcze można sparametryzować) do łopat sprężarki, byłoby fajnie gdyby mógł (kierując się swoją wiedzą) sprawdzić różne wartości i zobaczyć jaki wynik dają - a właściwie wyniki, ponieważ tutaj, tak jak w AI nie ma jednej odpowiedzi. Może być tak że np. z danym parametrem rośnie sprawność sprężarki, ale spada wytrzymałość, albo od pewnego momentu wzrostu wydajności zużycie energii rośnie nieproporcjonalnie i taki inżynier też chciałby zobaczyć w którym momencie tak się dzieje. Czy znacie jakieś systemy tego typu? Szczerze mówiąc to nawet nie wiem co wpisać w google.;"
"Co do praktyk darmowych to zbyt duzych wymagan nie maja. Stawialbym raczej na jakies platne, ale wtedy musisz przejsc testy wstepne, ktore dana firma przeprowadza. U nas np. wybiera sie z kilku dostepnych dziedzin, powiedzmy bierzesz sobie java + sql i piszesz test. Prawde mowiac na takich praktykach w 3 miesiace uczysz sie wiecej niz na studiach przez 3 lata. Dla mnie najgorsza rzecza jest to, ze ucza nas duzo teorii, ok jest ona przydatna, ale powinni uczyc rzeczy na prawde przydatnych czyli jakis hibernate, spring, ormy ogolnie. Np. na politechnice lodzkiej niby ucza dosyc duzo, asm, cpp, java, ada, sql, sztuczna inteligencja, kryptografia, linux dosyc szczegolowo, sieci, jakies smieci webowe, troche photoshopa i opengl, jakies sieci neuronowe jeszcze itd. Matma tez oczywiscie jest bo kryptografia bez dyskretnej by nie przeszla. No i na dobra sprawe wydaje sie duzo, ale jak przyjdzie co do czego i w robocie kaza podpiac sie pod silnik hibernate, zrobic to i tamto, to w praktyce okazuje sie ze gowno umiesz ;) i dlatego firmy musza robic takim studentom 3 miesieczne praktyki, a potem dopiero moga z nich korzystac ;p;"
"No nie jest jakoś hiper-obiektywne, porównujesz tylko jeden aspekt. Tymczasem na UG nie mają nawet w połowie tak fajnych laboratoriów, jak ma PG. Może ktoś z UG sprostuje, ale na PG zajarana byłam tym, że np. mogłam pobawić się routerami ATM, WiMAXem, laboratorium z prokurvami było dostępne dla studentów bez ograniczeń, mogłam zobaczyć Galerę na żywo, wycinałam własnoręcznie anteny po czym badałam ich moc w super-hiper-wygłuszonym laboratorium. W ogóle na UG dostępne są tylko 3 specjalizacje: Inteligencja obliczeniowa, Algorytmy, Informatyka ogólna - trochę słabo, porównując do PG: Aplikacje rozproszone i systemy internetowe; Inteligentne systemy interaktywne; Inżynieria systemów i bazy danych; Technologie internetowe i algorytmy; Sieci komputerowe; Systemy geoinformatyczne i mobilne. A te dwie ostatnie specjalizacje (tzn. ich katedry) mają naprawdę świetnie wyposażone laboratoria. Nic z tych rzeczy nie pomaga w programowaniu, ale ja nie szłam na studia uczyć się programować. Bardziej niż algorytmy, interesowała mnie sama budowa komputera (od poziomu bramki logicznej, przez układ scalony do mikroprocesora) a potem wciągnęły mnie sieci i działanie Internetu. Dlatego też nie zgadzam się, że niby uniwersytety generalnie i obiektywnie są lepsze od politechnik. Nie twierdzę też czegoś odwrotnego, chociaż IMHO akurat PG jest lepszym wyborem niż UG (ale raczej nie lepszym niż UW).;"
"Jak najbardziej daje efekty. Są działy przemysłu, które bezpośrednio wymagają wiedzy z algorytmów i matematyki:  eksploracja danych, uczenie maszynowe: wymaga wiedzy ze statystyki, teorii informacji, algorytmów przetwarzanie sygnałów: potrzebna wiedza z analizy, statystyki, elektroniki, fizyki silniki baz danych - algorytmy, teoria mnogości, przetwarzanie rozproszone soft do zastosowań inżynierskich - zależy od działu, głównie analiza i przetwarzanie równoległe bezpieczeństwo - znajomość kryptografii Do każdego działu mogę wymienić Ci firmę w Polsce, która potrzebuje tych konkretnych umiejętności.  Nie znam NIKOGO, kto by przykładał się do studiów i nie znalazł pracy w IT. Ci co nie mogą znaleźć zatrudnienia jako programiści byli po prostu słabi na studiach zarówno z przedmiotów praktycznych jak i teoretycznych. A jak ktoś nie potrafi po studiach wziąć się w garść i np. napisać jakiegoś projektu open-sourceowego żeby sobie zapewnić trochę praktyki i mieć co pokazać na rozmowie kwalifikacyjnej to znaczy że po prostu nie nadaje się do pracy. Obecnie w Polsce jest ogromne zapotrzebowanie na programistów i żeby załapać pierwszą pracę bynajmniej nie trzeba być mega mózgiem.;"
http://sztuczna-inteligencja.co-za.info.pl/Sieci%20neuronowe/Predykcja/44-Predykcja/71-Predykcja%20ciag%C3%B3w%20czasowych%20za%20pomoc%C4%85%20sieci%20neuronowych.html Generalnie to masz racje. Musisz po prostu obliczac wagi w twojej symulacji czasowej. Jesli znajdziesz wyznacznik dla obliczenia wagi to bedziesz mogl wykorzystac sieci neuronowe. Pozdrawiam;
"Rzuciłem okiem na przedmioty i generalnie nie powala. Jest tam jeden przedmiot który obejmuje wprowadzenie od informatyki, automaty, kompilatory i teorie złożoności obliczeniowej. Ciekawi mnie jak oni to tam chcą upchnąć w jeden semestr (u mnie np. to było 6). Poza tym nie ma tam właściwie nic ""obliczeniowego"" (metod numerycznych np.). Tak samo upychają sztuczna inteligencję, uczenie maszynowe, sieci neuronowe i symulacje w jeden semestr (u mnie np. to było 5). No i skisłem jak zobaczyłem: http://www.wsti.pl/images/stories/sale/pracownia%20komputerowa%20iMac/WSTI-226B.jpg :P Stronka robi dobre wrażenie bo przynajmniej są na niej jakieś sensowne informacje. Ale nie spodziewałbym się że zrobią tam z kogoś nowego zwycięzcę top codera ;);"
"Na zlecenie nie (jeszcze nie miałem takiej przyjemności) natomiast co do własnych projektów OS to tak. Napisałem taki program do symulacji sieci typu MLP, ma szerokie zastosowanie do różnych prognoz a nawet predykcji szeregów czasowych. Swego czasu zaobserwowałem (w określonych przedziałach czasowych) na sf zainteresowanie i dużą liczbę pobrań, wielu użytkownikom się musiało spodobać. To było do przewidzenia. W Polsce mało kto się tym zajmuje i interesuje, oczywiście są i firmy takie jak np. Neurosoft, oni właśnie robią jakieś zaawansowane oprogramowanie. Oglądałem gdzieś na YT jakieś prezentacje inteligentnych systemów w ruchu drogowym np. do wyłapywania kierowców przejeżdżających na czerwonym świetle. Jeśli te systemy będą powszechne w Polsce to się mandaty posypią. Nie zdziwiłoby mnie zastosowanie w sterowaniu ruchem przez inteligentne systemy sygnalizacji świetlnej.  na pewno nie w Polsce. Tu jak sądzę nie przejdzie. Musiałbym dysponować sporym kapitałem a o inwestora trudno (no chyba że mu oddasz większość udziałów w firmie).  Co nie znaczy że nie można tego wykorzystać w praktyce w komercyjnym serwisie jako tool do wykrywania spamu, łamania regulaminów na forum (hejtowanie, trolowanie). Wiesz, tu nie chodzi o to że takie bajery nie mają zastosowania, problem polega na tym że koszt na ich wdrożenie jest ogromny a to nie koniecznie może oznaczać zyski.  No cóż. I pewnie masz rację. Wiesz, to nie chodzi o to że mam jakieś chore ambicje. Też w większości przypadków w zasadzie jestem typowym klepaczem i po prostu to co jest do zrealizowania (specyfikacja klienta) to jest realizowane i tyle. Co nie znaczy że nie mam pomysłów, które mógłbym wdrożyć o ile ktoś faktycznie by się tym zainteresował. Bo we własnych projektach nie ma problemu - realizuję to co chcę.;"
"Tak też ludzie myśleli 40 lat temu jak wymyślono sieci neuronowe. I minęło te 40 lat a sieci neuronowe nie dość że wcale nie rozwinęły się tak jak planowano, to jeszcze w wielu miejscach zostały zastąpione przez inne, czytelniejsze rozwiązania (sieci bayesa, drzewa decyzyjne, reguły asocjacyjne i wiele innych). Niestety ale komputery nadal doskonale radzą sobie z szybkim wykonywaniem prostych, powtarzalnych operacji i w zadaniach ściśle ""specjalizowanych"" ale zupełnie nie radzą sobie w zadaniach ogólnych, abstrakcyjnych i wymagających ""kojarzenia"". Zamiast wymyślać koło na nowo wpisz w google ""reprezentacja wiedzy"" i czytaj.;"
"Chłopie czy ty masz jakiekolwiek pojęcie w tym temacie czy tak sobie tylko trollujesz? o_O Takie pojęcia jak uczenie maszynowe ci coś mówią? Inferencja reguł i drzew decyzyjnych? Na pewno naukowcy od Watsona przez te całe lata pracy nad nim ""kodowali sobie reguły"" i zrobili ""typowy system ekspertowy"". Kończę zaglądać do tego tematu bo jeszcze mi iq spadnie od czytania twoich postów... Ale kusi mnie przeniesienie tego do perełek.;"
"nie, kompiter nie rozumie. przez procesor płynie prąd o zmiennym napięciu. napięcie poniżej pewnej wartości reprezentowane jest jako zero, powyżej niej jako jeden(a raczej TRUE/FALSE). to wszystko. i procesor nie zapisuje. on przesyła tam, gdzie należy. elementarna wiedza.  gdyby to było takie proste, że od samej złożoności i poziomu abstrakcji zależy to czy ta świadomość jest czy jej nie ma... za przeproszeniem, zaczynasz od d* strony. najpierw zwrócić należy uwagę, do jak wielu rzeczy zdolny jest umysł świadomy- do uczenia się i wyciągania wniosków. to dużo więcej niż tylko powtarzanie i szukanie w pamięci, co jest jedyną ""umiejętnością"" bardzo zaawansowanych, jak na dzisiejsze czasy ""systemów inteligentnych"". zdolny jest do samodzielnego organizowania, porządkowania, szufladkowania zdobytej wiedzy, doświadczeń. grywałeś w dzieciństwie z kolegami w skojarzenia? zauważ: pewne słowa(a raczej to, co reprezentują) wywołują podobne skojarzenie u większości osób. inne wywołają podobne skojarzenie tylko w obrębie jakiejś grupy. nazwisko nielubianego nauczyciela wśród uczniów jednej klasy wywoła skojarzenia bardzo zbliżone, ale jeśli to samo nazwisko padnie podczas gry z osobą, która danego nauczyciela widziała tylko parę razy na korytarzu, skojarzenie będzie już inne. jest też bardzo wiele słów, które w każdym człowieku wywołają zupełnie odmienne skojarzenie. z pozoru niewinna i mało ambitna gra w skojarzenia świetnie pokazuje, że każdy świadomy i myślący organizm organizuje swoją wiedzę i nabyte doświadczenia w najróżniejszy sposób-taki, jaki jest dla jednostki najbardziej optymalny. tego się nie da narzucić, to przychodzi samo. złożoność powiązań pomiędzy znaczeniami wyrazów(rozumujemy wyraz poprzez jego znaczenie. nazwa to tylko abstrakcyjna forma nadawana mu na zewnątrz) jest wynikiem porządkowania, układania i kojarzenia ze sobą znaczeń, a nie ich przyczyną. wniosek z tego się nasuwa taki, że tworzenie sieci neuronowej przy założeniu, że dzięki samej złożoności będzie inteligentna to ożywianie zmarłego- wszystko niby działa i żyje, ale w środku absolutna pustka. i oto odpowiedź na pytanie, dlaczego sieci neuronowe tworzone przed czterdziestu laty zawiodły, oraz dlaczego zaczynanie tworzenia świadomości w ten sposób jest tak żałośnie naiwne. a jaka jest rola DNA? kieruje życiem pojedynczej komórki, która jest najmniejszą formą życia w organizmie. sam sobie odpowiedz, czy ma się to jakoś do świadomości. w starszego pana nie wierzę. wierzę w istotę tak doskonałą, że nie jest jej do niczego potrzebne ciało ani forma. istotę przepełniającą cały wszechświat i dużo więcej przestrzeni oraz iejsca zupełnie z przestrzenią niezwiązanego, która sprawiła, że jestem i która za kilkadziesiąt lat oddzieli moją duszę od ułomnego ciała(ciało z definicji nie jest i być nie może doskonałe) i zabierze ją do Raju.;"
"Jeśli chodzi o sztuczną inteligencję, to zanim zaczęły się zajęcia to też myślałem, że to fajne, a potem na zajęciach prowadzący pokazał, że to niefajne :D Na egzaminie główne zadanie ""praktyczne"" to obliczyć wyjście systemu wnioskowania rozmytego Mamdaniego lub Takagi Sugeno. Nie wiem, czy to takie fascynujące i interesujące. Projekty to też np. uczenie się rozpoznawania rodzajów grzybów lub rodzajów szkła na podstawie danych wejściowych. Wszystko fajnie, ale niczego z tego nie sprawdzaliśmy w praktyce - uczyliśmy tylko nasze sztuczne sieci neuronowe za pomocą funkcji matlabowych - learnbpm, trainbpx itp. Potem podawaliśmy błąd uczenia. Spodziewałem się czegoś ciekawszego po tym przedmiocie. Miałem nadzieję, że będzie coś o sztucznej inteligencji w takim aspekcie, jak np. gra ucząca się grać w szachy sama od siebie (program wystawiony przeciwko sobie) albo od gracza - to by było dużo ciekawsze niż nic nie warte obliczenia. Studia w wielu przypadkach (na wielu przedmiotach) cię zawiodą. Nie wszystkie przedmioty są jak matma - ponadczasowe, które może wykładać nawet dziadek nie dokształcając się zbytnio. Na informatyce jest wielu staruchów, którzy uczą swój stary przedmiot pod nową nazwą. Tępią z języka C i Pascal'a, bo to jest przecież jedyny język, który znają itd. Stąd też studiowanie informatyki w Polsce to tak naprawdę historia informatyki. Jak ci ludzie mają przygotować kogokolwiek do pracy w zawodzie informatyka skoro sami mają duże braki w aktualnych trendach i studenci muszą ich uczyć nowych technologii? Rozumiem jeszcze jakby używali na zajęciach Free Pascal'a, który jest kompatybilny z najnowszym sprzętem i systemami operacyjnymi, ale nie, zazwyczaj prowadzący zajęcia w Pascal'u każą klepać w Turbo Pascal 7.0... Na początku powinieneś studiom poświęcić więcej czasu, ponieważ na początku jest największy odsiew. U mnie większość osób, która odpadła - zrezygnowali, nie dali rady itp. - zrobili to tuż po pierwszym semestrze. Potem raczej wszyscy wytrzymali do końca.;"
"Zatem do informatyki zaliczać będziemy zarówno:  programowanie, jak i: formatowanie dokumentów w Wordzie, tworzenie wykresów w Excelu, korzystanie z GIMPa, wykorzystywanie Mathematiki do liczenia całek/uczenia sieci neuronowych/whatever, projektowanie budynków, zagadnienia związane ze sztuczną inteligencją, architekturą procesorów,  et cetera.    Inny przykład - Vsauce wrzucił kiedyś filmik o paradoksie Banacha-Tarskiego ( ). Świetnie się go oglądało, solidny materiał, ale pod koniec stwierdziłem, że tak w sumie to nic z tego filmu nie rozumiem. Dopiero za trzecim pełnym obejrzeniem na przestrzeni dwóch tygodni zacząłem pojmować, co się tam dzieje (a nie jestem wcale opóźniony w rozwoju). Złota zasada: jeśli nie potrafisz jakiegoś zagadnienia wytłumaczyć tak, aby zrozumiała to Twoja matka/żona/dziewczyna/kuzyn/brat/(...) - to znaczy, że sam nie znasz danego zagadnienia.  Warto się wszechstronnie rozwijać choćby po to, aby mieć czym zaszpanować przed innymi czy też móc porozmawiać na inny temat niż np. wojsko (mam takiego znajomego, który swojego czasu 90% rozmowy prowadził tylko o tym, a przegadać go ciężko ;) - domyślasz się zapewne, że nie wracasz do rozmowy z takimi ludźmi z uśmiechem).  Nie mówiąc o tym, że taka ""akademicka"" matematyka przydaje się później - nawet jeśli nie zostaniesz jakimś super zajebistym informatykiem w majkrosofcie, co to własnymi rękami dotyka jądro Gatesa, to warto pewne rzeczy znać, bo nigdy nie wiadomo, co Cię zainteresuje. Przykładowo taki raytracing czy sieci neuronowe - świetna sprawa, obydwa dają niesamowite efekty... ale jeśli chcesz robić coś więcej, niż kamerę ortogonalną czy proste sieci feed-forward, no to bez porządnej znajomości geometrii/całek/bógwieczegojeszcze tak naprawdę nawet nie przełkniesz artykułu przedstawiającego dane zagadnienie ""dla początkujących"". Przekopiujesz gotowy kod tak samo, jak ja podstawiłem dane pod wzór sądząc, że potrafię rozwiązać tamto zadanie.   Oczywiście nie twierdzę, że Twój rytm dnia ułoży Ci się ot tak czy też że powinieneś pójść do pracy i się przedwcześnie stresować :D (pozdrawiam moich rodziców) To jest coś, co się wypracowuje z czasem. Póki co postaraj się przyłożyć do nauki materiału przewidzianego przez podstawę programową, a zainteresowania swoją drogą. Na przykład programuj po 2h dziennie, ucz się też 2h, a resztę dnia ułóż jak Ci się podoba. Pamiętaj jednak, że znajomi to równie(ż) ważna sprawa ;-) Tak jak już mówiłem: zaczyna się od podstaw, a uczy do śmierci ;) PS http://pomodorotechnique.com * która przewidziana jest na materiał liceum, czyli 3 lata później, i o której nie miałem bladego pojęcia na tamten czas.;"
"Witam, na początek ogromne podziękowania dla uczestnika i moderatora tego forum Deti-ego za udostępnienie biblioteki HSynapse z zaimplementowaną siecią neuronową :). Mam nadzieję, że autor się nie pogniewa i pozwoli spróbować przerobić (mam nadzieję, że naszymi wspólnymi siłami) ten kod na C++. Cel tego wątku Dlatego, że od dłuższego czasu interesuję się sztuczną inteligencją, co zresztą skłoniło mnie do nauki programowania w C++ (ciągle się uczę!), chciałbym w końcu wykorzystać te mechanizmy w praktyce. Niestety nie urodziłem się informatykiem i mam pewne problemy z myśleniem obiektowym a poza tym nie mam jeszcze dużego doświadczenia, dlatego na początku postanowiłem bazować na czyjejś pracy. Niestety biblioteki, które znalazłem w internecie napisane w C++ albo są gigantycznie długie (i ciężko jest je analizować) albo dot. tylko jednej warstwy ukrytej, albo są napisane strukturalnie (a chciałbym zrobić to obiektowo) i w ogóle ciężko znaleźć coś wartościowego, więc czuje się ""zmuszony"" (to kiepskie słowo ale nic) bazować na - wydaje mi się - bardzo ciekawiej koncepcji implementacji sieci napisanej przez Deti-ego -> niestety w języku C#. Pierwszy kontakt z tym językiem trochę mnie zniechęca (mimo, że większość z was twierdzi przeciwnie). Jednak mimo wszystko zależy mi na tym kodzie i nie chcę się tak łatwo poddać. W związku z powyższym co jakiś czas będę zamieszczał w tym wątku jakąś klasę z biblioteki Deti-ego i ""próbował"" samodzielnie (lub z wami) ją przerobić na C++. Niestety, z uwagi na niezbyt dobrą znajomość programowania i praktycznie zerową znajomość C# obawiam się, że często będę potrzebował waszej pomocy. Pomoc może polegać zarówno na wyjaśnianiu kwestii technicznych, sprawdzeniu poprawności mojej lub czyjejś implementacji jak również (co jest najbardziej pożądane) samodzielnej próbie napisania/przerobienia kodu :). Będę wdzięczny i bardzo zobowiązany z okazania wszelkiej pomocy! Zdaję sobie sprawę, że nie jest to kwestia minut czy godzin mam jednak nadzieję, że jakoś się z tym uporamy :) drobne uwagi Wstępnie Deti omawia działanie tej biblioteki w tym wątku: Backpropagation i SSN typu RBF natomiast tutaj: Sieci neuronowe, aproksymacja i rozpoznawanie pisma można znaleźć artykuł napisany przez Detiego o SSN. P.S. Prosiłbym również o merytoryczne wypowiadanie się w temacie a nie bezcelowe uwagi np. dot. wyboru przeze mnie języka etc. Aha, jak by co to: nie, nie chcę uczyć się innego języka programowania - zacząłem C++ i obecnie opanowanie go jest jednym z moich celów, i nie chcę go zmieniać. No to zaczynamy :);"
"A masz jakieś większe pojęcie o programowaniu ? Bo napisałeś w następujący sposób...  Kurs ? Papierek praktycznie nic Ci nie da w przypadku programowania. O niebo lepsze są studia. Nie ze względu na papierki, ale na kontakt z ludźmi o podobnych zainteresowaniach. Tych ludzi nie będzie dużo, bo wiadomo czym zajmuje się ~90% studentów, ale zawsze się znajdą koledzy/koleżanki do współpracy w kole, etc. I tak najważniejsza jest samodzielna nauka.  To słabo szukałeś, ale nie trać na to czasu. Jeśli chcesz ""kurs"", to poszukaj jakichś darmowych. Choć to i tak nie zastąpi dobrej literatury.  Taaa... Visual C++ to nie język.  Nie ma takich kursów. Kolejny kwiatek - ""symfonia c++"", to nie język, tylko książka. Podsumowując - jak chcesz ""kursów"", to lepiej idź na studia informatyczne i w międzyczasie możesz szukać jakichś zleceń. Jeśli nie, to inwestuj w książki i się z nich ucz, programuj, bierz udział w dyskusjach na forach programistycznych, czytaj blogi specjalistyczne, etc. Życzę powodzenia :);"
"Nie bardzo wierze że na mechanice musicie pisać sieci neuronowe no ale mniejsza. Ciężko Ci będzie znaleźć kogoś kto Ci pomoże nieodpłatnie gdyż to trudny temat, Ci którzy zrobili coś podobnego szanują swoją wiedzę. Jeśli pali Ci się tyłek to poszukaj na sieci kogoś (gdzieś tu w serwisie był link do bloga osoby która zrobiła rozpoznawanie cyfr ze zdjęć) i poproś o odpłatną pomoc.;"
"Hmm Deti ostatnio umieścił swój program na stronie, który wykorzystuje SSN napisany w C#... Jeśli chodzi o SSN to jest masa książek o nich i trudno w jednym poście napisać jak to działa... Osobiście polecam książkę S. Osowskiego pt. ""Sieci neuronowe do przetwarzania informacji""! Książka opisuje w piękny sposób krok po kroku co należy robić i opisuje mase algorytmów uczenia dla każdego rodzaju sieci. Analizując Twoje pytania sądzę, że nie masz większego pojęcia o sieciach neuronowych dlatego polecam zakup tej książki (w porównaniu z harrym poterem jest bardzo tania! :) ). Tak na szybko mogę jedynie powiedzieć, że obliczanie wag zależy od typu sieci oraz od przyjętego algorytmu. Backpropagation to zwykła metoda gradientowa (z momentum lub bez) i wagi oblicza się odejmując od obecnych wag gradient funkcji celu (znaczy się jego część). Dlatego wystarczy jedynie policzyć dE/dw i część tego odiąć od obecnej wagi... Jeśli chodzi Ci o sieć typu jednokierunkowa sigmoidalna to jest to najbardziej opisany typ sieci włącznie z metodą backpropagation... Dlatego tym bardziej zachęcam do przeczytania jakiejś książki a dopiero później w razie jakiś wątpliwości zgłosić się w celu wyjaśnienia pewnych kwestii... Pozdrawiam!;"
"mam książkę Osowskiego  ""Sieci neuronowe  w ujęciu algorytmicznym"", ale to kompletna żenada. Pełno tam wzorów do każdej sieci na energię E, a mnie chodzi o konkretny wzór na wyliczenie wagi w i-tym neuronie warstwy ukrytej, tylko tyle chcę.;"
"mam książkę Osowskiego  ""Sieci neuronowe  w ujęciu algorytmicznym"", ale to kompletna żenada. Pełno tam wzorów do każdej sieci na energię E, a mnie chodzi o konkretny wzór na wyliczenie wagi w i-tym neuronie warstwy ukrytej, tylko tyle chcę. Wydaje mi się, że książka którą ja podałem jest kontynuacją tej co ty podałeś... Jeśli tak nie powinna się znacznie różnić! W związku z powyższym pytanie: co znaczy ""do każdej sieci na energię E""? czy wiesz czym jest np. błąd kwadratowy? (zdaje się, że Osowski właśnie oznacza go przez E!) Po drugie czy wiesz co to jest pochodna i jakie są jej właściwości? Po trzecie: w dalszym ciągu nie wiem, o jaką sieć Ci chodzi Po czwarte: kompletną żenadą to jest gdy mając książkę ze wzorami pytasz się o wzory O_o Po piąte: zdaje się, że już Ci napisałem jak wylicza się wagę - dodam może jeszcze tylko, że w większości typu sieciach wstępny dobór wag przyjmuje się losowo (np. z zakresu (-1,1)) Pozdrawiam ale tak przy okazji pozwolę sobie jeszcze dodać, że SSN bazują na procesie zachodzącym w mózgu człowieka natomiast chyba jeszcze nikt nie dowiódł naukowo, że mądrzejsi częściej wygrywają w dużego lotka (ale chyba można dowieść, że większość mądrzejszych w niego nie gra :P) Pozdro!;"
"Zdaje się, że już Ci wszystko napisałem - nie wiem co jeszcze mogę dodać O_o. z uwagi na fakt, że sieci neuronowe opierają się głównie na nieliniowych funkcjach aktywacji nie można dobrać wag w sposób liniowy (rozwiązując prosty układ równań)... dlatego nie ma czegoś takiego jak wzór na optymalne wartości wag!!! Jedyne co da się zrobić to wyznaczyć wagi np. w sposób losowy i je zmieniać (douczać) aż  błąd funkcji celu będzie jak najmniejszy (osiągnie się minimum funkcji celu - lokalne bądź najlepiej globalne)... co jeszcze mam Ci powiedzieć?!? jak tego nie rozumiesz to może w ogóle sobie odpóść bo chodzenie na skróty (typu forum) nie jest rozwiązaniem - trzeba zrozumieć podstawy, a jak nie rozumiesz samej ideii precesu zachodzącego w SSN to czego bym nie napisał to i tak dla Ciebie SSN pozostanie ""czarną skrzynką"" do której wrzuca się jakieś dane a sieć wypluwa odpowedź! żeby zaprogramować najprostrzą sieć należy przeanalizować cały proces od początku do końca (i najlepiej przeczytać uważnie całą książkę a jak nie pomoże to jeszcze raz i tak do skutku!) Ja sam niektóre rozdziały czytałem po 10 razy i więcej... Wbrew pozorom cały ten proces jest banalnie prosty - trzeba to tylko zrozumieć :). P.S. a jeśli chodzi o te douczanie to polecam sięgnąć do e rozdziału książki którą posiadasz tj. ""sieci neuronowe w ujęciu algorytmicznym"" - tam masz aż nadto wzorów! Pozdrawiam!;"
"Szybki, wystarczyło potwierdzić wypowiedź Deti... Szanowny kolega w dalszym ciągu nie rozumie podstaw :( a co gorsza nie potrafi precyzować pytań :/. Powiem szczerze, że trochę się gubię czytając jego odpowiedzi... Najgorsze jest to, że kolega nie potrafi lub nie chce czytać ze zrozumieniem :( natomiast najbardziej boli, że wszystko chce dostać na tacy - praktycznie bez własnego zaangażowania... Nie jestem matematykiem (ani informatykiem) ale jeśli chodzi o Twoją wypowiedź to niezabardzo mi się podoba wypowiedź odnośnie czystej matematyki (lub po prostu źle ją zrozumiałem)... Sieci neuronowe nigdy nie zastąpią konwencjonalnej matematyki i polegną w najprostrzych algorytmach (tam gdzie liczy się dokładność obliczeń). Nie wiem jakie Ty robiłeś badania ale zaletą sieci jest to, że potrafiają uogólniać pewne procesy a co najważniejsze ich wyniki często są bardzo bliskie rozwiązaniu. Jednak bardzo rzadko będzie to 100% dokładność! Dla przykładu Tadeusiewicz podaje prosty przykład z którym sieć sobie nie poradzi: ""Ale jesli podac sieci serie liczb całkowitych i zazadac, zeby siec odgadła, czy nastepna liczba jest liczba pierwsza to ona sobie z tym nie poradzi. Chocby uczyc siec na okragło to ona nigdy nie na nauczy sie rozwiazywac tego typu problemów"". Tak samo jest z najprostrzym dodawaniem czy mnożeniem - wyniki sieci mogą być bardzo bliskie wyniku ale praktycznie nigdy nie będzie to 100% dokładność (chyba, że dla pojedyńczych równań). Jeśli chodzi o naukę sieci to było już chyba 5 razy mówione, że wstępny wybór jest losowy natomiast później uczy się sieć iteracjami - przez minimalizację funkcji błędu!!! I teraz chciałbym zacytować to co Ty Szybki zacytowałeś tylko w innym kontekście: jak wszystkie wagi dobierane są na wstępie losowo, TO JAKIM CUDEM neurony ""będą dawały takie same wartości na wyjściach""?!? ZACZNIJ CZYTAĆ CZŁOWIEKU ZE ZROZUMIENIEM!!! i zajżyj w końcu do książki a nie wszystkie informacje ściągasz z netu - byle szybciej... Looknij na obrazek jakie procesy zachodzą w sieci a może w końcu dojdzie do Ciebie co tam w środku się dzieje... Szybki pytałeś się, czy on potrafi rozwiązywac równania rózniczkowe i wie co to minimum lokalne - od początku mu proponuję żęby policzył pochodną to może dowie się w SPACJA końcu czym jest te tajemnicze ""(ti-yi)"" o które się pyta ale jak on chce wszystko na tacy to niech sobie jeszcze trochę poczeka... Analizując powyższe - nie, on nie umie rozwiązywać równań różniczkowych! Męczą mnie tacy ludzie, którzy potrafią tylko brać, ale od siebie nic nie wnoszą!!! Natomiast jeśli chodzi o ""gotowy wzór"" na wagi to bym tu polemizował (tak na boku ofc). W sumie wagi w sieci typu RBF można obliczyć rozwiązując układ równań tylko tam problem jest z doborem parametrów i centrów (odpowiedników wag w neuronach) ale... tu też nie jest tak łatwo! Pozdrawiam! Oczywiście chodziło mi o ten cytat:  A jeśli chodzi o bias (polaryzację) to służy ona do tego, że jak by wszystkie neurony dały wartość = 0, to żeby sieć mimo wszystko coś ""wypluła"" (w modelach ekonometrycznych tłumaczy się to mniej więcej tak, że jak wszystkie zmienne (w uproszczeniu odpowiedniki neuronów) dadzą wartość 0 to wynik = właśnie ten  bias (beta)) Dla przykładu gdy staramy się odgadnąć jaki wzrost będzie miał dany osobnik w zależności od zmiennych objaśniających, to gdy wszystkie zmienne przyjmą zero to należy się spodziewać, że ta osoba będzie wzrostu równym temu parametrowi wolnemu (biasowi/becie);"
"Kowal Ja jestem chemikiem nie matematykiem więc dla mnie np. dziwne jest gdy kumpel matematyk wziął i na układach równań wyliczał współczynniki stechiometryczne reakcji buahahaha byłem w szoku jak mi to pokazał ale tak juz jest każdy ma swoje zboczenie ja bym pewnie w życiu na to nie wpadł bo mam uzgadnianie stechimetrii reakcji wpojone od lat i wtedy działam jak automat I chyba znów nie precyzyjnie się wyraziłem z tą wyższością nad czystą matematyką chodziło mi własnie o to że taka sieć bez problemu potrafi rozwiązywac wiele problemów logicznych nad którymi zwykłe algorytmy wysiadają albo są cholernie skomplikowane. Oczywiście że siec neuronową trudno przyrównywac do królowej nauk, jest to jakby osobna dziedzina nauki chyba już można tak mówić. A i żeby niebyło że sieci neuronowe to nie są skomplikowane bo jak napisałem wczesniej kwintesencją uczenia sieci jest poznanie co ta sieć się nauczyła, jako przykład podam (już nie pamiętam gdzie to przeczytałem) w wojsku uczono sieć rozpoznawać czołgi nieprzyjaciela na zdjeciach satelitarnych, po jakiś czasie okazało się że sieć daje jakies bzdurne odpowiedzi, więc szukano gdzie jest bład i co by tu zrobić okazało się że sieć nauczyła się rozpoznawać ale to czy zdjęcie robiono w nocy czy w dzień. Myslę że to dobra pzrestroga dla ludzi którzy stykają się po raz pierwszy z sieciami neuronowymi, zaczynaja ją nazywac sztuczną inteligencją i myślą że jest to panaceum na wszytskie problemy jakie człowiek potrafi sobie stworzyc. A i bardzo dobrze wytłumaczyłeś ten bias jak teraz przeczytałem co ja napisałem o biasie to wcale nic mądrego. Otóż to! Gdyby w moim przykładzie okazało się że sieci nie można nauczyć tych przykładów np. po 1000 iterakcjach to można przypuszczac że nigdy się nie nauczy więc bias by tu mógł pomóc, oczywiście bias też nie jest lekarstwem na wszystko. A co kolegi maszynaz Podtrzymuje wcześniejsze zdanie, po co rzuciłeś się na warstwy ukryte jesli nie rozumiesz pojedynczego neuronu, i nie korzystaj z apletów jawa do symulacji sieci neuronowych bo nic z nich nie zrozumiesz i tylko się zniechęcisz. Pisałeś że masz Osowskiego, jak dlamnie to durna książka bo to nie jest książka akademicka, napisana jest po łebkach i bardzo skomplikowanie, ja gdyby mój promotor nie podesłał pare artykułów po angielsku nigdy bym nie zrozumiał o co w tym biega. jest jeszcze jedna książka właśnie chyba Tadeusiewicza ale jakoś nie mogę sobie przypomnieć ale też gość pisze jakies kosmosy, w ogóle wydaje mi się że w Polsce nic z literatury nie można polecić cóż może w SPACJA końcu trafi się ktoś i przetłumaczy jakiś zagraniczny podręcznik bo blado to widzę zresztą nie tylko w tej dziedzinie, jakby nie podręcznik Oreara to nigdy bym nie skumał pare rzeczy z fizyki. A sorka za oftopa bo troche mnie poniosło.;"
"hehehe Szybki - chemik Deti - elektryk a ja - finansista a gdzie informatycy :D - w końcu to oni głównie powinni być zainteresowani sztuczną inteligencją (pomijając fakt, że to forum programistyczne :p) W dodatku wszystkiego sam się nauczyłem własnie z polskich książek (głównie Osowskiego :P) U mnie w szkole nawet specjaliści od ekonometrii czy informatyki nie potrafili mi pomóc w najprostrzych rzeczach związanych z SSN dlatego do wszystkiego sam dochodziłem! Piszę to, żeby ponownie zmotywować kolegę do myślenia - to nie boli a czasem się przydaje :). Natomiast wracając do książek to tu bym troszkę polemizował. Fakt, że np. podręczniki amerykańskie są pisane jak dla małych dzieci (w jakimś podręczniki do matematyki finansowej autor w pierwszych dwóch rozdziałach tłumaczył czym jest dodawanie, mnożenie O_o i inne banały typu co to jest licza rzeczywista...) Takie podejście rzeczywiście mogłoby bardzo pomóc w nauce bo przypomina pewne podstawy (chociaż jest pewna granica...), jednak sieci neuronowe to wiedza już bardzo specjalistyczna - trudno wymagać od autorów, żeby zajmowali się tłumaczeniem czym jest np. pochodna (o tabliczce mnożenie nie wspomnę :D), gdy piszą głównie dla studentów 4 i 5 roku studiów (w dodatku kierunków ścisłych!). Takie podejście wymuszałoby na nich pisanie dwa razy grubszych podręczników :/. Zgodzę się jednak z tym, że polska literatura w tym temacie jest bardzo trudna, szczególnie, że każdy z autorów inaczej zapisuje te same wzory (używa innych oznaczeń itp). Przykładowo Osowski na błąd używa litery E a Tadeusiewicz Q - i tak praktycznie wszędzie - co bardzo utrudnia naukę! Jednak wszystko jest możliwe :D Natomiast wracając do biasa to jeszcze dwa słowa: jego celem jest tak jakby wygładzenie wyników - bo nie wsyzstko jest zależne od zmiennych, które sobie wybierzemy. Bias nie jest niezbędny i nie zawsze pomaga ale najczęściej się go używa :). Jego wartość rzeczywiści jest jeden ale pomnożone przez jakąś wyuczoną wagę tzn. w rzeczywistości może on przyjmować różne wartości (z dowolnego zakresu) - czasami sieć wyznaczy wagę przy biasie 0.7 a czasami -0.3 lub 1.2 i wówczas bias będzie równy właśnie tej wadze (bo 1 przemnożone przez cokolwie = cokolwik -> dla niewtajemniczonych :P) Pozdrawiam :);"
"Zgadzam się ze ""szczawik"" - w C# najbardziej brakuje możliwości zbudowania natywnego .EXE zamiast fake .NET .exe. Natomiast nie rozumiem czym jest ""borlandowy VCL"" i jak to ma się do języka? ... czym jest tenże VCL - przecież to tylko integracja klasy z IDE (czy ja to dobrze rozumiem). No bo OOP w C# i Delphi jest prawie taka sama. Co do tematu: ta cała TOP lista popularności to oczywiście wielka nieprawda - zbudowana na zasadzie błędnej interpretacji wyszukań w google. W ogóle nauka języka w szkole / uczelni nie powinna być brana pod uwagę. Wystarczy się rozejrzeć po firmach: która zatrudnia programistów C? (na pewno jest ich duuużo mniej niż JAVA czy .NET lub PHP). Jeśli chodzi o przyszłość (moim zdaniem):   JAVA jest i będzie liderem jeśli chodzi o oprogramowanie na urządzenia mobilne, nie prędko inny język wyprze JAVA`e choćby z komórek.   C i języki niskiego poziomu zostaną zepchnięte z programowania aplikacji na sterowniki, kontrolery itp. rzeczy, gdyż nie będzie sensu ich używać w programowaniu aplikacji.   .NET powoli będzie wypierał PHP na rzecz ASP.NET, a język C# będzie TOP językiem w aplikacjach pod Windows wypierając inne języki jak C++ oraz Delphi, które już dostają zadyszki.   Myślę, że php + mysql przetrwa (kwestie finansowe), jednak w dużych systemach komercyjnych .NET w połączeniu z MS SQL Server 2008 będzie niedoścignione. ... bo nie ma lepszego narzędzia IDE jak Visual Studio 2008  [green];"
"Pogrubiony kluczowy fragment. W USA jedną z przyczyn stopniowego grzęźnięcia liberalnego systemu ubezpieczeń zdrowotnych (poza brakiem miliarda regulacji prawnych, które jednak byłyby wbrew liberalnej wolności) był fakt, że po prostu ubezpieczało się zbyt mało ludzi. Jaka miałaby być gwarancja, że tu będzie ich więcej? Oczywiście żadna. Żeby ubezpieczycielowi się opłacało - trzeba było podbijać ceny. Ale drożej = stać jeszcze mniej. I błędne koło się zamyka. W samochodach sytuacja jest inna, bo inna jest świadomość ludzi, wypadki są częste, ubezpieczenie mieć trzeba. Na zdrowie - nie trzeba.  To był tylko przykład jak bardzo oderwane od rzeczywistości hasła rzuca. Reforma armii, czy sądownictwa, wspomniane przeze mnie są w jego postulatach, wypisane na jego stronie i są kompletnie nierealne do przeprowadzenia z poziomu prezydenta.  Nie wiem jaki związek ma powstanie Empire State Building z liberalizmem - jakbyś historii nieco znał, to byś wiedział, że jeszcze zanim go wybudowano, w 1929 roku USA popadło w katastrofalny kryzys (Produkcja w USA zmalała o 50%; w 1932 bezrobocie osiągnęło 25%; co czwarty farmer stracił ziemię na skutek zadłużenia. - wiki). Jeśli liberalizm był taki wspaniały, to czemu padł? Ludzie mieli się stawać mądrzejsi, a co wyszło - 25% bezrobocia. No to faktycznie mądrość ich ogarnęła. Żeby było śmieszniej, to akurat właśnie po tzw. New Deal przypada rozkwit śmiałych projektów w USA, jak przykładowo most Golden Gate. Akurat budownictwo ma się nijak do ustroju. W przyczynach kryzysu, poza tym, o czym już pisałem, upatruję jeszcze jedną rzecz - chciwość. Ludzie mądrzy stawali się ""mądrzejsi"", stawali się kombinatorami. Ich bogaceniu nie było granic. Niestety jeśli pieniądze są gromadzone i nie krążą, to gospodarka pada. Ale to tylko jedna z wielu przyczyn.  Gdyby tych nierobów i biedaków było mało, to by nie było problemu. Przecież nie mieliby wtedy siły, żeby się przebić. Liberalizm w swojej wspaniałości powinien przecież sprawiać, że ludzie stają się mądrzejsi, dążą do bycia mądrymi, bo to się opłaca, więc nie powinno być żadnych kryzysów, protestów, ani niczego - czyż nie? Liberalizm powinien trwać wiecznie jako ustruj doskonały zgodnie z tym co piszecie. Ale jednak tak nie było - bo się okazało, że system się nie sprawdził, zakrztusił się sam sobą. Tylko jak widać ludzie nie wyciągają żadnych wniosków z historii.  Jak wyżej - przecież głupich być nie powinno? Skąd się wzięli? Czyżby liberalizm czegoś nie przewidział? Przecież mieli zmądrzeć... Ale powiem tak: zapewne to kiedyś nastąpi, bo żaden system nie jest idealny i ten też wcześniej, czy później padnie - to oczywiste. Może zastąpi go liberalizm, ale tak jak poprzednio upadnie on sam - bo w liberaliźmie obywatele stopniowo sami sobie krzywdę robią.  Szkoda, że umiejętność czytania ze zrozumieniem stopniowo wymiera. Gdybyś przeczytał uważnie moją wypowiedź zauważyłbyś, że założyłem sytuację w której dochodzi do oszustwa. Świat nie jest taki piękny, że możesz się umówić lub nie - jest trzeci przypadek. Taki brak myślenia abstrakcyjnego i analizowania różnych scenariuszy jest jedną z przyczyn sypania się liberalizmu będącego w użyciu.  Co miałeś z historii w szkole? Albo może jeszcze do tego etapu nie doszliście? Kojarzysz Bolesława Krzywoustego, jego testament, który spowodował rozbicie dzielnicowe Polski? Wszytko jest w monarchii ""super"" (nie licząc możliwości honorowania przywilejami określonych grup w zamian za pieniądze - przywileje szlacheckie - także słabość - monarchia jest de facto korupcjogenna), póki król jest silny. Ale jak nie jest lub podejmie jedną głupią decyzję, to jest w stanie uwalić cały kraj. Były też przykłady jak polscy królowie stawali się pionkami, uciekali, okresy bezkrólewia... Liberałowie mają cudowną zdolność do wybiórczego pamiętania historii. Komunizm pamiętają świetnie, ale ile razy zawodził system monarchii - to już nie. Teraz przynajmniej prezydent sam państwa nie rozwali - jeden człowiek nie jest w stanie jedną decyzją zniszczyć kraju. A już ten tekst na koniec z inteligencją króla to kwintesencja bezmyślności. Skąd to wiesz, że on inteligentny będzie?! Ilu głupich w historii Polski było?! Tylko żeby to wiedzieć to jeszcze historię Polski trzeba znać.  Cała demagogia opiera się na ""myślę"", ""wydaje mi się"" - mało przekonywujące - to raz. Dwa - 1 000 $? I tak za dużo. Ile osób byłoby na to stać? A teraz NFZ przyszyje.  Dowcip miesiąca. Jako wytwórca produktu/usługi z pewnością będziesz wysoce zainteresowany chwalić się jego wadami :-D  Czyli? Ciekawe teorie, bo jakoś jak idę do sklepu kupić mleko, to ja ustalam zasady, że potrzebuję mleko, a państwo na to leje gęstym sikiem :-D Mogę sobie równie dobrze zamiast mleka kupić piwo - państwo ma to nadal w równie głębokim poważaniu, co najwyżej nie będę miał mleka.;"
"1.Mam TLabel zapełnione dość dużą ilością tekstu chce napisac cos co zastąpi daną fraze na coś innego np jesli program znajdzie ciąg znaków tytul to niech pobierze ciąg znakow az do tytulend i skasuje z całego ciąu znakow wszystko od tytul do tytulend włącznie 2.To czy podczas trwania programu mogę dodać bądź skopiować zawarty w nim ""obiekt"" (komponent delphi) jako drugi niezalezny od pierwszego komponent? dajmy na to ze mam Label1 i podczas programu i chce aby program utworzyl na formie dajmy na to Label'e z numerami od 2-100 i kazdemu przypisal co innego do parametru Caption? Jeśli się do to w jaki sposob;"
"Heh, ja z Fido juz kawal czasu przegadalem. Jest raczej taki sobie. Zapytaj go np. ""Kto jest moim ojcem"", to zacznie nawijac o swoim. Poza tym on jest robiony (prawdopodobnie) na zasadzie - wyszukaj jakies slowa i dopasuj jedno z przygotowanych poprzednio wypowiedzi. a jesli chodzi o sieci neuronowe, to zeczywiscie to mogloby byc jakies rozwiazanie. Tylko nie wiem, czy taka siec nie bylaby troche za duza. Troche jednak slow w jezyku polskim mamy. Poza tym ja osobiscie nie za bardzo wiem jak moznaby skutecznie uzyc sieci to rozwiazania tego problemu. Moze przeszloby z przepuszczaniem poszczegolnych slow i na podstawie wyniku ich odpowiednie klasyfikowanie, sortowanie itp. ale z calymi zdaniami chyba nie pojdzie. Nie sadze, by dalo sie zrobic tak, ze puszczam na siec zdanie, a wynikiem jest odpowiedz, ale rzeczywiscie moznaby uzyc sieci zamiast wspomnianego rachunku prawdopodobienstwa. Tylko ze to wymagaloby niezwykle dlugiego uczenia  :-/;"
"Kryptografia, automaty komorkowe, sieci neuronowe - ciekawe tematy. Ale... chcesz byc magistrem, a nie wiesz o czym napisac? Zeby napisac prace trzeba znac sie na jakims konkretnym zagadnieniu, a Ty pytasz o temat? Magister powinien byc magistrem, a nie czlowiekiem z papierem. No chyba, ze sie dopiero uczysz :P Zle sie dzieje...;"
"optymalizacja zapytan w relacyjnych bazach danych obiektowe bazy danych / GIS mapowanie obiektowo relacyjne automatyczne zarzadzanie pamiecia data/text mining systemy wieloagentowe Jakby dobrze poszukac to i na doktorat z tych tematow by sie cos znalazlo. ;) Sieci neuronowe i rozpoznawanie obrazow sa moim zdaniem juz oklepane.... Co trzeci student u nas cos z tego robi (no fakt, Zaklad Grafiki robi dobry marketing).;"
sieci neuronowe lub język wysokiego poziomu;
"ja proponuje zagadnienia sztucznej inteligencji: sieci neuronowe, algorytmy genetyczne, zbiory rozmyte <- a najlepiej polaczenie tych zagadnien w jakims temacie. np. inzynierii, zalezy co studiujesz;"
"Nie rozpatrywałem tego z punktu widzenia męskiego ego (ja) (Freud - ""Wstęp do psychoanalizy"" - polecam). Kobiety szukają więzi emocjonalnych, podczas gdy facetom wystarczy rozmawianie o ""rzeczach"". Być może dlatego, nie pociąga je programowanie w takim stopniu jak nas. Komputer nie przytuli, nie porozmawia itp (widzieliście kiedyś człowieka, który rozmawia z kompem w języku programowania? - ja tak, zdrowo szurnięty był). Może jest to uwarunkowane neurologicznie. Wiadomo, że nasze i ich synapsy tworzą nieco zróżnicowane sieci neuronowe (nie mylić z tymi programowymi). Z neurobiologicznego punktu widzenia konbiety są ukierunkowane na zupełnie inne odczuwanie przyjemności niż my.;"
"Tak. Znajdź kilkaset milionów dolarów na pensje dla speców od sztucznej inteligencji i około 10 lat wolnego czasu. Jak już jakieś AI zrobią, to przynajmniej będzie cię wyręczać w myśleniu, bo tobie to idzie średnio. :P Na CAŁYM forum była już masa tematów dotyczących AI (polecam dział #6). Wypowiadali się wszyscy najlepsi z tego forum, niektóre z zamieszczonych odpowiedzi na tego typu pytania z trudem idzie zrozumieć (sieci neuronowe itp.). Ostateczny wniosek brzmi tak: wszyscy którzy tu są, razem wzięci, nie zrobiliby czegoś, co można by nazwać chćby inteligencją szczątkową (nie jakiś dobrze zrobiony bot na warunkach, tylko inteligencja). Oczywiście zwykłego bota warunkowego może ci się uda zrobić (o tymteż dużo było), ale to też nie takie łatwe.;"
"Ale w którym momencie dyskusji jest o tym mowa?  Nie założę się i nie dam sobie nic uciąć, ale jestem prawie przekonany że z TF możesz też zaawansowane modele językowe tworzyć. Nie mówiąc o wykorzystaniu dostępnych freeware. EDIT: Siedziałem jedynie nad sieciami neuronowymi dla time series, stąd brak wiedzy o modelach językowych w Tensor Flow. Ale wg. mojej najlepszej wiedzy można je budować;"
"Mam taki pomysł na wytłumaczenie czym jest uczenie maszynowe: Wyobraź sobie, że istnieje czarna skrzynka, w której znajdują się różne algorytmy, które potrafią rozwiązać wiele problemów. Uczenie maszynowe to metoda znajdowania tych algorytmów, które radzą sobie z zadaniami, lecz bez możliwości zaglądania do wnętrza tej skrzynki. W związku z tym nie do końca wiemy, jak te algorytmy działają w środku, nawet gdy je odkryjemy. Macie lepsze?;"
"Po kolei - chcesz wytłumaczyć komuś, czym jest AI, czy czym jest uczenie maszynowe?  Uczenie maszynowe to sposób dobierania parametrów do algorytmu (nawet jak jest to algorytm do wybierania algorytmów), a nie sposób dobierania algorytmów.;"
"To chyba jak wszędzie. Gównianego HRa AI wygryzie. Dobrego HRa nie zastąpi. Zamykam wątek, temat z czarnej listy;"
"Hej zastanawiam się nad wyborem kierunku studiów i myślałem o programowaniu ale z tego co czytam do 10 lat  AI  zastąpi programistę i nie wiem czy warto. Moje pytanie jest poważne bo jeden z najlepszych programistów na świecie John Carmack założył startup i twierdzi, że w 10 lat stworzy AGI które zastąpi osoby pracujące przy komputerze https://www.insiderintelligence.com/content/startup-keen-technologies-raises-20m-advance-controversial-agi;"
"Dlatego ja idę krok do przodu. Czekam, aż różne AI zastąpią programistów i wtedy ja stworzę AI, które zastąpi tamte AI.;"
"A tak serio to nie jest do końca prawda że ""AI zastąpi programistów"". Bliżej prawdy jest ""Ludzie którzy bardzo dobrze używają AI, zastąpią programistów"".;"
Jeszcze z 5-6 lat wtedy AI stworzy taki AI który zastąpi aktualny i programistów;
"Ja stawiam, że jest szansa że AI, w pierwszej kolejności,  zastąpi koderów klepiących kod, ale programiści którzy potrafią pogadać z klientem, zebrać dobrze wymagania i zaprojektować co ma być zrobione, będą przez dłuższy czas bezpieczni, ale będzie się od nich wymagało umiejętności analityka biznesowego/testera/PM a kodera w ostatniej kolejności - taki one-man orchiestra. No a najważniejszą umiejętnością będzie dogadanie się z AI w zakresie przekazania co ma kodować i jak testować.;"
"AI nigdy nie zastąpi czynnika ludzkiego. Kod tak, wiele rzeczy będzie można wygenerować. umiejętności komunikacji, zarządzania, rozmów, szerokopojętych skilli miękkich nie.;"
"Ktoś mi odpisał żeby iść na informatykę i programistę. Rozumie, że informatyk to ktoś taki bardziej co wymyśla ulepsza algorytmy, no ale nawet tutaj AI będzie lepsze. Nie dawno czytałem że AI ulepszyło algorytm mnożenia macierzy więc kluczowy dla swojego działania. Więc nie tylko klepaczy zastąpi ale tych od myślenia algorytmicznego również. https://venturebeat.com/ai/deepmind-unveils-first-ai-to-discover-faster-matrix-multiplication-algorithms/;"
A kto zastąpi skram majstra?;
"To są dziwne pomysły, że AI zastąpi programistów, ale oprogramowanie będzie dalej wyglądało podobnie jak dzisiaj i użytkownicy będą klykali w kąkutry. ;) Przecież dla systemów w firmach używanych przez ich pracowników to AI zastąpi systemy razem z pracownikami. Co do systemów używanych przez klientów firm, których jednak zastąpić nie można do końca, bo ktoś musi płacić, to czy nie wolelibyście jako klient też mieć asystenta AI, któremu każecie głosowo poszukać produktu lub usługi o jakichś własnościach i ładnie zaprezentować do wyboru i przedyskutować wady i zalety? No właśnie, czyli prawdopodobnie to sprowadza się do tego samego - oprogramowanie ""biznesowe"", jakie znamy dzisiaj, nie będzie miało racji bytu, bo AI będą się dogadywać między sobą po swojemu. To wszystko oczywiście przy założeniu, że to AI będzie coś do końca rozumiało, a nie tylko ""papugowało"" mniej lub bardziej powierzchownie.;"
"Cześć! Kilka miesięcy temu zainteresowałem się programowaniem i innymi nowymi technologiami. Miało to związek ze stanowiskiem, jakie objąłem w firmie, a mianowicie zostałem specjalistą ds. narzędzi CAT i nowoczesnych technologii w jednym z biur tłumaczeń. Na stanowisko to zostałem wybrany przez szefa ze względu na mój „analityczny umysł”. Po czasie zacząłem powoli uczyć się Pythona, choć nadal próbuję czasami też innych języków (na ten moment wszystko jest takie ciekawe :)).  Następnie podjąłem decyzję, aby nie tylko poświęcać swój wolny czas na programowanie, ale żeby stało się to również moją pracą. Jako, że jestem już po magisterce (filologia rosyjska), zdecydowałem się na studia podyplomowe na następującym kierunku - https://www.merito.pl/chorzow/studia-i-szkolenia/studia-podyplomowe/kierunki/programista-python-developer Zapisałem się i mam już informację o przyjęciu na studia, które rozpocznę w październiku tego roku. Szkołom programowania oraz innym oferowanym kursom raczej nie ufam. Programowanie stało się moim nowym hobby i to gównie na nim spędzam swój wolny czas. Odniosłem też swój pierwszy niewielki sukces - napisałem prosty skrypt w Pythonie służący do obliczania stawki za postedycję tłumaczenia maszynowego zgodnie ze wzorem, który wykorzystywany jest przez innych pracowników w mojej firmie każdego dnia. Szef zapłacił mi nawet za ten skrypt, ponieważ napisałem go w swoim czasie wolnym i nie prosił mnie o to, a jednak pozwolił na automatyzację pracy. Postanowiłem jednak odezwać się na waszym forum, ponieważ mimo wszystko mam czasami obawy, czy uda mi się w ogóle dostać do IT. Jedną z moich obaw jest fakt, że na praktyki, staże oraz stanowiska juniorskie jest po kilkadziesiąt/kilkaset chętnych osób. Kolejna kwestia to rozwój sztucznej inteligencji. Dużo mówi się, że zastąpi lub odbierze ona niektóre obowiązki programistom. Staram się podchodzić do tego typu newsów z przymrużeniem oka, ponieważ rozumiem, że portale z informacjami właśnie w ten sposób działają, czyli stosują krzykliwe nagłówki i inne clickbaity. Wśród artykułów w internecie przewija się również ostatnio temat zwolnień w branży IT. Na dodatek moja mama przesyła mi tego typu artykuły, ponieważ jak twierdzi „chce, żebym był doinformowany”... Na chwilę obecną nie mam za bardzo z kim porozmawiać z mojego grona znajomych na powyższe tematy, dlatego jestem ciekaw waszych opinii, aby móc również poszerzyć swoje własne spojrzenie. Dzięki!;"
"Mnie zaczyna powoli męczyć ta apokaliptyczna wizja, że chatGPT jest taki cudowny, że zaraz zastąpi programistów a ja nawet nie jestem programistą XD;"
"To, że GPT co najmniej dłuższy czas nie zastąpi programistów to pewne. To, co ewentualnie może nastąpić, to spadek liczby programistów, ze względu na ich drastyczny wzrost wydajności, teoretycznie. Tylko czy nawet w takim przypadku takie rozumowanie ma sens? Przy teoretycznym założeniu, że 1 doświadczony programista z GPT jest w stanie pracować jak setka programistów bez GPT, potencjalny Klient nie będzie oczekiwał takiego samego tempa rozwoju swojego oprogramowania co teraz, tylko będzie korzystał z ze wzrostu wydajności rozbudowując system o masę ficzerów, na które nie było go dotychczas stać (jako że musiałby płacić za 100 dodatkowych programistów). Co więcej, patrzycie na to z pozycji szklanki do połowy pustej - bendom zwalniać. A szklanka do połowy pelna jest taka, że brawo panie senior deweloperze, z chatem GPT staje się Pan firmą stuosobową. Można myśleć o własnych biznesach, lub wdrażaniu oprogramowania tam, gdzie nie było ku temu ekonomicznej możliwości (prywatne osoby). Tak jak 40 lat temu kolor na ekranie to był szał, tak jak 20 lat temu szałem była w ogóle własną strona WWW, tak za lat 10 osobom prywatnym będzie się udostępniać w rozsądnej cenie szybki sklep WWW, pozostawiony na Cloudzie, z automatyzacja CI/CD, oraz podpiętym AI, wciskającym odwiedzającemu, że te garczki pasują mu do wystroju domu. Zamiast gównianego Wordpressa trzymającego sie na trytytkach, zapranego pluginami. A duze korpo będą sprzedawać gadające roboty. Oczywiście teoretyzuję, hiperbolizuję itd., ale mam nadzieję, że przekaz i kierunek jest jasny.;"
"Odpowiedź jest prosta. Ludzie pracują na etacie i robią projekty jakie wymaga pracodawca.Nie ja to kto inny zrobi. Nawet jeśli GPT zastąpi crudowców, to i tak taki człowiek co to tworzył nie musi się bać o pracę.;"
"Hej, chciałbym poznać Wasze opinie na temat nauki programowania nowych technologii tj. widzenie komputerowe (computer vision), uczenie maszynowe (machine learning) czy big data. Czy to jest coś, czego chcielibyście się nauczyć? Co skłoniłoby Was do udziału w kursie? Dlaczego chcielibyście wziąć udział w takim kursie?;"
"Hej, chciałbym poznać Wasze opinie na temat nauki programowania nowych technologii tj. widzenie komputerowe (computer vision), uczenie maszynowe (machine learning) czy big data. Czy to jest coś, czego chcielibyście się nauczyć? Co skłoniłoby Was do udziału w kursie? Dlaczego chcielibyście wziąć udział w takim kursie? Gigantycznym plusem byłoby gdyby to nie był indiański videotutorial, przy czym za brak indiańskości + 8 pkt. a za brak videotutorialowatości + 32 pkt. (Max. liczba pkt. do uzyskania: 96);"
"Poczytaj o RASA framework. Naprawdę fajny framework (do chatbotowania) i ma też voice recognition z tego co pamiętam. Zbiór na 3 części bo mam treningowy, testowy i weryfikacyjny. To w przypadku sieci neuronowych kiedy sprawdzasz metryki podczas uczenia (co którąś tam epokę). Wtedy na treningowym się uczy, na testowym sprawdza podczas uczenia a weryfikacyjny to ten już ostateczny, który daje Ci najwięcej informacji o szeroko pojętej skuteczności modelu. NLP - Natural Language Processing. Żeby program ""rozumiał"" co do niego mówisz. Do realizacji NLP służy wiele narzędzi. Tu przydatne są szczególnie Rekurencyjne Sieci Neuronowe, głównie ze względu na to, że pamiętają ""context"". Algorytmy to na przykład LSTM, GRU, czy bardziej wyrafinowane - BERT, ELMO, RoBERTa itp. Ich implementacje są dostępne np. w Kerasie, ale też w dedykowanym frameworku do NLP - FLAIR. Do dyktowania SMS-ów wystarczy Ci API google. Do tłumaczenia w czasie rzeczywistym cóż... Pewnie trzeba by jakiegoś prostego OCR-a napisać (ogarnij przykład zbioru MNIST, tam są cyfry 0-9 kategoryzowane - skanowane). Jeśli chodzi o podjęcie decyzji, chodziło o przeniesienie się z działu wdrożeń do działu Core. Po 6 latach w jednym miejscu człowiek czasem ma ochotę na zmianę. No i chciałem nauczyć się czegoś o AI/ML, a że pojawiła się taka możliwość (ja coś dam wiedzy na pewne tematy od siebie, oni mi dadzą możliwość nauczenia się). To skorzystałem. Generalnie nie licz na ogromny odzew - mało jest specjalistów od ML w Polsce. Ja sam siedzę w tym od września zeszłego roku dopiero, ale odnalazłem się ideolo. Z moich propozycji co mógłbyś zrobić żeby ogarnąć temat to:  Napisz prostą sieć od podstaw (bez żadnego frameworka typu tensorflow/keras). Naprawdę dużo łatwiej Ci będzie. Napisz rozpoznawanie obrazków (zbiór danych MNIST w kerasie). Tu też jest do tego tutorial Następnie możesz poczytać (jeśli jeszcze nie ogarniesz do końca) co to jest funkcja aktywacji, optimizer. To tak w kontekście Sieci neuronowych No a dalej to już możesz iść albo w sieci CNN (to głównie do rozpoznawania obrazu albo np spektrum dźwięku - np do rozpoznawania mowy) albo RNN (tu wspomniane wcześniej rozpoznawanie tekstu i kontekstu).  No i generalnie bierz się i rób. Wymyśl sobie projekt i konsekwentnie realizuj :);"
"Dzięki. Mam ogólnie jeden przedmiot związany z uczeniem maszynowym, tylko jest on prowadzony, mówiąc delikatnie, w specyficzny sposób. Nie umniejszając roli wykładowców, po prosku jest położony największy nacisk na podstawy teoretyczne, natomiast implementacja wg zasady ,,znasz teorię to implemementuj"". Korzystam obecnie również z jednego z kursów na udemy bodajże się nazywa Machine Learning from A to Z czy jakoś tak. Dosyć dobrze do mnie trafia, no i lubię jak ktoś używa pewnego słownictwa w oryginale, a nie na siłę próbuje niektóre skróty i zwroty tłumaczyć na polski. Ogólnie to dotychczas moim głównym obiektem nauki była Java. Teraz trochę spodobało mi się grzebanie w web-devie. Ale to uczenie maszynowe jest fajne, bo jak sam stwierdziłeś mało jest osób u nas które się tym zajmują. A jeśli chodzi o javę to niezły poziom trzeba reprezentować, żeby się wybić zwłaszcza wśród zalewie projektów typu ,,lista do zrobienia"", ,,kalkulator"". Albo jakiś kopiuj-wklej z bootcampów;"
"samsung, tensorflight, lingaro, daftcode, sektor finansowy, marketing, systemy rekomendacyjne (allegro itp.) i setki innych firm, firemek, spółeczek, korporacji, banków, startupów. Nie wiem za bardzo o co ci chodzi, uczenie maszynowe ma tysiące zastosowań w finansach, image processingu, NLP, naukach społecznych, biostatystyce itp.;"
"somekind jejku jaki z Ciebie niedobry złośnik jest ;) nie stresuj się tak, bo ci żyłka pęknie. Nie wiem jak się cytuje na tym waszym genialnym forum dla programistycznej elyty, ja cytuje jak Pani Bozia przykazała, czyli za pomocą cudzysłowów. W Polskim uzywa się cudzysłowa dolnego(na początku) i górnego(na końcu), w angielskim używa się górnych i ja też taką konwencję przyjąłem. Chyba też powinno się jakoś podać autora cytatu, ale akurat w tej dyskusji zawsze odnosiłem się do posta powyżej mnie, więc stwierdziłem, że to bezsensu. Czy to naprawdę takie istotne? :D Jak na razie widzę z Twojej strony ciągłe argumenty ad hominem pod moim adresem i jakieś zupełnie niepotrzebne przytyki na poziomie gimnazjum. ""Cytowanie w pracach naukowych może być dosłowne (zaznaczone cudzysłowem) lub sparafrazowane (cytuje się dane, fakty, teorie, a nie ich kompozycję słowną – nie ma znaczenia, czy przytoczenie ma formę „ssaki mają cztery kończyny”, czy „ssaki posiadają dwie pary kończyn” – w obu przypadkach sens faktu naukowego pozostaje ten sam)."" Co do oczyszczania danych to wykazujecie się sporą dozą ignorancji i jak to programiści ""wiecie lepiej"" (arogancja typowa dla tego środowiska). Dwa bardzo ważne poddziedziny data science czyli sieci neuronowe i uczenie ze wzmocnieniem nie wymagają praktycznie wcale takiego czegoś jak czyszczenia danych, bo specyfika systemów opartych na tego typu algorytmach jest zupełnie inna. No chyba, że zbudowanie algorytmu ML, który ""wycina"" ze zdjęcia twarz, uważacie za czyszczenie danych. Ale nawet w przypadku ""typowego"" uczenia maszynowego, w stylu ocenienie czy pacjent będzie miał raka czy nie, to czyszczenie danych nie trwa zbyt długo. Co innego umiejętne zebranie danych, wykrywanie wartości odstających, imputowanie wartości zmiennych itp. itd. co wymaga wiedzy statystycznej i też można traktować jako ""przygotowywanie danych"". A i jeszcze jedna kwestia, bo wspominano tutaj o tym nieszczęsnym forbesie i o tym, że data scientist zajął pierwsze miejsce jako najlpeszy zawód 2016 roku( statystyk drugie miejsce). Nie pamiętam, żeby w 2014 gdy software engineer zajął w tym samym rankingu, w tej samej gazecie, pierwsze miejsce, polscy programiści narzekali jaki to forbes jest tendencyjny, przehypowany i niepoważny. Wręcz przeciwnie. Za to teraz jak software engineer spadł na 9 miejsce,a data scientist wszedł na pierwsze, to nagle forbes i jego dość wiarygodny i profesjonalny ranking, staję się ucieleśnieniem głupoty i hype'u. Druga kwestia to to, że jakikolwiek inny ranking na temat perspektyw zawodowych, zarobków i warunków pracy, syytuuje data scientista i statystyków w ścisłej czołówce (top5). Jeśli już wchodzimy na temat stronniczości rankingu forbesa.;"
"Serio uwazasz że 95 w moim tymczasowym loginie gościa, oznacza że mam 22 lata?  ""Jak uzywasz studenckich setow z WEKI""  Zyjemy w 2017 roku, java jest mało popularna do data science. Praktycznie wszystko idzie w R i Pythonie. http://www.kdnuggets.com/polls/2015/r-vs-python.html 2)""Odkrywanie wiedzy z danych"" T. Larose Żyjemy w 2017 roku, przez ostatnie 10 lat od momentu wydania tej książki data science zmieniło się bardziej niż programowanie przez ostatnie 30 lat(pod każdym możliwym względem, od języków programowania, oprogramowania, teorii i przede wszystkim praktcznych zastosowań). Książka nie dotyka takich kluczowych obecnie poddziedzin data science jak sieci neuronowe czy uczenie ze wzmocnieniem, bo w 2007 miały bardzo niewielkie zastosowania. 3)""ktory dla odmiany na prawde pracowal przy projektach ML:"" ad hominem do anonimowego gościa o loginie tymczasowym LSTMDestroyer95. Widzę że już rozłożyłeś mnie na czynniki pierwsze.   http://widgetsandshit.com/teddziuba/2008/05/machine-learning-is-not-as-coo.html   artykuł z 2008 roku, serio? Data science przekształca i rozwija się przez ostatnie 5 lat tak szybko, że wiele publikacji i artykułów z 2012 jest w tej chwili już bezuyżteczna, a Ty podajesz jako jakąś wyrocznie artykuł z roku 2008? ""And since that can't be done with a JUnit test, I have to get all scientific-method on that shit.  Remember in college when you snoozed through advanced statistics because it sucked?  Yeah, me too.  Good thing I kept the book."" pomijam już, że gość jest niepoważny. teoria w data science to podstawa, jak ktoś jej nie lubi, to niech zostanie programistą, w programowaniu nie trzeba się przejmować jakimiś iksami dupiksami (w ogóle komu to potrzebne ? :D);"
Przecież ten gościu twierdzi że sieci neuronowe są odporne na szum.;
"@Czarny Mleczarz:  Jasne, najprostsze sieci neuronowe faktycznie są ciekawe oraz banalne (już nawet licząc tę propagację wsteczną jako łatwą), ale na takich banalnych sieciach raczej specjalnie ciekawych AI nie można zrobić. Albo w każdym razie mi nic w tej chwili nie przychodzi na myśl, w przypadku którym niech ktoś mnie wyprowadzi z błędu, jeśli się mylę :P;"
Zaden. Pierwszego zastąpi AI a drugi wypali się zawodowo;
"@ŁF: a najlepsze jest że jak się zapytałem GPT to mi proponował custom implementacje dekorując Dictonary<TK,TV>. Tak w ramach ""czy AI nas zastąpi?"";"
"Zmień obraz rastrowy na vektorowy jeśli idzie wtedy, możesz dowolnie skalować obraz bez zmiany jego wielkości. Zmniejszając obraz rastrowy(downscaling) to tracisz trochę danych, w końcu miałeś 3x3, a zrobiłeś 2x2 to zgubiłeś 5 pixeli 3x3=9, 2x2=4, 9-4=5, w pewnym momencie będzie niewyraźne. Upscaling to musisz wypełnić brakujące pixele wykorzystując jakieś metody jak uśrednianie czy sieci neuronowe to aproxymacji brakujących pixeli, bo takie proste metody są przeciętne. Wraz ze zmniejszaniem jakości rastrowego obrazu to zawsze musisz się liczyć ze zmniejszeniem ilości szczegółów. Później jeszcze format kompresji też wpływa na utratę jakości, lub nie zależy co zastosujesz. Wiele algorytmów pozwala tak skompresować, że dla ludzkiego oka utracone dane są niezauważalne i dzięki temu mniej ważą.;"
"Ale co się przejmujecie?! Przecież w ciągu 5 lat zniknie zawód programisty, zastąpi nas AI. Brak B2B to pikuś.;"
"Dziękuję za pomoc. Nie wpadłem, żeby zapytać o pomoc AI. Jest w kodzie jeden błąd jest c: TControl a ma być c : TComponent; Widać jeszcze AI nie zastąpi chwilowo człowieka ;);"
"Ale zdajecie sobie sprawę, że na chatgpt się temat nie kończy. Prędzej czy później powstaną wyspecjalizowane modele, które będą potrafiły tworzyć oprogramowanie. Nie wiem czy to kwestia 5 czy 25 lat, ale to się wydarzy  zapewne będzie to ewolucja, ale na pewno znacząco zmieni wygląd branży. Jedyne pytanie jakie jest otwarte to czy w przewidywalnej przyszłości programista będzie kontrolował AI jak operator koparkę czy będzie zupełnie zbędny bo zastąpi go analityk. Moim zdaniem osoby, które tylko klepią taski zostaną zmarginalizowane.;"
"Cały czas podajecie przykłady: ""patrzecie ten chat GPT/gemini/copilot to totalny syf! Toż to generuje kod, który nawet się nie skompiluje, no nigdy nas nie zastąpi hehe"" I wiecie co? Przecież ja się z wami zgadzam, że obecnie to całe AI to niewiele potrafi i bardzo rzadko wypluje coś sensownego Aczkolwiek zapominacie o jednym - kwestia nie tyczy się tego, że obecnie AI jest kiepskie, główny problem to rozwój wykładniczy Powtarzam, widoczny gołym okiem rozwój wykładniczy Jeszcze rok temu można było wrzucać proste kawałki pytań do promptu, nie pamiętało historii między zapytaniami, dzisiaj AI pamięta całą historię konwersacji, może nawiązywać do poprzednich promptów i może sobie zaciągnąć 100k linii kodu... Jeżeli w najbliższych latach nie trafią na jakiś poważny problem, blokadę, przeszkodę do dalszego rozwoju to jest bardziej niż pewne, że to kwestia kilku/kilkunastu lat że AI nas zastąpi. I jasne - łatwiej jest zastąpić tą przysłowiową HR-ówkę czy klepacza excela, ale jednak to w programistów komercyjnych, klepaczów webowych są wymierzone wszystkie działa. Dlaczego? Może dlatego, że mimo wszystko z biznesowego punktu widzenia - klient końcowy nie chce rozmawiać z ""chat-botami"", tak samo nie chce rekrutera ""chat-bota"", tylko realny kontakt z drugą osobą. Natomiast programista to taka osoba, z którą zwykły użytkownik aplikacji nie ma żadnego kontaktu, nawet nie wie o naszym istnieniu. No i jeszcze kwestia kosztów, programiści (może nie w Polsce, ale np ci w stanach) zarabiają gigantyczne pieniądze, które są kosztem dla biznesu. Stąd pomysł na zastąpienie programistów w pierwszej kolejności Obecnie szacuje się, że modele AI to takie ""trzy-letnie dziecko"" mające wiedzę milionów osób z całego świata, za kilka lat dojdą do momentu gdy będzie to ""10-letnie dziecko"" mające wiedzę milionów osób z całego świata, a za kolejne kilkanaście lat będzie miało poziom inteligencji 20-30 letniej dorosłej osoby + wiedza kilkuset milionów ludzi z całego świata Lepiej się módlcie, żeby nie stworzyli komercyjnych komputerów kwantowych... Tylko zastój mocy obliczeniowej i zbliżanie się do granicy możliwości (technologia 3nm) daje nam te kilka/kilkanaście lat luzu...;"
"@CoderOne A Wy dalej traktujecie LLM'y jako osobny byt z niebywałą świadomością albo jakiś przęłom... Ten koncept istnieje co najmniej od lat 60. To jest narzędzie bazujące na danych i nic więcej. Z tym rozwojem też się trochę zagalopowałeś. GPT uczy się również na własnych promptach, które bywają błędne, zatem jest to w pewnym sensie samo napędzająca się spirala. Na prawdę minie jeszcze sporo czasu zanim to narzędzie będzie w stanie zastąpić programistę/ów/cały zespół w przypadku pełnoprawnego projektu (o ile w ogóle). Osobiście uważam, że nie szybciej niż za 10/15 lat. Jedyne co się zmieni to standardy. Umiejętność korzystania z gpt będzie branżowym standardem i zastąpi SO.;"
"@loza_prowizoryczna  Zależy co rozumiesz pod ""wynik interakcji""... Jeżeli wnioski, które może wyciągnąć czytelnik na podstawie takiej dyskusji to generalnie zależy od wielu czynników... Jeżeli takie same modele dostaną te same pytania w takiej samej kolejności to wynik zawsze w 100% będzie konwergentny... Jeżeli zaś masz na myśli sam rozwój jakości modeli, czy też możliwość, że jeden ""przekona"" drugi do swoich racji - no niestety tutaj wynik zawsze będzie obojętny. Modele językowe nie rozwijają się wraz z prowadzonymi dyskusjami. Czy AI da się zatrzymać? - Ponownie - zależy co masz na myśli :) Chociaż w zasadzie w 99.9% przypadków odpowiedź będzie twierdząca :P;"
"Ponownie - wartość dodana może powstać w takim sensie, że nieprzekonany obserwator tej hipotetycznej dyskusji modeli z różną wiedzą na dany temat może uznać część argumentów modelu X za bardziej przekonujące a część modelu Y... W większości realnych przypadków różne modele językowe będą się od początku zgadzały ze sobą na temat faktów - żadnej debaty więc nie będzie. Natomiast w 100% dyskusji między czatami bez ludzkiego weryfikatora, będzie miała obojętny wynik dla aktorów...Każdy będzie upierał się przy swojej wiedzy, nie będąc zdolnym do zmiany przekonań pod wpływem argumentów.;"
"@axelbest: napisał:  Tylko te najtańsze wykonane w technologii z lat 70`tych. Bo te współczesne już takich błędów nie robią. Mam na biurku jakiś pierwszy lepszy ze sklepu. Model CITIZEN SR-135N i tego błędu nie robi. Minęło 50 lat kolego! AI będzie lepiej pisać programy niż 80% użytkowników tego forum już za kilka lat. Kto twierdzi inaczej ten chyba nie bawił się na poważnie narzędziami AI.  Nikt nic nie będzie musiał kontrolować. Lata pracy z ludźmi pokazują, że Ci są dużo bardziej omylni, leniwi, niedokładni niż AI nawet na dzisiejszym poziomie. Nawet GPT potrafi wypluć dużo ładniejszy i pewniejszy kod niż większość juniorów a nawet  obracających się figur geometrycznych (i nie chodzi tylko o sześcian). Tu masz kilka przykładów kodu realizującego zapytanie do zwykłego GPT a nie jakiegoś wyspecjalizowanego narzędzia:  Napisz obracającego się sześcianu z kolorowymi ścianami. Kod napisz w JavaScript używając Canvas.  https://jsfiddle.net/etnLcap0  A teraz niech to będzie dwunastościan pitagorejski: https://jsfiddle.net/Lgcjr8uw/   Punkt drugi wymagał kilku dodatkowych komend ale efektu końcowego i wyplutego kodu sam bym się nie powstydził. Zatem bagatelizowanie AI w programowaniu to dzisiaj już przejaw zwykłej ludzkiej głupoty. Napisałem mały Framework w PHP na własne potrzeby. Od dwóch miesięcy eksperymentując tworzę dokumentacje na potrzeby GPT Chat. Tak by, wklejać ją w prompt. Jest to wyzwanie bo wielkość prompt jest dziś mocno ograniczona. Ograniczyłe się więc do kilku bibliotek: Config,  Database, IOUtils + ERD dwóch tabel. Finalnie w jednym z eksperymentów GPT zwrócił działający kod (póki co nie było bardzo łatwo bo trzeba było go korygować), który pliki CSV po odpowiedniej obróbce danych importuje do bazy danych. Szczerze mówiąc tłumaczenie mu, co ma robić zajęło niewiele więcej czasu niż tłumaczenie statystycznemu programiście a przewagi są następujące:  mogę to robić w środku nocy, wiem, że narzędzie się będzie rozwiajać, kiedyś połknie całą dokumentację mojego framework, pewnie będzie dało się zapodać wejścia do katalogów na dysku i sam będzie mógł przeglądać pliki,  Jasne, że GPT nie zastąpi dziś jeszcze analityka, który rozmowę z klientem przełoży na działający kod na wskazanym serwerze ale to już jest w zasięgu ręki, a tęgie głowy ostro kminią jak zastąpić przemądrzałego programistę, który za godzinę woła minimum 80zł netto na rzecz automatu, z którym możesz gadać i przekazywć mu wytyczne cały dzień a on skasuje Cię za to10$. To jest ekonomia - z tym się nie wygra. Do tego przekonanie o posiadaniu nadprzyrodzonej wiedzy i doskonałości (przez dużą grupę programistów - oczywiście nie wszystkich) + lenistwo, które doprowadziło do tego, że w większości firm zadania są delegowane w postaci ticketów w języku angielskim aż prosi się o to, że aby te tickety realizowało AI. Za kilka lat product-manager nawet nie będzie wiedział czy zleca zadania AI czy fizycznej osobie. Zadanie ""będzie się robiło"" - tak samo jak dzisiaj się robi tylko automatycznie. Niestety dla zdecydowanej większości programistów wyrok już zapadł i pozostaje im już dziś zastanawiać się jak dużo kasy  mogą jeszcze wydusić z obecnej roboty by odłożyć na swoją przyszłość. Potrzebni będą jedynie Ci, którzy zarządzają i tworzą zadania - nieco się wyspecjalizują, kupią nowe narzędzia, powstaną Frameworki wyspecjalizowane do pracy z AI (już powstają). Nikomu nie będzie potrzebne żadne IDE ani nudny programista, który zajmuje miejsce przed monitorem i zużywa prąd żeby świeciło mu 3 x 32 cale ekranu. Tak jak dziś nawet w Intelu i AMD nie do końca wiedzą jak działa ich procesor na najniższym poziomie czyli litografii - bo to nie ma znaczenia. Ważne jest że działa a powszechnie wiadomo, że od lat już tym końcowym etapem projektowania zajmuje się właśnie AI, algorytmy ewolucyjne itp. Również managera w Twojej firmie, guzik będzie interesowało, że kod nie jest ""piękny"" jak ten Twój. Ten z idealnymi wcięciami i z zachowaniem reguł pisania ""zajfajnego kodu"" z wszystkich 5-ciu książek, które czytałeś z wypiekami na twarzy. Także jeśli nie nastąpi jakaś katastrofa poza technologiczna typu totalny światowy Armagedon to jestem pewien, że już dziś ponad połowa siedzących na tym forum za 5 albo 10 lat będzie pracować w innym zawodzie. Tak samo jak masy ""niezastąpionych wówczas księgowych"" w USA w latach 60-tych, których wyparły komputery. Nie wieszczę, że wszyscy zostaną bez pracy ale zawód programisty jaki dziś znamy w najpowszechniejszej postaci można uznać za wymarły już teraz.;"
"Zgadzam się z @4w0rX4t4X nie ma już odwrotu, jedyne co nam pozostaje to zarobić i zainwestować ile się da zanim przyjdzie czas na naszą branże. Nie wierzę że chatGPT w tej dekadzie całkowicie zastąpi ludzi, ale może namieszać w ten sposób że jedna osoba będzie w stanie w 1 dzień zrobić robotę zespołu przez tydzień. Na pocieszenie dodam że poleci też wiele innych zawodów:  Tłumacze, graficy, copywriterzy. Wszelkiego rodzaju doradcy. Wszelkiego rodzaju analitycy. Aktorzy i aktorki.  Co ciekawe zawody in real life jak fryzjer czy budowlaniec nadal powinny się trzymać (to jest dekadę dłużej aż AI wymyśli jak i ich wyautomatyzować). PS. W czasie gdy TY dysktujesz na 4p, Hindusi już masowo korzystają z chatGPT! Już krótce hindusGPT może mieć jak mawiają amerykanie upper hand nad outsource'ingiem do Polski i wtedy się zacznie. Wszystkie JPMorgany i inne molochy zaczną znów outsource'ować do tanich pragramistów uzbrojonych w GPT...;"
Jakim cudem AI ma zastąpić pracowników? Przecież to co wypluje AI trzeba umieć wdrożyć i połączyć z czymś innym żeby to działało. Imo nigdy AI nie zastąpi człowieka. AI to tylko pomocny tool;
"Ten poziom AI przyszedł wcześniej niż zakładałem (ale oczywiście moje wyliczenia były strzałem z d**y, bo się absolutnie na tym nie znam i nie znałem) i będzie podejrzewam tak samo jak z internetem. Internet dał nam ogrom możliwości, dosłownie otworzył nas na cały świat, ale w zamian zostaliśmy zniszczeni. Brzmi to edgy, ale internet rozpierdzielił społeczeństwo w drobny mak. Nie będę się rozwodził szerzej tutaj bo byłby offtop. Uważam jednak, że z AI będzie to samo. Popchnie nas niesamowicie do przodu, inteligentne jednostki z tego skorzystają i będą błogosławić to narzędzie. Nic oczywiście za darmo nie przyjdzie i społeczeństwo zdegenruje się pewnie jeszcze bardziej i zaczną się większe problemy. Czy wszystkich zastąpi AI w robocie? Pewnie jeszcze nie, ale zacznie to powoli się dziać. Ja nigdy nie planowałem programować do końca życia także jestem absolutnie gotowy zmienić branżę jak okażę się za słaby by konkiurować z AI i z programistami lepszymi od siebie. Problem jest taki, że gdzie ci wszyscy ludzie się potem podzieją, bo fizoli też zacznie być nadmiar. Z prozaicznych plusów i minusów - jak AI zacznie nam praktycznie tak łatwo tworzyć gry i filmy jak tworzy teraz Midjourney obrazki to znowu będzie zalew syfu i szukanie perełek będzie JESZCZE trudniejsze. Mi Midjourney urwał suty, ale rozwój poszedł w kierunku nie takim co osobiście bym korzystał i znudziło mi się. Ludzie jednak niezmiernie tworzą te fotorealistyczne ""artworki"" i już w 95% przypadków i tak możesz stwierdzić, że było to zrobione przez AI bo albo ten sam styl cieniowania albo pomysł tak odjechany, że człowiek by tego raczej nie zrobił. Ubolewam, że prawdziwi artyści w końcu wyginą zalani syfem generowanym przez AI przez ludzi bez talentu i bez pomysłu. No ale chociaż będę mógł wygenerować więcej pornoli z aktorkami co już dawno są na emeryturze i w gatunkach w których jeszcze nic nie nakręciły, yay;"
"Pierwszy temat jak najbardziej. Drugi nie zrozumiałe trochę, bo co znaczy nie ogarnia AI, większość na studiach tego nie ogarnia, a sieci neuronowe są tłumaczone głównie w teorii. To musi zrobić coś w czym się dobrze czuje i zaproponować promotorowi, jak nie chce z nim gadać to niech rzuci studia, bo nie rozumiem takiego podejścia.;"
"Cześć, Ostatnio mam dosyć rozmów z biznesem, definiowania user stories i później klepania tego wszystkiego tak, żeby story points się zgadzały. Chciałbym znaleźć jakąś pracę dla prawdziwego programisty, coś w czym nie zastąpi mnie łatwo bootcampowiec i będzie to jakiś zaawansowany software, ale nie dla jakiegoś korpo. Jakiego rodzaju projekty powiniennem szukać i czego się uczyć?;"
"testerzy w niektórych firmach to jedyne osóby, które tak na prawdę wiedzą jak działa system i potrafią z niego w pełni korzystać. tego trzeba się samemu wyuczyć pracując rok czy dwa w danej firmie i kto ma takich ludzi niby zastąpić? programiści którzy proszą testerów żeby im wytłumaczyli gdzie jest button x w zakładce y, a najlepiej gdzie jest zakładka y bo tego też nie wiedzą, a zarabiają dwa razy więcej. AI tez nie zastąpi testerów, bo potrzebna jest żywa osoba, na którą będzie można zwalić winę, że coś nie zostało przetestowane, a weszło na prod;"
"Dużo mówi się o tym że GPT zastąpi pracowników umysłowych, tymczasem roboli już się zastępuje: https://www.bbc.com/news/technology-67163680 Już za kilka lat tego typu pan powita ciebie w stacji kontroli pojazdów:  It's over dla robola!   screenshot-20231023083643.png (750 KB) - ściągnięć: 3;"
"Znam ten argument że jeżeli się społeczeństwo bogaci to i nam również przybywa. Natomiast IMO jest to wpływ drugiej kategori, nie można wyłącznie na to liczyć. Jezeli wszyscy zarabiamy po np. 5000 zl i chleb kosztuje 5zl. To każdego stać na 1000 chlebków. Jeżeli społeczeństwo podniesie efektywnosc o powiedzmy 10% to bedzie zarabiać 5500, gdzie chleb bedzie dalej kosztowac 5zł. To kazdego bedzie stać na 1100 chlebków. I super i pięknie i rozwój jak w Korei Południowej czy w Chinach po 2001 (gdy przystąpila do WTO) To jest natomiasto process powolny i nie ma pewności że bedziemy się rozwijac wszyscy, mamy PKB max kilka procent, co i tak jest nie najlepszym wskaźnikiem. Natomiast jeżeli wszyscy zarabiamy 5000zł a Jan Kowalski nauczy się lepszej technologi, ma ogrom motywacji to zaczyna zarabiac nie 5k a np. 10k i nagle moze kupić 2000 chlebków. Jan jako jednostka samostanowiąca chciała by kupić chleba jak najwięcej. Natomiast Jan dalej zarabia 5000zł i zauważył że Chleb pozdrożał o 20%, a płaca minimalna goni jego zarobki (została podniesiona o kilkadziesiąc procent placa minimalna przez ostatnie lata).   Ostatnie 2 lata byly zmienne, dużo firm ze wschodu przypłyneło do Polski i było chwilami ogromne zapotrzebowanie na programistow. Także wielu programistów ze wschodu napłynelo. Jeżeli ktoś umiał dobrze rozgrywać giełde to DAX jest na prawie ATH. Fajnie jak by pensja programisty skalowała się o inflację, jak surowce czy towary. Można by miec wlasna firme, wlasny produkt, natomiast jako pracownik nie jest to takie latwe.   3.na pewno konkurencja dla ludzi przecietnych w IT, jeżeli 100 000 ludzi umie Jave albo JS to pracodawca wybiera lepszego albo tańszego. Jak mamy niszowe programowanie np. DEX w krypto to można mieć jako programista większą marże. Pytanie czy warto pakować się all-in w np. krypto? Mieć swoją niszę gdzie ustala sie swoje marze?  Case worldpressa, kiedys sie programowalo html css itp dla prostych stron. Teraz daje sie klientowi wordpressa i sobie sam klika. Programista poszedł OUT. Kolejny przyklad to testerzy manualni, też mają ciężej. Ludzie od devopsa ktorzy zarzadzali jakimis powolnymi sposobami wdrazan, zostali wyparci przez pipeliny. Z programowaniem czystym jest troche ciezej wyprzec naszczescie, ale automatyzacja nie śpi.  Celem jednostki jest nie obudzenie się za 20 lat z ręką w nocniku i straceniu konkurencyjnosci na rynku. Znam osoby co zaszyły się w korpo, robią to samo cały czas. Nagle przychodzi recesja, jakieś zwolnienia albo firma upada i nie mają co ze sobą począć. Brak umiejetności, pewne przywyczajenie do kosztów i komfortu.;"
"Nie rozumiem tego ciągłego odkłamywania rzeczywistości. Im mniej ludzi wie o branży tym lepiej. Dlatego mi nie przeszkadza jak ludzie gadają że zaraz AI mnie zastąpi lub ze spawacz zarabia więcej. Im mniej ludzi wie, pcha się do nas i próbuje ingerować tym lepiej. Zamiast szpanu powszechnym spuszczaniem się nad naszym stanem wole jeździć 4-6 razy w roku na wakacje, serwisować auto w ASO, mieszkać w dużym domu,  jak utopie komórkę czy zepsuje się lodówka to kupić z marszu nowy sprzęt za gotówkę czy pracować w losowych częściach świata. Dlatego moje oświadczenie jest takie że eldorado nie było, nie ma i nie będzie a ja ledwo wiążę koniec z końcem ale staram się myśleć pozytywnie. Mowa jest srebrem lecz milczenie złotem.;"
"@elwis: Jasne, że ""aktualny kryzys"" może zostać zasypany kolejnym dodrukiem kasy. Jednak w jakiejś tam perspektywie on nastąpi. Nie mam wielkich obaw, że sobie nie poradzę. Mam spore doświadczenie, dość szeroką i aktualną wiedzę, w tym z aktualnie modnych obszarów jak ML. Nie sądzę też, że na aktualnym poziomie rozwoju, AI zastąpi programistów. Jeżeli zwiększy ich efektywność, to spadną koszty software, więc zwiększy się popyt. Może to zwiększyć barierę wejścia do IT, bo trzeba będzie się wykazać czymś więcej niż klepaniem banalnego kodu. Sam właściwie od początku kariery pchałem się w nowości, współpracowałem z biznesem, potrafię gadać z klientami i ogólnie dowieźć projekt, co jest dość mocno doceniane. Natomiast ""stabilność"" zawsze opierałem bardziej na zdolności spadania na cztery łapy, niż okopywaniu się na aktualnej pozycji. Zwyczajnie ciekawi mnie, jak obecnie widzimy czynniki, które wpływają na naszą wartość na rynku pracy.;"
"Dla mnie najtrudniejszy było przestac bić się po mordzie jak słyszałem niemiecki XD. A serio, to znalazłem mały projekt z Niemiec, nudziło mi się, więc zaproponowałem bym spotkania odbywały się w ich języku (tak nauczyłem się Tureckiego*). Daily z 15 min przerodziły się w 1,5h. Wszyscy byli jednak zadowoleni, ja miałem praktykę, oni kabaret XD Ogólnie polecam znaleźć sobie jakiś znajomych z danego kraju. Jest masa portali, na których można wymienić się kontaktami. Ja tak teraz utrzymuje swój niemiecki na w miarę znośnym poziomie. Inna opcja to konwersatoria, organizowane w większych miastach w szkołach nauki danego języka. Minus jest taki, że trzeba płacić, albo ilość miejsc jest ograniczona. Ostatni sposób, nie do końca polecam, bo moim zdaniem najmniej daje korzyści, to konsumowanie kultury w danym języku. Dla mnie nic nie zastąpi kontaktu z żywym człowiekiem i widząc jak szybki progres od ""0 do 100"" zrobiłem w niemieckim, a jaki w angielskim. Gdzie ang. to ""otoczenie się kulturą"", a niemiecki to rozmowy z żywym człowiekiem. Pierwszego uczę się 20lat, drugiego 4, poziom taki sam XD * taki żarcik :P;"
"Ani to ani to. Wybierz coś przy czym będziesz czuł się inteligentny, robił przy cutting edge projektach, mógł znaleźć własną specjalizację, ciągle się rozwijać i mógł się pochwalić oraz pośmiać z webdevowców, że robią proste i powtarzalne dziadostwo (aż w końcu chatGPT ich zastąpi)Czyli C++, Python razem z ML/AI, quantum computing(tu wyjazd za granicę niestety), algebra liniowa, cloudy(chociaż to też obcykane trochę) a najlepiej to wszystko na raz.;"
"Siemano, proszę pomóżcie! Nie wiem czy to przełom roku tak na mnie działa, czy mój wiek (studia kończyłem gdy jeszcze nie było Facebooka), ale czuję, że dotarłem do ""ściany"". Od kilku lat pracuje na froncie (głównie w e-commerce) i trochę na zapleczu. Ogólnie nie narzekam - kasa się zgadza, zleceń nie brakuje... tylko jakoś satysfakcji z pracy zaczęło mi brakować. I niby wiem, że technologia się rozwija, że świat idzie do przodu (pojawiły się komputery, amfetamina, samoloty:), ale prawda jest taka, że 70% tego co robię to klepanie wciąż tego samego. Mierzenie się z tymi samymi problemami. I żeby nie było - kocham pisać od kiedy miałem pierwsze c64. Wcześniej każda działająca funkcja sprawiała mi frajdę - teraz czuję się jakbym pracował na taśmie w fabryce. Co-pilot chyba tylko to wszystko pogorszył. Zacząłem szukać innej drogi. Jako pierwszy na tapet wpadł mi Python - słyszałem mnóstwo dobrych opinii. Przerobiłem kilka tutków - no i jest spoko (choć brakuje mi średników). Nie bez znaczenia jest uczenie maszynowe, którego chciałbym liznąć (tak - jestem z tych gości, którzy są zauroczeni AI). Pewnie im dalej tym będzie trudniej (chętnie to ogarnę), ale wciąż nie wiem czy się w to angażować na 100%. Próbowałem React, ale Google go nie lubi (seo), ale jak trzeba to reactuje (ale niechętnie:). W czasie mojej edukacji poznałem assemblera (lubię:), Pascala (napisałem grę w snake), c++... nigdy nie lubiłem się z php... Kiedyć pracowałem na Android Studio, ale jak wszedł kotlin to odpuściłem. Stoję teraz na rozdrożu - nie wiem czy wybrać jakąś nową ścieżkę rozwoju, poprawić swój skill na froncie czy może rzucić wszystko i wyjechać w Bieszczady. Zawsze marzyłem też o prowadzeniu wytwórni niskobudżetowych filmów pornograficznych - ale to nie teraz, tylko dopiero na emeryturze. Chcę, lubię i będę kodować - tylko w czym i po co? Proszę Was dobrzy ludzie: pomóżcie i doradźcie. Może coś przegapiłem? Szukam tylko w swojej bańce? Zlitujcie się - dla mnie to zbyt wcześnie żeby produkować porno! Mimo tych wspomnień o porno - proszę Was o poważne odpowiedzi. Dzięki z góry! Peace!;"
Systemy operacyjne i uczenie maszynowe.;
"Tak, tak robot murarza nie zastąpi...;"
Uważasz że ten robot będzie w powszechnym użyciu w Polsce w ciągu 15 najbliższych lat? Bo jakieś tam robot z tego co pamiętam był w 1860 roku na pokazie w USA - ii co nadal pracownicy kolejowi pracują na torach. A to już prawie 200 lat temu. On wspomaga dziś wbijanie ćwieków w szyny. A ludzie nadal tam robią. Stolarki na zamówienie nie zastąpi ani elektryki i kładzeni kabli w domach.;
"Hejka, posiadam problem z moim kodem, jest ktoś w stanie mi z tym pomóc? Błąd pojawią się w bt1.onclick = function (). Niby nie ma wartości <!DOCTYPE html> <html lang=""en""> <head>   <meta charset=""UTF-8""/>   <meta name=""viewport"" content=""width=device-width, initial-scale=1.0""/>   <title>Porównanie AI</title>   <link rel=""stylesheet"" type=""text/css"" href=""style.css""/> </head> <body> <div class=""top"">Porównanie AI</div> <div class=""container"">   <div class=""title"">ChatGPT</div>   <div class=""title2"">Bard AI</div>   <div class=""title1"">Pytania</div>   <div class=""texxt"">     <p id=""tekst""><b>Tu otrzymasz odpowiedź</b></p>   </div>   <div class=""texxt1"">     <p id=""tekst""><b>Tu otrzymasz odpowiedź</b></p>   </div>   <div class=""texxt2"">     <button class=""bt1""><b>Czy bóg istnieje?</b></button>     <button class=""bt2"">       <b>Kto jako 1 wynajdzie komputer kwantowy?</b>     </button>     <button class=""bt3"">< b>Ile to 2+2x2?</b></button>     <button class=""bt4"">< b>Czy roboty przejmą świat?</b></button>   </div> </div> </body> <script>   //definiowanie zmiennych//   let tekst = document.getElementById(""tekst"");   let bt1 = document.getElementById(""bt1"");   let bt2 = document.getElementById(""bt2"");   let bt3 = document.getElementById(""bt3"");   let bt4 = document.getElementById(""bt4"");   //onclick//   bt1.onclick = function () {     tekst.innerHTML = ""XD"";   }; </script> </html>  Edit: @Riddle zformatowałem kod, ponieważ został wklejony niepoprawny HTML (spacje między < i tagiem);"
"taa tyle że to już wtedy statystyka itp. więc nie jeden już odpadnie w przedbiegach bo nie będzie się chciało sięgnąć po książkę a w przypadku przebranżawiajacych się to już ściana. Ale prosta sprawa. Po prostu projekty z AI same wygenerują potrzebę budowania do nich frontów i backendów. Więc nie będzie tak że AI sam w sobie zabije miejsca pracy wręcz przeciwnie, boom na nie wygeneruje zapotrzebowanie na nowe portale, appki mobilne. W kwestii samych programistów to te modele językowe to przez najbliższe lata będzie pomoc. Kto tam gada w mediach o tym że to wykosi programistów nie ma pojęcia czym jest machine learning;"
generyczne crudy to chyba chatgpt zastapi spring data. To wojna maszyn na jaka zaslugujemy;
"Zastanawiam się, czy nie jest już tak, że w dobie ChatGPT zadania rekrutacyjne przestały mieć sens jako sposób na sprawdzenie umiejętności programisty. ChatGPT może nie zastąpi jeszcze programisty jako zawodu, ale umie pisać krótkie programiki na podstawie promptu tekstowego, a zadania rekrutacyjne to dokładnie to: ""piszą ci prompt tekstowy i masz zaimplementować"". To robota dla AI. Nawet jak trzeba będzie poprawiać, to jeśli możesz mieć już szkielet zrobionego zadania w minutę, to i tak oszczędność czasu (szczególnie, że zadania rekrutacyjne to często 5 czy więcej godzin pracy za darmo). Więc chyba teraz wręcz należałoby korzystać z ChatGPT do robienia zadań rekrutacyjnych.;"
"Akurat nie znam bibliotek jako takich, z takich prostych algorytmów to masz cross correlation gdzie masz przykłady jak wyglądają sygnały danych komend i wyliczasz pomiędzy sygnałem przechwyconym przez mikrofon, a tym z przykładu korelację i przy pewnym threshold akceptujesz. Później masz feature extraction jakiś mel-frequency cepstral coefficiencs i później możesz jakieś ml metody na tych cechach przeprowadzać jak clustering, gaussian mixture model, hidden markov chain. No i jeszcze lepsze to sieci neuronowe, gdzie poza tym możesz też użyć sieci one shot learning gdzie będzie obliczać similiarities między dźwiękami. Jako, że to C++ to wszystkie modele AI ci zadziałają, gdyż wszystkie frameworki są zbudowane na C++, macierzysty język. Do tych dwóch wyrazów w dodatku to są angielskie to zapewne wystarczy ci jakiś bardzo mały zdestylowany model, sam mam llame3 na dysku 8B i przemielenie koło 50-100 znaków w 3-5 sekund na zwykłym desktopie ogarnie. Mój ulubiony model do speech to text akurat jest whisper, tiny model ma 32mb, te najprostsze wyrazy łatwo rozpoznaje poniżej 1sekundy, zależy jaki input dźwięku długi jest, jakieś trudne zdania polskie to już musisz mieć small wersję. Przed chwilą nagrałem na mikrofonie stop i start wyraz, dałem pod najmniejszy model tiny i bezbłędnie wykrył wszystko. Też można nie nagrywać np. 3 sekund i potem dać do modelu, tylko jednocześnie nagrywać i przetwarzać co też przyspieszy wykonanie. (https://github.com/openai/whisper) Później masz drugi problem jak będziesz nagrywał ten dźwięk, bo masz w sumie 2 sposoby, jeden to naciskasz klawisz i wtedy cię nagrywa, puszczasz to się kończy nagrywanie, to jest przekazywane do modelu. Inny to jest ciągłe nagrywanie wtedy, będzie ciągle chodził procesor, można dać teź wake word, czyli słowo na które nasłuchuje model. Czy ciągle po prostu przetwarzać co oczywiście może trochę być kosztowne. Patrzyłem rozwiązania gotowe to taki command word w esp https://docs.espressif.com/projects/esp-sr/en/latest/esp32/speech_command_recognition/README.html używają wake word żeby wykryć, że ktoś chce coś powiedzieć do modelu i potem do głównego dają, żeby cały czas ten główny nie pracował, bo wtedy trochę będzie obciążał wszystko. W sumie sam nie wiem jak z bibliotekami, sam nie używam, ale modele są do nawet całego przetwarzania tekstu. Też czy jesteś ograniczony obliczeniowo żeby to wykonać. Jeśli taki model AI ci wystarczy, czy użyć jakiegoś zewnętrznego api, to wtedy można spróbować jednego rozwiązani i jak coś to zmienić na inne.;"
"Projekt powinieneś napisać bez użycia sklearn, to wtedy byś udowodnił, że masz podstawy statystyki, to są dość proste algorytmy do napisania od ręki i dodatkowo ze statystyki byś się podciągnął. Tak to nlp to operacje na danych sekwencyjnych to powinieneś też sieci neuronowe poznać, rekurencyjne, transformer, czytać papiery na arxiv jak np. https://arxiv.org/pdf/1706.03762.pdf Uczysz się całe życie, nie ma tak że jednej rzeczy się nauczysz i koniec w dodatku ta gałąź nauki się szybko rozwija. Ciekawe artykuły do czytania są na stack/math/ai/overflow, Dla przykładu jakiś https://medium.com/@ageitgey/natural-language-processing-is-fun-9a0bff37854e Powinieneś dużo czytać i implementować.;"
"No ale co wybralo? Przeciez ciezkie obliczenia  w AI ida w c++ a python to tylko binding. Ten argument ze sprzętem  nietrafiony, bo w AI obliczenia są  często  tak ciężkie  (głównie  sieci neuronowe) ze nawet szybki  sprzet z modelami zaimplementowanymi w czysttm pythonie liczyl by je latami;"
Temat jest nie trywialny gdyż nie ma jasnej granicy kiedy według ciebie zdjęcia są podobne a kiedy nie. Czyli musisz znaleźć jakiś analizator obrazu który porówna zdjęcia i zwróci ci procent zbieżności a to ty zdecydujesz kiedy są podobne a kiedy nie. Kiedyś do takich rzeczy używało się transformaty Fouriera ale uczenie takiego modelu będzie wymagało tysięcy zdjęć w zbiorze uczącym (niezależnie czy pójdziesz w ML czy jakieś sieci neuronowe będziesz potrzebował dużego zbioru uczącego).   Może opisz jaki problem chcesz rozwiązać to będzie łatwiej coś doradzić.;
"Cześć, potrzebuję pomocy z realizacją projektu BigData na studia, oto jego kroki:  Przetwarzanie i analiza w środowisku rozproszonym - Big Data & Data Science Opracować: koncepcję, główne procesy przetwarzania, architekturę środowiska przetwarzania i analizy (VM lub cloud Azure) w przetwarzaniu strumieniowym i wsadowym. Dobierać odpowiednie komponenty BD&DS - rozproszone (min. 2 węzłach): zasoby/bazy, środowiska przetwarzania, kolejki, środowisko zarządzania przetwarzaniem/procesami (NiFi, AirFlow), VM, kontenery/dockery Analiza statystyczna (strumień dla SMO - określć/wyliczyć parametry strumienia lambda) Zastosowanie AI (ML,DL,NLP,...).  Podczas realizacji tego zadania mam całkowitą dowolność w doborze interesujących mnie narzędzi, więc nie ma żadnego znaczenia czy wybiorę Hadoopa, Sparka, Piga czy coś od Elastica. Totalnie nic nie wiem odnośnie BigData, więc liczę, że z waszą pomocą uda mi się zrealizować ten projekt. Czy ktoś ma jakieś rady od czego w ogóle zacząć? Dane na pewno pobiorę za pomocą jakiegoś ogólnodostępnego API i w sumie na tym kończy się moja wiedza, odnośnie tego projektu. Będę wdzięczy za jakąkolwiek formę pomocy - zarówno za jakieś materiały na YT czy nawet zwykłe linki do artykułów. Dzięki za pomoc! :D;"
"Używam copilita od jakiś dwóch tygodni. Generalnie całkiem niezła pomoc i wklepuje zauważalnie mniej kodu, bo naprawdę świetnie się domyśla co chcę osiągnąć. Ale najlepiej wychodzi mu podpowiadanie komentarzy dokumentujacych publiczne api ;) Jak ktoś ma tendencje do kopiowania kodu z Internetu bez zrozumienia, to narzędzie nie sprawi, że nagle jego kod będzie lepszy. Będzie tak samo zły. Co nie znaczy, że doświadczony, samodzielny programista nie jest w stanie skorzystać z tego narzędzia by podnieść swoją produktywność. Pracy koncepcyjnej programisty nie zastąpi, ale z nudnym kodem pomoże.;"
"Na początku zabaw z takimi technologiami jak AI zawsze próbujemy robić rzeczy łatwe i oczywiste dlatego nie ma nic dziwnego w tym, że to już ktoś zrobił lepiej. Pierwsze sieci neuronowe działały na lampach elektronowych a teoria jest jeszcze starsza... Więc naukowcy trochę lat, jużmieli na to żeby dobrze zaimplementować rozpoznawanie literek czy obrazków. Sieci neuronowe, algorytmy genetyczne czy systemy rozmyte to bezdyskusyjnie przyszłość. Wyspecjalizowanie się w tych dziedzinach zagwarantuje Ci pracę w bardzo ciekawych miejscach... Trzeba jednak wiedzieć, że aby taką pracę dostać to nie wystarczy wiedzieć jak wytrenować prostą sieć, ale trzeba samemu potrafić problem postawić tak aby za pomocą AI był rozwiązaywalny, a to już wymaga praktyki i kilku lat doświadczeń. Pewne jest, że warto w to iść. Dziś AI dopiero wychodzi z uczelnianych zakamarków do świata komercyjnego. Lawina pomysłów na zastosowanie tych technologii jest dopiero przed nami.  Tak. Choć to zwykle dużo trudniejsze to małe zespoły/firmy też tworzą wiele innowacyjnych rozwiązań. Rzecz w tym, że w takiej sytuacji sam musisz się zaopiekować produktem, który stworzysz. Sam się nie sprzeda. Zatem jeśli chcesz być tylko programistą i wolnym strzelcem jednocześnie to raczej mała szansa, że tą wiedzę przerobisz na pieniądz. Jeśli jednak masz chęć tworzyć własne produktu i je sprzedawać to taka wiedza jest jak ""złoto"".;"
Wystarczy nakarmić go treścią z Flame/Offtopic. Resztą zajmie się ludzki klient.  Czemu mnie nie dziwi że taki wysryw jest na geekweeku xD  Mamy badania wykazujące korelację pomiędzy wykresami EEG różnych ludzi obserwujących/klasyfikujących obrazy/opisujących swoje stany emocjonalne. Wystarczająco danych by budować modele predykcyjne. Mamy badania z których jasno wynika że sieci neuronowe reagują na stymulację polem elektrycznym oraz/i magnetycznym. Mamy możliwość czasowego knock-outu odpowiednich obszarów mózgów w celu badań koordynacji i roli pomiędzy obszarami w analizowaniu poszczególnych scenariuszy. Wszystko jest kwestią czasu pieniędzy i (braku) etyki/moralności w badaniach.;
"@Ktos: Delphi 2007 ale to było naście lat temu i nie wyczynowo. Nie jest to program na zaliczenie więc pomyślałem, że nauczę się albo javy albo phytona. Terminy nie gonią ale nie chciałbym się za pół roku dowiedzieć, że e się czegoś nie da albo było by lepiej inaczej dla tego pytam mądrzejszych Jeśli mówisz że client, serwer, sieci neuronowe w javie obskoczę to ok. Edit. Fluttera też obejrzę bo o nie miałem styczności. No właśnie teraz pytanie bo na chwilę obecną jest tylko laptop na Windows a program nie będzie prototypowy ale na czym najbezpieczniejszy i najwydajniejszy będzie serwer? To i na czas pisana sobie zorganizuję jakiś mini do testów.;"
"@ZrobieDobrze: Bo wiesz, na pierwszy rzut cokolwiek przesyłane byle działało. Więc mogły by to być pliki txt, stringi i bmp/ tabele danych. Żeby nauczyć się i uruchomić komunikację. Ważne by te sieci neuronowe po drodze można było. Gdzieś w drugiej wersji będzie to prosty menadżer plików księgowości lub/ i plików audio, obrazy. Czyli np wyszukiwanie podobnych dokumentów. Do wstępnego segregowania. Ale to już mniej istotne. Nie chcę sobie dużego celu stawiać żebym się w myślach nie poplątał :).;"
"Ciężko ci coś doradzić konkretnie, nie wiedząc jakie są faktyczne wymagania. Czy to musi być aplikacja, czy wystarczy stronka mobilna, czy sieci mają być używane na serwerze, czy również na urządzeniu mobilnym. Czy jest to taka sobie wprawka do CV, czy coś co ma stać się skalowanym i utrzymywalnym systemem. Dla Androida Kotlin jest w tej chwili najpopularniejszym językiem, przy okazji będzie tam do ogarnięcia najwięcej rzeczy, bo sam Android framework to już kobyła, a pojawią się pewnie inne wyzwania. Na Windows możesz do napisania serwera użyć właściwie czegokolwiek. Osobiście polecałbym ograniczyć liczbę języków i skorzystać z Kotlin + Ktor. Sieci neuronowe, czy ogólnie AI to już kompletnie inna para kaloszy, znowu zależy co chcesz tym analizować, gdzie wykonywać predykcje, jak zbierać dane itd. Jest trochę frameworków, które pozwolą ci np. wyuczyć model na maszynie z windowsem i używać go na urządzeniu mobilnym, ale sporo zależy od konkretnego zastosowania. Jakieś popierdółki na 5 zmiennych nie ma problemu, z rozpoznawaniem obrazu będzie już trochę gorzej.;"
"Rozpisz sobie co ma robić najprostszy wariant tego co chcesz osiągnąć. Zdecyduj się co ma być po stronie serwera, a co po stronie klienta. Poczytaj sobie o REST API, zaprojektuj to co ma oferować serwer (w najprostszym wariancie) i go napisz. Żadne tam Springi (chybam, ze chcesz podpompować CV, albo coś...), tylko proste rozwiązania typu podany wcześniej Ktor. Zrąbiesz to pewnie masakrycznie, ale opanujesz podstawy języka. Testowanie jakimś klientem http, może być wbudowany w Intelli (tworzysz plik cośtam.http i wpisujesz np. GET http://localhost:8080/myendpoint). Jak uda ci się doprowadzić serwer do działania, to bierzesz się za klienta. Będziesz potrzebować jakiejś biblioteki klienta http + trochę ""formatek"". Wykorzystasz w tym Kotlina, którego liźniesz podczas robienia serwera. Sieci neuronowe: Wyuczenie sieci neuronowej do rozpoznawania znaków, to trochę banał. Masz gotowe zbiory do trenowania ML, więc najtrudniejsza część (przygotowanie danych uczących) jest za tobą. Pozostaje przygotowanie i wyuczenie sieci. Na początek potrzebujesz wiedzy ""co to jest sieć"", ale nie żadne pierdoły i nagrodach i karach, tylko podstawy działania NN. Ten kurs: https://www.coursera.org/specializations/machine-learning-introduction da ci tę wiedzę (wiem, bo go robiłem). Następnie bierzesz tę wiedzę i robisz drugi kurs, z Tensorflow, nie mogę znaleźć go w tej chwili, też był niezły i za darmo (dobre bo tanie), ale bez wiedzy o tym co to jest learning set, test set, validation set możesz mieć problem, dlatego polecam najpierw ten pierwszy prowadzony przez Andrew Ng. Jak już będziesz miał model, to pozostanie ci go podłączyć do serwera, albo do klienta, gdzie ci wygodniej.;"
"Siedzenie na tyłku 8h na dobę i czekanie na hemoroidy to taka zajebista praca? Mamy zarobki powyżej średniej ze względu na to że nasza praca jest łatwo przenaszalna między krajami, ale też łatwo takie stanowisko zlikwidować. Konkurujemy z całą Europą wschodnią, Chinami i Indiami. Kto wie jak długo nam to się będzie udawać? Jeśli ktoś myśli że może się poopierdzielać za 10k to oczywiście ma rację, tylko to myślenie krótkowzroczne. Bo albo zastąpi go Ukrainiec, albo ktoś się zorientuje że ma za mały wkład. Albo cała firma się zawinie do jakiejś Indonezji. Trzeba być ciągle ap-to-dejt, albo trzymać się jakiejś archaicznej technologii której nie uczą na butkampach w Kraju Połudiowej Azji. Każde z rozwiązań ma swoje plusy i minusy.;"
"Chciałbym się dowiedzieć jaka powinna być moja znajomość matmy, żeby móc zrozumieć w pełni szeroko rozumiane uczenie maszynowe, głębokie uczenie, przetwarzanie obrazów w opencv itd. Czy wystarczy, że wiem jak policzyć przysłowiową deltę i rozwiązać układ z trzema niewiadomymi, czy też powinienem coś więcej wiedzieć i rozumieć o takich rzeczach jak płaszczyzny, wektory, jakobiany, liczby zespolone, całki, pochodne, pochodne wyższych rzędów, sploty i inne tego typu duperele? Wiem, że prawdopodobnie ktoś już dawno temu te rzeczy zaimplementował, ale mimo wszystko pytam.;"
"To zależy. Obecnie można gotowe modele ściągnąć z Internetu, nie musisz być biegły z matematyki, żeby używać tego w oprogramowaniu czy to swoim czy w firmie. Można również wykupić sobie gotową usługę w chmurze i również nie przejmować się jak to jest zbudowane w środku. Za pomocą tych gotowych klocków możesz rozpoznawać obrazy, interpretować mowę itd. Jeżeli jednak chcesz sam programować modele, to najważniejszą dziedziną matematyki z której mocno czerpie uczenie maszynowe i vice versa jest statystyka, a nie analiza czy algebra. Analiza i algebra to tylko podstawy. W statystyce trzeba czasem policzyć jakąś całkę oznaczoną i w sumie tylko tyle masz z analizy. Zatem nie musisz być biegły z analizy, za to ze statystyki już bardziej. Nie bez powodu największymi specjalistami z uczenia maszynowego są często posiadacze doktoratów ze statystyki.;"
"Cześć, chciałbym się trochę dowiedziedzieć na temat uczenia maszynowego. Mój obecny poziom:  ogarniam sporo dewelopersko (4 lata doświadczenia) ukończona informatyka (mgr, UW) ogarnięta w miarę matma zupełne podstawy jeżeli chodzi o samo uczenie maszynowe.  Czy moze ktoś polecić jakąś książkę, która będzie skupiała się trochę na praktyce, a trochę na teorii? Nie chodzi mi o samą teorię, ale nie zależy mi też na podejściu tutorialowym. Fajnie, jakby książka w części praktycznej korzystał z TensorFlow. Pozdrowienia :);"
"Czy algorytm wstecznej propagacji to uczenie maszynowe? Z tego co wiem to tak, ale wole się upewnić.;"
"Uczenie maszynowe to sposób na znalezienie najlepszego estymatora dla zbioru danych; a robi się to najczęściej za pomocą algorytmu wstecznej propagacji, a w zasadzie gradient descent, ale można by użyć innej metody minimalizacji normy, np., algorytmu genetycznego. Napisałem gradient descent, ale nie wiem czy miałeś na myśli ML, ale nie deep learning, czy ogólnie AI statystyczne: AI - GOFAI.;"
"Czyli po prostu w niektórych przypadkach w DP człowiek nie wie jak zachodzi proces decyzyjny (bardziej zaawansowane sieci neuronowe) i wtedy to jest określane mianem czarnej skrzyniki, czyli człowiek nie jest w stanie określić tego jak program uzyskał poszczególne wyniki na wyjściu?;"
"Podjąłem jednak inną decyzję, pewnie w jakimś stopniu za jakiś czas będę jej żałował, ale doszedłem do wniosku, że przy tym trybie zajęć, planu, odległości studiowanie nie będzie zbyt efektywne. W poprzednim semestrze było kilka zajęć, na których prowadzący faktycznie pomogli i tego chyba będę żałował najbardziej. Niestety teraz już po pierwszym tygodniu widać, że w zasadzie większość jest do samodzielnej nauki w domu, praktycznie od początku do końca. Czytanie na wykładzie prezentacji słowo w słowo w 2022 r. mnie przerosło. Prawdopodobnie w kolejnych semestrach zmieni się to na plus. Poznałem w porządku ludzi, myślę, że udzielą kodów i w co przydatniejszych wykładach będę uczestniczył zdalnie. Z ćwiczeń porobię ksero albo zdjęcia - nic nie zastąpi fizycznej obecności i wysłuchania na własne uczy, ale dobre i to, tym bardziej, że te rzeczy będę i tak się uczył we własnym zakresie. Niestety prawie w całości zajęte dni związane z zajęciami i dojazdem nie pozwolą mi zrealizować tego co bym chciał w sposób w jaki bym chciał. Tym bardziej że oprócz samej analityki danych i programowania są też inne przedmioty, wymagające i zapewne czasochłonne jak fizyka, metody numeryczne, równania różniczkowe i jeszcze 2 semestry samej analizy matematycznej. Ciężka decyzja, nie ma dobrego wyjścia, ale jeśli znowu mam niedosypiać i naganiać wieczorami /nocami to już wolę swoim tempem za pomocą tego co dostępne online + w książkach. Z tytułu braku papieru będzie też pewnie kłopot z pierwszym stażem. Będę chciał to nadrobić skillem, a jeśli będzie za mały tzn. że się nie nadaję do tej pracy i trzeba będzie szukać szczęścia gdzie indziej. Wstępny plan na najbliższe pół roku to Podstawy pythona/ podstawy statystyki/ angielski.;"
"Często pojawiają się tutaj tematy o karierze, niepohamowanej chęci rozwoju, niespełnionych ambicjach i niemal atawistycznym pragnieniu poznawania nowych technologii. Tego typu wątki prawie zawsze budzą spore emocje. Ja natomiast chciałbym sprawdzić ile w tych ""szczerych"" chęciach oraz ""złotych"" poradach jest prawdy a ile zwykłego pierniczenia i powtarzania zasłyszanych w ""internetach"" sloganów. Napiszcie lub pokażcie co faktycznie zrobiliście dla swojego rozwoju. Co przeczytaliście od deski do deski ze zrozumieniem albo co zaimplementowaliście w ramach ćwiczeń. Moje z ostatnich 3 lat:   W związku z awersją do obcych framework'ów ćwiczę obecnie TypeScript + WebComponents + własny EntityFramework ( w przyszłości do wykorzystania komercyjnego ) ;   Ciągle praktykuję algorytmy genetyczne ( obecnie wyznaczanie tras atrakcyjnych turystycznie ). Wspieram się książką Zbigniewa Michalewicza - ""Algorytmy Genetyczne"" choć on ma bardzo ""purystycznie - bitowe"" podejście do tematu to polecam.   Przygotowuję się teoretycznie do pracy z sieciami neuronowymi w obróbce sygnału akustycznego ale jeszcze nie potrafię implementować tego co chcę w TensorFlow - potrzebuję kilku dni spokoju aby to ogarnąć do końca. Samodzielne próby implementacji sieci okazały się bezcelowe ale i tak spróbować musiałem bo inaczej nie byłbym sobą. Przeczytane: Ryszard Tadeusiewicz - Sieci Neuronowe, Akustyka - F. Alton Everest - Podręcznik Akustyki, w trakcie: Akustyka - Rufin Makarewicz - Dźwięki i Fale.pdf ;   C++ ogólnie i obiektówka w C++ na AVR ( mimo wielu lat nigdy się z tym językiem nie zaprzyjaźniłem a w elektronice to jednak rzecz popularna )   Efekty ćwiczeń::  Uproszczony wynik działania alg. genetycznego dla wyznaczania trasy Kraków -> Paryż:    Sterownik wzmacniacza bazujący na jednym enkoderze z przyciskiem a dostępne funkcje to:   obsługa z pilota ; głośność ; balans ; zmiana źródła ; gładkie wyciszanie / zgłaśnianie ( fadeout / fade in ) ; odłączanie głośników przy zaniku napięcia ; kilka innych drobiazgów ...     screenshot-20200814131038.png (7 MB) - ściągnięć: 86 screenshot-20200814131233.png (2 MB) - ściągnięć: 54 screenshot-20200814130917.png (10 MB) - ściągnięć: 77 screenshot-20200814130305.png (2 MB) - ściągnięć: 51;"
"Ogólnie chłonę teorie,  złapałem straszną apatie do programowania, nawet w pracy ledwie wie zmieniło szam do robienia minimum rzeczy, o projektach juz nie mówiąc, wiec sie skupilem na teorii. Może uczenie sie nowych rzeczy pomoże mi to przełamać.  Przerabiam sobie zapomnianą matme ze studiow, żeby latwiej bylo sie zabrać za AI i Sieci neuronowe. Przerabiam Artificial intelligence: a modern approach. ""Think like a mathematician"" Barbary Oakley;"
"Dzięki za odpowiedź, Materiałów mam aktualnie dość sporo do nauki. Książki takie jak: ""Data Science od podstaw. Analiza danych w Pythonie"" J. Grus ""Python. Uczenie maszynowe"" S. Raschka ""Uczenie maszynowe z użyciem scikit-learn i tensorflow"" A. Geron ""Zaawansowane uczenie maszynowe z językiem Python"" J. Hearty Kończę aktualnie tę książkę o której wspominałem, czyli Automatyzacja nudnych zadań z pythonem. Staram się wykonywać wszystkie zadania i idzie mi to bardzo sprawnie. Czy jeśli chce cisnąć głównie w Data Scientista to jest sens tracić czas na frameworki typu Django, Flask itp czy jednak warto poznać chociaż podstawy z czym to się je? I drugie pytanie: zarabiam już teraz calkiem nieźle (ok. 8k brutto), ale nie jest to coś co dokładnie chciałbym robić (mało u mnie w dziale programowania, może czasem jakiś SQL i trochę R), to czy po ogarnięciu tego wszystkiego, studiów podyplomowych i stron, które wysłał kolega wyżej, jest sens szukania pracy na Juniora czy można z moim doświadczeniem uderzać na coś wyżej za lepszą kasę (oczywiście zakładając, że ogarnę wszystko co wyżej w stopniu bardzo dobrym)?;"
"Zbliżają się Święta i kilka dni wolnego, wypada więc poświęcić kilka godzin na swoje hobby. Mnie od pewnego czasu męczą sieci neuronowe mam już opracowaną całą koncepcję i algorytmy, jednak zwyczajnie nie wiem w czym to napisać. Moje ""natywne"" języki to PHP i Delphi ... PHP z założenia się do tego nie nadaje a w Delphi to już tylko dinozaury i ja piszą zresztą chcę się od niego kiedyś odciąć. C++ nie cierpię i mam na nie alergię z wysypką włącznie. Przeglądając internet w tematyce sieci neuronowych spotkałem dużo publikacji z przykładami niestety w C++ ale także w Python'ie. Pythona choć nie znam to postanowiłam go wstępnie ""pooglądać"" napisać kilka ""hello world"" i czuję, że zdecydowanie będzie mi bliższy niż C++. Zatem do rzeczy. Szukam biblioteki dla Pythona, która pomoże mi ogarnąć przeliczanie sieci neuronowej, zmiennoprzecinkowej pozostałe parametry to ( pi * drzwi ale może coś ułatwi ):  1000 wejść. 2 do 4 warstw ukrytych każda po 1200 - 2000 neuronów. 1000 wyjść.  Takich sieci (każdej skonfigurowanej nieco inaczej ) w pamięci jednocześnie chciałbym trzymać 50 - 500. Nie chcę tego samemu pisać bo jakoś głęboko czuję, że podczas przeliczania takich sieci można sporo zoptymalizować bardzo dużo zyskując na wydajności ( nie będę kola na nowo wymyślał ) a na niej zależy mi najbardziej bo zaplanowany proces uczenia z założenia jest czasochłonny i robi mi sporą różnicę, czy zapuszczę algorytmy na 3 dni zamiast 30 na własnym algorytmie.;"
"Pewnie, że programowanie zostanie wyparte, na szczęście analitycy zostaną wyparci wcześniej :-D :-D;"
"Cześć, chciałem w ramach samorozwoju zrobić coś z Android NDK. Poszukałem i na razie znalazłem zajawki:  VOIP, PJSIP https://github.com/pjsip/pjproject  sieci neuronowe https://developer.android.com/ndk/guides/neuralnetworks  sieci znowu https://github.com/axinc-ai/ailia-android-ndk  jakieś sample https://github.com/android/ndk-samples/tree/master  książka (jeszcze nie zaglądałem) https://github.com/corporateshark/Mastering-Android-NDK  zabawa z OpenCV Crashlytics przez Firebase w Androidowej apce używającej NDK https://medium.com/@aungkyawmyint_26195/setting-up-ndk-crashlytics-android-11ad775676f7  jakieś PR do VLC https://github.com/videolan/vlc-android  crossplatform https://oziemski.medium.com/handling-cross-platform-frameworks-in-native-applications-92811cae7480  openssl https://proandroiddev.com/tutorial-compile-openssl-to-1-1-1-for-android-application-87137968fee  openssl i przy okazji Qt https://www.volkerkrause.eu/2019/11/09/qt-ssl-on-android-qt-5-13-1.html  niby-chowanie czegoś w ndk https://rahulsharmagbpec.medium.com/hiding-secret-api-key-from-reverse-engineering-in-android-using-ndk-bdc774a73fa9  AWS SDK for C++ https://docs.aws.amazon.com/sdk-for-android/  sqlite i cipher https://github.com/sqlcipher/android-database-sqlcipher https://developer.android.com/jetpack/androidx/releases/sqlite https://developer.android.com/reference/android/database/sqlite/package-summary;"
"@leczo: Trzeba było od razu napisać, że artykuł jest za paywallem, a tak to straciłem czas na czytanie biografii jakichś przydupasów.  Nie potrafimy zautomatyzować segregacji śmieci i zamiast tego angażujemy w to całą ludzkość. Jak niskie trzeba mieć IQ żeby nie potrafić posegregować śmieci zwykłego Kowalskiego? Prawdopodobnie tresowane małpy lepiej by sobie poradziły w tym zdaniu niż najnowsze sztuczne sieci neuronowe czy tym podobne wynalazki.;"
"@TrexBoy: Forum to nie jest Twój blog. Forum to nie jest Twoje prywatne repozytorium kodu. Forum to nie jest portal rekrutacyjny. Pisałem Ci już o tym, gdzie coś takiego możesz robić TUTAJ, powtórzę jeszcze raz:  Jeśli chcesz gdzieś tworzyć kod i się nim dzielić ze światem, to istnieją liczne serwisy oferujące publiczny dostęp do repozytoriów, jak na przykład GitLab. Jeśli chcesz, by ktoś Ci pomógł z konkretnym i dobrze opisanym zagadnieniem, wyraź to w jasny i oczywisty sposób w tytule i w treści tematu. Jeśli chcesz, żeby ktoś Ci zrecenzował kod, zamieść temat w odpowiednim dziale. Jeśli chcesz kogoś zatrudnić do pomocy, zamieść temat w odpowiednim dziale, podając koniecznie stawkę i oczekiwany zakres tej pomocy. Jeśli chcesz pisać bez ładu i składu, załóż bloga.   Tu nie chodzi o lubienie czy nie, tylko o to, że śmiecisz — używasz forum generując nieczytelne, bezwartościowe treści. Nikt nie wie, o co Ci chodzi. Pomimo licznych i powtarzanych próśb o wyjaśnienie, nie wyjaśniasz, tylko dalej przeklejasz automatycznie wygenerowany tekst. Co może zrobić każdy z nas, minimalnym wysiłkiem.  Nikt Ci nie broni robić swojego — na swoim. Na razie jesteś na cudzym, więc musisz przestrzegać cudzych zasad.  To się dowiedz, a do tego czasu nie męcz tym innych. Bo ci inni też nie wiedzą, i wiedzieć nie mają jak. To szum informacyjny. Śmieci. Być może wśród tych śmieci leży coś wartościowego, ale nikt ich nie będzie przegrzebywał „bo może”.  My też byśmy chcieli, więc jak ktoś od nas oczekuje pracy, to my od niego oczekujemy pieniędzy.  To dla obdarowywanych bezwartościowe prezenty — kod wygenerowany automatycznie, który prawie-że, ale jednak nie-do-końca działa, każdy kto odczuwa taką potrzebę może sobie wygenerować w ilościach dowolnych. To są śmieci.  Jesteś jedyną osobą, którą to bawi. Pozostałym przeszkadza to w korzystaniu z forum. Śmiecisz.  Nie. To niskiej jakości, praktycznie bezwartościowy kod wygenerowany przez model językowy. Próba dopatrywania się tam czegoś jest nonsensowna — gorzej, niż wróżenie z fusów, albo próba odczytania pogody z makaronu w rosole. To są śmieci.  To zdanie, jak i sporo Twoich, jest kompletnie nonsensowne i niezrozumiałe. To są śmieci.  To zdjęcie nie ma nic wspólnego z chatem GPT 3.5.  Tak, operacje wykonuje się, zazwyczaj, na łóżkach. Z faktu, że już się tak dzieje (i działo od tysiącleci), wynika, że się da. Łóżka medyczne istnieją. Mogą zaistnieć nowe.  „Weźmy się i zróbcie” — inżynieria (czy to łóżek medycznych, czy jakakolwiek inna) to praca. Za pracę się płaci — inaczej to niewolnictwo. Jeśli chcesz, i się na tym znasz (jakie jest Twoje doświadczenie z inżynierią w ogólności, i inżynierią medyczną i projektowaniem łóżek w szczególności?), to droga wolna. Jak chcesz ludzi do tego, to im zapłać.  Modele językowe, w tym i Chat GPT, nie służą do celów inżynieryjnych, i nawet jeśli jakieś zastosowanie by tam znalazły, to mocno poboczne. Dalej potrzebujesz ludzkich ekspertów. Jeśli nie jesteś takim samemu, to musiałbyś któregoś zatrudnić (za kasę) i mu dobrze, czytelnie wytłumaczyć, nad czym miałby pracować. Na razie, to są śmieci.  Twoje notatki są bezużyteczne dla innych. Nawet, jeśli coś wiesz — na ten temat czy dowolny inny — to Twoje notatki tego nie komunikują. Nie niosą ze sobą czytelnej dla innych treści. To śmieci.  Co mają drzewa do łóżek medycznych? Po co łóżku drzewo? Co mają te znaki do drzew? Twoja wizja jest nieczytelna dla innych. Nikt nie wie, co masz, co chcesz osiągnąć, jak się jedno łączy z drugim, co by trzeba było zrobić, żeby z jednego dojść do drugiego. To śmieci.  To tym gorzej. Bez „umiejętności dokładnego określenia się”, niezależnie jakie potencjalnie genialne pomysły byś miał, nie jesteś w stanie ich nikomu przekazać. Nie da się Ciebie zrozumieć. Generujesz i wrzucasz śmieci.  Prześwietlają narzędzie obrazujące — takie jak, na przykład, tomograf komputerowy — nie programy. Jeśli masz narzędzie obrazujące, które trzeba oprogramować (choćby celem wyświetlenia w programie 3D), to potrzebujesz: a) jego bardzo dokładną specyfikację, uzyskaną od producenta; b) kupę doświadczonych programistów, którzy są w stanie napisać wystarczająco poprawne i bezpieczne oprogramowanie. Jeśli nie masz nawet urządzenia, to potrzebujesz dodatkowo zespół inżynierów, którzy się na projektowaniu takich urządzeń znają. Tym ludziom trzeba by było za tę pracę zapłacić.  Dlaczego akurat z taką dokładnością? Już istnieją narzędzia o podanej wyżej (0,1 mm) rozdzielczości — obrazowanie to nie jest obecnie przeszkoda w mikrooperacjach, przynajmniej nie w tej skali. Wątpliwym pozostaje zysk z wykorzystywania AI do operowania ludzi — choćby dlatego, że nijak nie wiadomo, jak takie AI uczyć.  Ilość materiału nie jest tutaj zaletą — to są niezrozumiałe śmieci. Nie komunikują one nikomu niczego wartościowego. Nie da się z nimi nic zrobić.  Nie. Jeśli chcesz, to się Ty zastanawiaj. Przegrzebywanie śmieci w poszukiwaniu wartościowych fragmentów to praca. Za pracę się płaci.  Użyłbym innego — bardziej wulgarnego — porównania.  To porozmawiaj o tym ze swoim lekarzem. Jeśli takiego nie masz — to znajdź, i to szybko. Poza tym, nawet jeśli o czymś piszesz, to nie musisz tego zamieszczać publicznie, a już zwłaszcza w miejscach kompletnie do tego nie przeznaczonych, jak na przykład to forum.  To jest tak dobrze schowana w tych śmieciach, że nikt jej nie odnajdzie. Co więcej, szukanie jej byłoby pracą, a za pracę się płaci.  To by było na tyle. Przeczytaj to uważnie — zwłaszcza fragment napisany pogrubionym tekstem — i spróbuj wyciągnąć wnioski. Żeby Ci było łatwiej — i żeby nam wszystkim oszczędzić przegrzebywania się przez kolejne śmieci — zablokuję Ci możliwość publikowania nowych treści na tydzień. Po tym czasie — jeśli faktycznie zrozumiałeś, o co chodzi — możesz, jak najbardziej, wrócić. Tylko że musisz przestrzegać regulaminu, w szczególności nie śmiecić. Jeśli będziesz uporczywie śmiecił, dostaniesz kolejną — permanentną — blokadę.;"
Procesy stochastyczne. Numeryka. Optymalizacje. Symulacje. Sieci neuronowe. Ai ogólnie.;
"Trochę niejasne to pytanie. Typowe rozwiązanie ML to z grubsza jakaś tam pajplajna do danych, gdzie zbiera się, replikuje i dostosowuje (np. przeskalowuje rozmiary obrazków) dane, dzieli training set, test set, validation set i jakaś maszynka statystyczna, która tych danych się nauczy i później będzie wykonywać jakąś tam klasyfikację, czy przewidywanie. Praktycznie zawsze trzeba zaimplementować część dostarczającą dane, zdefiniować jak te dane mają wyglądać na wejściu do ML.  Później musisz wybrać algorytm wg. którego działa ML i jest tego od groma - regresje, sieci neuronowe, maszyny wektorowe, drzewa decyzyjne itd. Jak wybierzesz już algorytm którego chcesz używać, to musisz też zdefiniować jego parametry, np. topologię sieci neuronowej. Musisz też dobrać sposób jej uczenia - liczba powtórzeń, wielkość pojedynczej próbki itd. Mniej-więcej tyle trzeba zrobić podczas implementacji jakiegoś rozwiązania ML. Resztę są w stanie ogarnąć narzędzia z frameworku. Zaletą najpowszechniejszego aktualnie DNN jest uniwersalność - czyli niezależnie od tego czy robisz rozpoznawanie obrazu, głosu, AI do gry w kółko i krzyżyk, czy przetwarzanie języka naturalnego, jesteś w stanie użyć tego samego zestawu narzędzi, zmieniając jedynie ""obudowę"" DNN i dostosowując jej topologię do zadania. Czy w ""normalnej pracy"" robi się coś więcej? Raczej nie Jeżeli masz taki Tensor Flow, w którym definiujesz liczbę i typy warstw, ładujesz dane i działa, to po co masz marnować czas na implementację tego ręcznie. W celach edukacyjnych / rozrywkowych zaimplementowałem podstawowy zestaw algorytmów ML schodząc do macierzy, pochodnych i MatLaba. Generalnie bardzo pouczająca zabawa, dająca dużo zrozumienia jak to działa.;"
"Kontynuując  dyskusję  o kruczkach  w javie  na rekrutacjach i korpo  projektach. Nie patrzcie na cały  świat  przez swój  pryzmat. IT to nie tylko klepanie  systemów  bankowych. Jest wiele dziedzin takich jak finanse, uczenie maszynowe, medycyna itp gdzie programowanie  jest tylko narzędziem, a hajs  trzepie  się  dzięki  wiedzy dziedzinowej albo matematycznej. I w przypadku rekrutacji na tego typu stanowisko, bardziej ceni się wiedzę  albo informatyczne/dziedzinową/matematyczne  fundamenty, niż  znajomość konkretnych  frameworkow  i języków. Bo ich da się  szybko douczyć, a matematyki  albo wieloletniego  doświadczenia  w danej dziedzinie w dwa tygodnie nie nadrobisz. Wiem że  trudno przechodzi to przez gardło  ludziom którzy  całe  życie  poświęcili  na czytanie dokumentacji  springa, ale tak po prostu  jest.;"
"Każda sytuacja, kiedy zakłamuje się rzeczywistość w imię wyznawanej ideologii jest głupia. Dlatego uważam, że nie ma sensu udawać, że uczenie maszynowe nie wyłapuje w we wprowadzonych danych różnic i nierówności pomiędzy luźmi, ew. zakładać z góry że wszelkie nieprawomyślne rezultaty są wynikiem błędnej metodologii badawczej. Inną sprawą natomiast jest to, jakie decyzje podejmujemy w oparciu o tak zebrane dane. Z biznesowego punktu widzenia statystyki pokazują np., że firmy ubezpieczeniowe powinny nakładać na młodych mężczyzn wyższe OC niż na kobiety. W kontekście społecznym takie karanie kogoś za posiadaną płeć jest po prostu niedopuszczalne.;"
"Od teorii. Niestety. Na początek warto pochylić się nad tematami związanymi z uczeniem maszynowym: systemy uczące, klastry, algorytmy, sieci neuronowe, logika rozmyta, szeroko pojęte ""data mining"". Bez tego zabawa w kodowanie czegokolwiek będzie tylko strzelaniem w ciemno.  Tu zależy od Ciebie, ale polecam celować w coś dobrego do kodowania logiki, bez wdawania się w szczegóły. Czyli coś, co pozwoli Ci skupić się na samym uczeniu maszynowym i implementowaniu Twoich pomysłów. Dobry jest tutaj Python, niektórzy wykorzystują Javę.  To zależy od firmy, bo uczenie maszynowe (zwłaszcza komercyjnie) jest tematem mega szerokim. Więc jedno ogłoszenie może być zupełnie inne niż pozostałe. Myślę, że właśnie na ogłoszeniach powinieneś opierać swoje ""must have"";"
"Wszystko wiem co robię, mogę ci nawet rozrysować. Rozumiem, że za każdym razem, gdy chcesz użyć k-means to piszesz swoją własną implementację k-means, tak? A jak piszesz dokumentację to najpierw implementujesz sobie swój własny edytor tekstu? W ogóle to w którym miejscu jest ci potrzebna algebra do napisania k-means? Każdy programista Ci to napisze, nawet po bootcampie.  a to co to jest:  algebra?  co?  Po co wymyślać na nowo koło po raz setny? Uczenie maszynowe to nie jest matematyka teoretyczna tylko używanie dokonań matematyki teoretycznej do rozwiązywanie rzeczywistych problemów byznesowych.;"
"weź nie słuchaj tych teoretyków co wiedzę o uczeniu maszynowym biorą z internetu. W realnym przemyśle np. w wizji komputerowej albo nlp albo sektorze finansowym, bardzo istotne są umiejętności programistyczne, bo często sama część modelowa nie jest jakimś problemem. Bierzesz po prostu najlepszy dostępny obecnie model do rozwiązania danego problemu. Oczywiście matematyka jest istotna, ale informatyka też. W codziennej pracy typu uczenie maszynowe, 99% czasu będziesz robił rzeczy informatyczne, a nie statystyczne/AI. Co nie zmienia faktu, że te statystyczne/AI też trzeba ogarniać. No i dlatego to taki ciężki kawałek chleba. Bo trzeba ogarniać na sensownymi poziomie dwie duże dziedziny wiedzy.;"
"AI już pisze kod w Javie: https://www.dobreprogramy.pl/Sztuczna-inteligencja-juz-dzis-pisze-kod-za-programiste-czy-jutro-go-zastapi,News,87796.html niedługo programiści w ogóle przestaną być potrzebni;"
"Odpowiem w komentarzu: Dzieki za post, mimo wszystko rynek w krk chyba jest dosc ubogi jesli chodzi o ML Ja mam 6 lat doświadczenia w androidzie, pracowałem w Monachium, San Francisco oraz Amsterdamie. Mówię Ci - nie idź w androida. Uczenie maszynowe FTW. Co do ubogiego rynku - co ja mógł bym zrobić? Pójść na uczelnie AGH/UJ na wydział sztucznej inteligencji i zapytać czy nie potrzebują pomocy w projektach / grantach. Pewnie potrzebują bo a) mało osób ma wiedzę żeby to robić b) ludzie myślą że uczelnia nie ma perspektyw więc mało ludzi zostaje ( to też nie jest prawda, jak pisałem magisterkę promotor chciał mnie wysłać do Sydney na grant). Porobisz pół roku, potem praca zdalna sama będzie do Ciebie pisać - na linked inie ustawisz machine learner w san francisco - robotę znajdziesz na 85% ;);"
"Jak nie możesz się zdecydować, to możesz jeszcze iść na Matematykę Komputerową na UJ lub na Informatykę Analityczną jeżeli jesteś mocny, a na magisterce na Informatykę o specjalności Nauczanie Maszynowe, koło naukowe też jest. Podejrzewam, że na tej specjalności jest więcej przedmiotów związanych z tematem niż na AGH, ale koło naukowe BIT oferuje naprawdę dużo, oprócz sekcji AI ma Idea Factory, którego odpowiednika UJ raczej nie ma, a jest bardzo przydatna.;"
"C# zagarnie wielka część rynku, jako język na wszystkie platformy po aktualizacji Listopad '20, Java nadal będzie bardzo popularna bo w 5 lat jej się nie zastąpi, dodatkowo zagarnie większość funkcjonalności od Scali czy Kotlina, Mam nadzieję, że hype na Pythona ucichnie bo już niedobrze sie od niego robi, Mam nadzieję, że ludzkość wymyśli cos lepszego od JS, np zaczną używać Darta(?),;"
"Powstanie kolejny język na JVM, o którym się będzie mówiło, że zastąpi Javę wraz z wyjaśnieniem, dlaczego Kotlin tego nie zrobił. Java 8 dalej będzie używana do chwalenia się, że w firmie są najnowsze technologie.;"
"Języki dynamicznie typowane ku uciesze gawiedzi zostaną zakazane, a programiści JavaScript i Pythona będą przymusowo reedukowani. Przeglądarki przestaną wspierać JavaScript. Windows 10 będzie rzeczywiście ostatnim możliwym do kupienia windowsem. Kolejne wersje systemu będą tylko i wyłącznie dostępne razem z instancją w chmurze. Nie będzie można już kupić komputera PC ani smartfona, wszyscy będą używać różnej wielkości terminali służących do logowania do chmury, gdzie gracze będę mieli silną instancję do grania, a madki kubełek S3 do trzymania zdjęć bombelków. Wszelkie dokumenty oraz karty płatnicze wyjdą z użycia, wszyscy ludzie będą musieli sobie wszczepić czip, który będzie służył do płacenia i identyfikacji. Powstaną ruchy i organizacje anty technologiczne, które będą propagowały życie w zgodzie z naturą z dala od technologii cyfrowej i cywilizacji. Prace fizyczne będą wykonywać wyłącznie roboty, a coraz doskonalsze AI wyprze ludzi z większości obecnie znanych zawodów. Wszyscy pozostali pracownicy przejdą na tzw. cyfrowy nomadyzm i będą pracować zdalnie, z nielicznych odległych miejsc na Ziemi, które będą się jeszcze nadawały do życia. Elon Musk ostatecznie dowiedzie, że ludzie żyją w symulacji i nawiąże kontakt ze Stwórcą.;"
"Założenie jest błędne. Algorytmy, które piszą algorytmy istnieją od dawna. Już w okolicach 2008 dostępne były liczne generatory (czyli algorytmy), które po określeniu przez użytkownika danych w postaci prostego schematu bazy danych, generowały działający program. Tego typu rozwiązania rynku nie zawojowały, ale są rozwijane do dzisiaj i mają swoją niszę. Problemem jest to, że ciężko w ten sposób zaimplementować nawet proste wymagania wynikające poza typowego CRUD'a — a to tylko czasem spełnia oczekiwania klienta. Dodatkowo, taka sieć neuronowa to w sumie algorytm, który potrafi modyfikować sam siebie. Prawidłowe pytanie powinno brzmieć. Co się stanie, kiedy powstanie algorytm, zdolny do analizy wymagań/potrzeb drugiego człowieka i stworzenia na podstawie ich działającego programu oraz do dalszych modyfikacji programu, z uwzględnieniem rozwiązywania konfliktów wymagań i propozycji ich rozwiązania. Zakładamy tutaj, że tym człowiekiem będzie analityk biznesowy, a w późniejszym etapie osoba nietechniczna. Obawiam się jednak, że taka SI będzie w stanie zastąpić każdego z nas, może poza psychologami. Ktoś wspomniał o tym, by przekwalifikować się na piekarza, ale to też kiepski pomysł wypiekanie chleba, mieszanie ciasta, czy jego wyjmowanie z pieca, to wszystko procesy dość łatwe do zautomatyzowania, nawet dziś, tylko niezbyt się to opłaca. Częściowa automatyzacja jednak już i tak nastąpiła w tym zakresie, chociażby w piekarniach supermarketów. Ogólnie uczenie maszynowe rozwinęło się w ostatnich latach, ale bardziej pod kątem dostępności dla szarego developera i możliwościami samych komputerów, niż pod kątem jakiejś wielkiej rewolucji w samych teoriach, które są dość stare. Jednak dzięki temu możliwe jest stworzenie autonomicznych samochodów (tylko czasem kogoś rozjadą, tak samo, jak ludzki kierowca) lub algorytmów pozwalających orzekać jak sędzia (też czasem się pomyli) - więc moim zdaniem jest to wielki sukces. Być może kiedyś stworzymy sztucznego człowieka, ale osobiście wolałbym nie, mam na ten temat zdanie podobne jak Hawking.;"
"Dziękuję wszystkim za odpowiedzi  Czyli nawet najbardziej skomplikowane sieci neuronowe działają w ten sposób, że wyliczają sumę wag dla danego neuronu i obliczają funkcję aktywacji dla niego? Czy algortym wstecznej propagacji jest reukrencyjny? Jeśli sieć ma więcej neuronów w warstwie ukrytej tym bardziej dokładne wyniki będziemy otrzymywać na wyjściu sieci neuronowej?;"
"Wracając do tematu miałbym jeszcze kilka pytań :D  Czy obecnie robotyka również wykrozystuje sieci neuronowe czy roboty wykorzystują inny rodzaj SI? Co przedstawia pojedyńczy neuron w warstwie ukrytej w sieci neuronowej? Zakładając, że dana sieć neuronowa posiada jedną warstwę ukrytą i sieć ta służy do rozpoznawania tego czy dany człowiek jest osobą dorosłą czy dzieckiem. Co oznacza wtedy pojedyńczy neuron w warstwie ukrytej? Sprawdza np. wzrost człowieka? Dobrze to rozumiem? Kiedy sieć neuronowa jest rekurencyjna? Wtedy, gdy korzysta np. z algorytmu wstecznej propagacji? Bo rozumiem to tak, że wtedy w sieci pojawiają się sprzężenia zwrotne przez co sieć staje się rekurencyjna.;"
"Witam, mam do was trochę nie standardowe pytanie. Za rok będę zdawał maturę z rozszerzonej inf, mat i ang i zastanawiam się na jakie studia by się tu wybrać. Od razu mówię, że mam już trochę doświadczenia w programowania w językach takich jak c, c++, c#, python, i nie idę po to żeby mnie nauczyli programować (co i tak chyba jest nie możliwe). Wybieram się głównie po to aby mieć okazje wziąć udział w kołach naukowych, poznać trochę ludzi no i może douczyć się typowej algorytmiki. Obecnie mam już możliwość brać udział w kole naukowym uczelni patronackiej mojej szkoły i jest to dość ciekawe, aczkolwiek chciałbym może coś więcej w przyszłości. Do tego nie szczególnie przepadam za uczeniem się i nie chciałbym trafić do jakiegoś ciężkiego wydziału. Stąd i pytanie do was: czy znacie / polecacie jakąś uczelnie wyższą z ciekawą informatyką (ciekawe projekty, wykłady) z szerokim zakresem materiału zakrawającym m.i. o sieci neuronowe i ogólnie pojęte AI i może z elementami elektroniki / robotyki, aczkolwiek o nie wygórowanych wymaganiach, no i z ciekawymi kołami naukowymi gdzie realnie można się rozwijać i coś tworzyć, a wykładowcy w miarę byli przyjaźni :D. No i żeby znaleźć ciekawe osoby o podobnych zainteresowaniach, aczkolwiek ich pewnie można znaleźć na każdej nieco lepszej uczelni. Wiem że może całkiem sporo chciałbym ale mam nadzieje że jednak coś znajdzie się z tych wszystkich szkół. No a obecnie myślałem nad UWr, ewentualnie AGH aczkolwiek nie wiem czy uda mi się tam dostać, ale proponujcie wszytko, chętnie wysłucham opinii. Pozdrawiam.;"
"wpisz na pracuj.pl frazę uczenie maszynowe w warszawie lub we wrocławiu, a następnie zastanów się czy chcesz emigrować za chlebem. Przykładowo w warszawie 23 oferty pracy, z czego realne AI to 15. Data science w warszawie chce się zajmować lub studiuję parę tysięcy osób.;"
"Na razie to chyba wszystko idzie w stronę tego, że JS wyprze wszystkie języki we wszystkich zastosowaniach. Są nawet wariaci, co pchają to na mikrokontrolery.;"
"Zależy co rozumiesz przez przyszłościowy: Jeżeli chcesz iść w stronę stronek to na pewno must have: html/css/js. Z tym że musisz ogarnąć do tego jakiś framwork, który zapewne umrze: ember lub vue lub angular lub react. Za 2-3 lata będzie pewnie kolejny nowy modny framework oparty na JS. Jeżeli chcesz iść w stronę backendu to Java, C# na pewno będą jeszcze rządziły kilkanaście lat. Jest jeszcze RoR i PHP ale ciężko stwierdzić, co z nimi będzie. W stronę bardziej nowoczesnych to na pewno Scala, Rust, Go. Python też ma swoją przyszłość. ale raczej nie jako webówka typu Django, tylko uczenie maszynowe/AI itd. No i oczywiście z niskopoziomowych to C też raczej nie umrze.;"
"Witam. Na zlecenie klienta mam do zrobienia prognozowanie zamówień. Nie bardzo wiem jak to ugryźć. Jedyne co wiem to robiąc to statystyką mogę dostać mało wiarygodne dane. Nie jestem pewien, czy w ogóle jestem w stanie coś takiego zasymulować, aby otrzymać dane w miarę rzeczywiste. Czy to już uczenie maszynowe?;"
"Nie jest, nawet ten zaczynał się od tego ze na uczenie maszynowe patrzy sie teraz innaczej(co to uczenie maszynowe?) 5 lat temu najwięksi profesorowie na każdej uczelni na świecie mówili że sieci neuronowe są fajne ale mało praktyczne ito bardziej ciekawostka. A teraz ogrywają normalne AI w szachy i podmieniają twarze aktorek w filmach.;"
"Na studiach prowadząca opowiadała nam, że teraz rodzice zmuszają małe dzieci do programowania, dzieciaki tego nienawidzą, nie wiedzą po co to robią, ale rodzice ich zmuszą bo są dobre pieniądze :) Gnije bo automatyzacja nie dotyczy jedynie kasjerek, kierowców, prawników czy lekarzy (systemy eksperckie lepiej diagnozują choroby niż ludzie) ale też programistów. Mamy coraz lepsze narzędzia i o ile nie zastąpi nas raczej AI to będzie mocno wspomagać, już teraz w takim django czy dot necie można klepać projekty w ekstremalnym tempie w dużo mniejszych zespołach niż dawniej. A co będzie za 20 lat jak te gówniarze zaleją rynek swoimi wymuszonymi umiejętnościami?  Ten rynek [CIACH!] to jest pewne. Kto się załapie i będzie miał ładne CV ten się załapie a reszta będzie za miskę ryżu pracowała, z resztą zarobki programistów na zachodzie nie są już tak wcale zajebiste;"
Podpowiem zależy od Ciebie popisz sobie trochę w pythonie spróbuj zrozumieć sieci neuronowe i DL i zobaczysz czy warto BTW. co do pracy na pewno dużo ciężej niż jako normalny programista;
"Hej, generalnie temat rzeka... Na pewno warto znać dobrze jakiś program/środowisko do obróbki danych... może to być Excel (czasem można ogarnąć temat w 5 minut zamiast pisać jakiś kod od zera)... jakieś wyspecjalizowane BI... może być Python + możliwości obróbki danych w Pandzie... może też być program R, sporo w nim można zrobić... i jeszcze coś by się znalazło... Druga sprawa, to umiejętność wdrażania się w Nowe Technologie... Teraz modne są na Zachodzie tematy związane z Big Data (technologie równoległe rozwijane np. w oparciu o Hadoop i MapReduce)... Niekoniecznie trzeba wchodzić w szczegóły (to znaczy jak to działa), ale warto np. znać Sparka, aby wiedzieć, jak obrabiać większe zbiory danych wykorzystując równoległe przetwarzanie danych (trudne to bardzo nie jest)... Jak już będziesz miał umiejętności wyżej wymienione, to warto wtedy głębiej wejście w ML... ale to jest taaak szeroka tematyka, że ciężko ją objąć w paru zdaniach... Spark ma wbudowane dużo ciekawych objektów ML... Ponadto warto znać podstawy AI: Sieci Neuronowe, Alg Genetyczne... Warto wiedzieć także co to są systemy rozmyte i systemy regułowe...;"
"Python i PHP to najłatwiejsze języki programowania na rynku. Potem Ruby i JavaScript. Python w bogatszych krajach zyskuje na popularności. Jak w Polsce zastąpi wysłużony Pascal na uczelniach, wtedy dopiero boom na Pythona ruszy w tym kraju. Już teraz developerzy przechodzą z PHP na Pythona z frameworkiem Django. Taki reddit napisany jest w Pythonie i frameworku Pylons/Pyramid. Jak najbardziej Python może być głównym językiem. Kiedyś czytałem taką książkę bodajże 10 lat temu, gdzie zawodowi programiści przewidywali, że takie języki jak Python i Ruby to przyszłość programowania. Wraz z rosnącą mocą obliczeniową komputerów. I mieli rację, Python jest w NASA, Cern, AI, Robotyce, Motoryzacji, Web, Mobile. https://www.tensorflow.org https://www.dobreprogramy.pl/Python-zyskuje-popularnosc-w-bogatych-krajach-szybciej,News,83062.html;"
"Ale ja nie napisałem, że Python ma zastąpić Jave, tylko że jest w różnych dziedzinach. Być może Jave zastąpi Scala, Kotlin, a może całkowicie zrezygnują z takiego Monolita na rzecz nowoczesnych mikroserwisów. Zachód wyznacza trendy w IT. Modularność zdobywa popularność, patrz Java 9, Plasma, QT 5.;"
"Cały ""deep learning"" : konwolucyjne sieci neuronowe, sieci generatywne + uczenie ze wzmocnieniem + nowe algorytmy typowo klasyfikacyjne (xgboost itp.) + postęp technologiczny + rozwój w poszczególnych dziedzinach (np. opencv w image processingu, czy word2vec/glove w nlp). Tak, postęp jest bardzo duży.;"
"Ta rozmowa jest wyrwana z kontekstu, ale ja nie widzę jakiejś konkretnej argumentacji. Co maja webowe aplikacje do tego, że ""samouk bez wiedzy nie zrobi data mining czy sieci neuronowe""? Co mają wspólnego aplikacje webowe z samouctwem (tylko samoucy robią apki webowe) i dlaczego niemożność zrobienia data miningu przez samouka będzie przyczyną upadku apek webowych? Nie rozumiem tego komentarza, jest on całkowicie nielogiczny. Nie wspominam już o tym, że jest tam zawarty stereotyp, że samouk nie może mieć dużej wiedzy o programowaniu - ale to nawet nieważne, bo w tym komentarzu nie chodzi o nic. (chyba, że widząc cały kontekst wypowiedzi można go zrozumieć jakoś).;"
"@somekind: Tak, miejsca w rankingach mówią o sukcesach naukowych i technologicznych danego kraju, bo są robione na podstawie ilości publikacji naukowych i ich cytowań. Polscy profesorkowie w większości mają bardzo niewiele publikacji, które mają niewiele cytowań, bo nic nie wnoszą do nauki. Jedyny wydział z sukcesami to jest MIMUW, tylko że polska ma 36 mln mieszkańców, a na MIMUW studiuje pareset osób. W cywilizowanych krajach masz takich wydziałów dosłownie dziesiątki. Polacy cieszą się jak jakiś jeden mistrzu wygra jakiś algorytmiczny konkurs, a na zachodzie nikt na takiego gościa nie zwróciłby uwagi, bo tam takich mistrzów wygrywających konkursy międzynarodowe w różnych dziedzinach jest tysiące. Jeśli chodzi o papierek polskich uczelni, to nikt o nich na  świecie nie słyszał, jeśli jakiś specjalista z polski rzeczywiście jest zatrudniany na jakimś stanowisku to wyłącznie wtedy kiedy akurat w jakimś zachodnim kraju takich specjalistów brakuje(lekarze, kiedyś programiści) + jest dobry. W sytuacji gdzie nie ma zapotrzebowania na dany zawód, czyli nie wiem np. finanse, papierki polskich uczelni są bezwartościowe i możesz conajwyżej iść na zmywak. Poziom polskiego przemysłu jest wprost propocjonalny do poziomu polskich politechnik i ich osiągnięć naukowych. Miejsc w przemyśle jest w polsce dużo, ale to albo montownie, albo polski mało innowacyjny i mało dochodowy przemysł. Nawet polskie IT to głównie mało innowacyjne i nudne rzeczy. Schemat jest mniej więcej taki: 2010 - początek rewolucji AI, tworzą się pierwsze startupy w dolinie krzemowej, chinach itp., polacy klepią CRUDY i stronki dla Janusza w javie 2011,2012,2013,2014,2015,2016 - startupy związane z AI zaczynają się przekształcać w firmy, a nawer korporacje, generują czasem miliardowe zyski, polacy klepią CRUDY i stronki dla Janusza w javie 2017- polacy orientują się że istnieje coś takiego jak AI i uczenie maszynowe, dalej klepią CRUDY i stronki dla Janusza w javie 2018- pierwsze polskie startupy AI, które powielają głównie pomysły z USA z 2011 2019-polskie firmy wprowadzają innowację AI poprzez kupowanie za grube miliony gotowych systemów opartych na AI(typy IMB watson, amazon web service),  mimo że jakby orientowały się co się wokół nich dzieje to mogłyby już w 2011 zatrudnić paru programistów i matematyków i zbudować taki sam system 100 razy taniej. A teraz obiektywny wskaźnik rozwoju polskiego ""przemysłu"": http://www.economywatch.com/companies/forbes-list/poland.html największa polska spółka przemysła 785 miejsce na świecie. To jak myślisz, jak polskie spółki przemysłowe są tak nisko, to przez co jest nadmuchiwane polskie PKB ?;"
"Przede wszystkim staraj się robić to co lubić, znaleźć może nie pasję, ale żeby to choć trochę Cię interesowało. Ja wciąż po 16 latach pisania kodów/prowadzenia projektów/supportu/robienia architektury w IT wciąż lubię to i potrafię wydać parę stówek na techniczne książki nie z wyrachowania tylko z czystej przyjemności, żeby coś poznać. Jeżeli nie będzie Cię to interesowało to nie ma szans, żebyś był kreatywny. Ugrzęźniesz w jakiejś kupie za 6 brutto :) Co do IT - praca jak praca. Mityczne 15k jest osiągalne po pewnym czasie. Ekonomiście poleciłbym karierę analityka biznesowego lub może analityka danych (budowa modeli, niekoniecznie sieci neuronowe czy AI), twarde IT może Cię odrzucić. Aczkolwiek nie mieszkam w Twojej głowie - nie wiem co Ci się spodoba.;"
"Rozwiązania określane mianem ""machine learning"" są znane już od wielu lat, tylko teraz zrobił się na to hype. Generalnie, sprowadza się to, do przetworzenia pewnych danych, dla uzyskania jakiegoś efektu lub klasyfikacji tych danych. Np. detekcja obiektów na zdjęciach lub filmach, klasyfikacja obrazów, wykrywanie wzorców, wykrywanie podejrzanych zachowań w transakcjach bankowych, autonomiczne pojazdy, etc. Wykorzystuje się do tego m.in. sieci neuronowe, na temat których miałem zajęcia na studiach kilka lat temu zanim nadeszła ""moda"" na ""machine learning"". Osobnym tematem jest też obróbka i analiza tych danych, gdzie wykorzystuje się soft wspomagający wizualizację informacji. Natomiast samo ""Big Data"", to po prostu buzzword, który może określać dużą ilość danych do przetworzenia. Chyba nie ma definicji, kiedy data zaczyna się robić ""big"". Co do samych ofert, to widziałem w Polsce oferty na stanowiska typu ""Big Data Developer"", ""Machine Learning Developer"" i inne tym podobne. Nawet poznałem osoby, które zajmują się tym w pracy. Nie ma tych ofert wiele. Ponadto zauważ, że niektóre oferty nie mają w nazwie lub opisie ""Big Data"" i ""Machine Learning"", ale w gruncie rzeczy, ludzie się tym zajmują.;"
"Studia na których nie ma całej otoczki matematycznej i fizycznej, elektrycznej, elektronicznej, metod numerycznych, optyki, miernictwa, techniki cyfrowej, transmisji sygnałów itp., a ich miejsce wskakuje więcej architektury oprogramowania, czym jest DDD, wzorce projektowe, projektowanie API itp., oprócz tego np. git, nauka o UI/UX, uczenie maszynowe, inteligentne domy, Rasberry Pi, gamedev, testowanie oprogramowania. Dlaczego nie istnieje w Polsce taki twór, po ukończeniu którego posiadałoby się tytuł inżyniera? Wizja takich studiów to tylko moje marzenie i nie mam na celu przekonywania nikogo do swoich racji i upierania się, że jakiś materiał jest wszystkim potrzebny, a innym niepotrzebny. Piszę tylko o tym czego sam chciałbym się uczyć i co chciałbym wiedzieć, umieć.;"
1)Studia bez otoczki matematycznej 2)Uczenie maszynowe Wybierz jedno...;
"To trzeba w końcu zrobić! Czarną listę tematów, tak jak na elektrodzie! Moje propozycje:  Mam 30 lat i chciałbym zostać programistą. Czy mam jeszcze szansę? Czy programistów zastąpi AI? Czy studia są potrzebne? Co minimalnie trzeba ogarnąć żeby dostać pracę w IT? Czemu odrzucają moje CV? Przecież dałem link do Githuba Jaki język wybrać na początek? Ten temat  Jakby się uprzeć to można by zatrudnić jakiś machine learning do detekcji tego typu tematów a potem wklejać standardową odpowiedź, albo jeszcze lepiej, wstawić całą opracowaną wcześniej przez specjalistów dyskusję!;"
"Witam wszystkich bardzo serdecznie, Jako że wielkimi krokami zbliża się do mnie czas wyborów studiów, chciałbym o pomoc w tej kwestii poradzić się kogoś nieco bardziej doświadczonego niż głosu własnego ""rozsądku"". Jeszcze do niedawna byłem pewien że postawię na pentestera (lubię w wolnym czasie pobawić się w CTFy), jednak martwi mnie pobieżność informacji na ten temat w polskim internecie. Nie wiem jak wygląda sama praca oraz jaka jest ogólna sytuacja na rodzimym rynku, czy są miejsca pracy, jak duża jest konkurencyjność, zarobki itp. Do tego oglądając jedną z prezentacji George Hotza, skrzydła ucięły mi słowa: ""The goal of a security engineer should be to put themselves out of a job"". Trochę przegrana wojna.. Alternatywę stanowi uczenie maszynowe którym interesowałem się już od dawna (choć przestałem się tym zajmować to wciąż śledzę nowości z tego świata). Przestałem jednak o tym myśleć na poważnie gdyż usłyszałem że 80% pracy polega na samym porządkowaniu danych. Rzeczywiście tak jest? Moje główne zainteresowanie wynika z ciekawości do rezultatów, kombinowania i samego ogromu możliwości jakie dostarcza AI. W dodatku ta droga zdaje się być znacznie bardziej przyszłościowa, szczególnie jeśli myślałbym o założeniu własnej działalności. Wiem że wybiegam w tym miejscu trochę za bardzo w przyszłość, jednak im dłużej myślę o wyborze tym więcej pojawia się różnych ""ale"". Choć mam też świadomość tego, że same studia mnie za wiele nie nauczą, to chciałbym studiować już coś co ""mniej więcej"" chcę robić. Są tu osoby mające doświadczenie w jednym bądź drugim zawodzie? Można też uzyskać sugestie co do uczelni? Do tej pory myślałem o PW, kierunek cyberbezpieczeństwo.;"
"Witam, Czy jest ktoś w stanie pomóc mi w modyfikacji kodu. Głowna zasada gry mówi, że statki nie mogą dotykać się bokami ani krawędziami. Tutaj jej brakuje. Niestety programowanie nie jest moją silną stroną. Bardzo proszę o pomoc. (function() {  // Global Constants var CONST = {}; CONST.AVAILABLE_SHIPS = ['carrier', 'battleship', 'destroyer', 'submarine', 'patrolboat']; // You are player 0 and the computer is player 1 // The virtual player is used for generating temporary ships // for calculating the probability heatmap CONST.HUMAN_PLAYER = 0; CONST.COMPUTER_PLAYER = 1; CONST.VIRTUAL_PLAYER = 2; // Possible values for the parameter `type` (string) CONST.CSS_TYPE_EMPTY = 'empty'; CONST.CSS_TYPE_SHIP = 'ship'; CONST.CSS_TYPE_MISS = 'miss'; CONST.CSS_TYPE_HIT = 'hit'; CONST.CSS_TYPE_SUNK = 'sunk'; // Grid code: CONST.TYPE_EMPTY = 0; // 0 = water (empty) CONST.TYPE_SHIP = 1; // 1 = undamaged ship CONST.TYPE_MISS = 2; // 2 = water with a cannonball in it (missed shot) CONST.TYPE_HIT = 3; // 3 = damaged ship (hit shot) CONST.TYPE_SUNK = 4; // 4 = sunk ship  // TODO: Utwórz ten lepszy kod OO. CONST.AVAILABLE_SHIPS powinna być tablicą // obiektów, a nie dwóch równoległych tablic. Albo lepiej // rozwiązaniem byłoby zapisanie ""USED"" i ""UNUSED"" jako właściwości // pojedynczy obiekt statku. // Te liczby odpowiadają CONST.AVAILABLE_SHIPS //1) ""pancernik"" 2) ""niszczyciel"" 3) ""okręt podwodny"" 4) ""patrolboat"" // Ta zmienna jest używana tylko wtedy, gdy DEBUG_MODE === true. Game.usedShips = [CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED]; CONST.USED = 1; CONST.UNUSED = 0;  // Game Statistics function Stats(){ 	this.shotsTaken = 0; 	this.shotsHit = 0; 	this.totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 	this.totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 	this.gamesPlayed = parseInt(localStorage.getItem('gamesPlayed'), 10) || 0; 	this.gamesWon = parseInt(localStorage.getItem('gamesWon'), 10) || 0; 	this.uuid = localStorage.getItem('uuid') || this.createUUID(); 	if (DEBUG_MODE) { 		this.skipCurrentGame = true; 	} } Stats.prototype.incrementShots = function() { 	this.shotsTaken++; }; Stats.prototype.hitShot = function() { 	this.shotsHit++; }; Stats.prototype.wonGame = function() { 	this.gamesPlayed++; 	this.gamesWon++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'win', this.uuid); 	} }; Stats.prototype.lostGame = function() { 	this.gamesPlayed++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'lose', this.uuid); 	} }; // Zapisuje statystyki gry do lokalnego magazynu, a także przesyła je, gdzie użytkownik umieścił // ich statki do Google Analytics, aby w przyszłości mogłem zobaczyć // które komórki ludzkie są nieproporcjonalnie nastawione do umieszczania statków. Stats.prototype.syncStats = function() { 	if(!this.skipCurrentGame) { 		var totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 		totalShots += this.shotsTaken; 		var totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 		totalHits += this.shotsHit; 		localStorage.setItem('totalShots', totalShots); 		localStorage.setItem('totalHits', totalHits); 		localStorage.setItem('gamesPlayed', this.gamesPlayed); 		localStorage.setItem('gamesWon', this.gamesWon); 		localStorage.setItem('uuid', this.uuid); 	} else { 		this.skipCurrentGame = false; 	} 	 	var stringifiedGrid = ''; 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			stringifiedGrid += '(' + x + ',' + y + '):' + mainGame.humanGrid.cells[x][y] + ';\n'; 		} 	}  	if (!DEBUG_MODE) { 		ga('send', 'event', 'humanGrid', stringifiedGrid, this.uuid); 	} }; // Aktualizuje pasek boczny z aktualnymi statystykami Stats.prototype.updateStatsSidebar = function() { 	var elWinPercent = document.getElementById('stats-wins'); 	var elAccuracy = document.getElementById('stats-accuracy'); 	elWinPercent.innerHTML = this.gamesWon + "" of "" + this.gamesPlayed; 	elAccuracy.innerHTML = Math.round((100 * this.totalHits / this.totalShots) || 0) + ""%""; }; // Zresetuj wszystkie statystyczne statystyki gry do zera. Nie zresetuj uuid. Stats.prototype.resetStats = function(e) { // Pomiń statystyki śledzenia do końca bieżącej gry lub innego // odsetek dokładności będzie niewłaściwy (ponieważ śledzisz // trafienia, które nie zaczęły się od początku gry) 	Game.stats.skipCurrentGame = true; 	localStorage.setItem('totalShots', 0); 	localStorage.setItem('totalHits', 0); 	localStorage.setItem('gamesPlayed', 0); 	localStorage.setItem('gamesWon', 0); 	localStorage.setItem('showTutorial', true); 	Game.stats.shotsTaken = 0; 	Game.stats.shotsHit = 0; 	Game.stats.totalShots = 0; 	Game.stats.totalHits = 0; 	Game.stats.gamesPlayed = 0; 	Game.stats.gamesWon = 0; 	Game.stats.updateStatsSidebar(); }; Stats.prototype.createUUID = function(len, radix) { 	var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), 	uuid = [], i; 	radix = radix || chars.length;  	if (len) { 		// Compact form 		for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix]; 	} else { 		// rfc4122, version 4 form 		var r;  		// rfc4122 requires these characters 		uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; 		uuid[14] = '4';  		// Fill in random data.  At i==19 set the high bits of clock sequence as 		// per rfc4122, sec. 4.1.5 		for (i = 0; i < 36; i++) { 			if (!uuid[i]) { 				r = 0 | Math.random()*16; 				uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r]; 			} 		} 	}  	return uuid.join(''); };  // Obiekt menedżera gier // Konstruktor function Game(size) { 	Game.size = size; 	this.shotsTaken = 0; 	this.createGrid(); 	this.init(); } Game.size = 10; // Domyślny rozmiar siatki to 10x10 Game.gameOver = false; // Sprawdza, czy gra jest wygrywana, a jeśli tak, ponownie zainicjuje grę Game.prototype.checkIfWon = function() { 	if (this.computerFleet.allShipsSunk()) { 		alert('brawo!'); 		Game.gameOver = true; 		Game.stats.wonGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} else if (this.humanFleet.allShipsSunk()) { 		alert('srobuj ponownie'); 		Game.gameOver = true; 		Game.stats.lostGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} }; // strzela do docelowego gracza w siatce. // Zwraca {int} Constants.TYPE: Co odkryto Game.prototype.shoot = function(x, y, targetPlayer) { 	var targetGrid; 	var targetFleet; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		targetGrid = this.humanGrid; 		targetFleet = this.humanFleet; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		targetGrid = this.computerGrid; 		targetFleet = this.computerFleet; 	} else { 		// Should never be called 		console.log("".................""); 	}  	if (targetGrid.isDamagedShip(x, y)) { 		return null; 	} else if (targetGrid.isMiss(x, y)) { 		return null; 	} else if (targetGrid.isUndamagedShip(x, y)) { // zaktualizować planszę / siatkę 		targetGrid.updateCell(x, y, 'hit', targetPlayer); // WAŻNE: Ta funkcja musi być nazwana _after_ aktualizacją komórki do ""trafienia"" // ponieważ zastąpi klasę CSS ""zatopioną"", jeśli okaże się, że statek został zatopiony 		targetFleet.findShipByCoords(x, y).incrementDamage(); // increase the damage 		this.checkIfWon(); 		return CONST.TYPE_HIT; 	} else { 		targetGrid.updateCell(x, y, 'miss', targetPlayer); 		this.checkIfWon(); 		return CONST.TYPE_MISS; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdej z 100 komórek siatki Game.prototype.shootListener = function(e) { 	var self = e.target.self; 	// Extract coordinates from event listener 	var x = parseInt(e.target.getAttribute('data-x'), 10); 	var y = parseInt(e.target.getAttribute('data-y'), 10); 	var result = null; 	if (self.readyToPlay) { 		result = self.shoot(x, y, CONST.COMPUTER_PLAYER);  		// Remove the tutorial arrow 		if (gameTutorial.showTutorial) { 			gameTutorial.nextStep(); 		} 	}  	if (result !== null && !Game.gameOver) { 		Game.stats.incrementShots(); 		if (result === CONST.TYPE_HIT) { 			Game.stats.hitShot(); 		} // Kula AI wystrzeliwa, gdy gracz kliknie komórkę, której jeszcze nie kliknąłeś 		self.robot.shoot(); 	} else { 		Game.gameOver = false; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdym ze statków w rosterze Game.prototype.rosterListener = function(e) { 	var self = e.target.self; 	// Usuń wszystkie klasy ""umieszczania"" z listy flot 	var roster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < roster.length; i++) { 		var classes = roster[i].getAttribute('class') || ''; 		classes = classes.replace('placing', ''); 		roster[i].setAttribute('class', classes); 	}  	// Move the highlight to the next step 	if (gameTutorial.currentStep === 1) { 		gameTutorial.nextStep(); 	} 	 	// Set the class of the target ship to 'placing' 	Game.placeShipType = e.target.getAttribute('id'); 	document.getElementById(Game.placeShipType).setAttribute('class', 'placing'); 	Game.placeShipDirection = parseInt(document.getElementById('rotate-button').getAttribute('data-direction'), 10); 	self.placingOnGrid = true; }; // Tworzy detektory zdarzeń kliknięcia na siatce ludzkiego gracza, aby obsługiwać // umieszczenie statku po wybraniu przez użytkownika nazwy statku Game.prototype.placementListener = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		// Extract coordinates from event listener 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		 	// Nie wkręcaj kierunku, jeśli użytkownik próbuje ponownie umieścić. 		var successful = self.humanFleet.placeShip(x, y, Game.placeShipDirection, Game.placeShipType); 		if (successful) { 		// Sporządzono umieszczenie tego statku 			self.endPlacing(Game.placeShipType);  		// Usuń strzałkę pomocniczą 			if (gameTutorial.currentStep === 2) { 				gameTutorial.nextStep(); 			}  			self.placingOnGrid = false; 			if (self.areAllShipsPlaced()) { 				var el = document.getElementById('rotate-button'); 				el.addEventListener(transitionEndEventName(),(function(){ 					el.setAttribute('class', 'hidden'); 					if (gameTutorial.showTutorial) { 						document.getElementById('start-game').setAttribute('class', 'highlight'); 					} else { 						document.getElementById('start-game').removeAttribute('class');	 					} 				}),false); 				el.setAttribute('class', 'invisible'); 			} 		} 	} }; // Tworzy zdarzenia obsługi zdarzeń mouseover, które obsługują mouseover na // siatka ludzkiego gracza narysuje statek fantomowy, co oznacza, że użytkownik // można tam umieścić statek Game.prototype.placementMouseover = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		var classes; 		var fleetRoster = self.humanFleet.fleetRoster;  		for (var i = 0; i < fleetRoster.length; i++) { 			var shipType = fleetRoster[i].type;  			if (Game.placeShipType === shipType && 				fleetRoster[i].isLegal(x, y, Game.placeShipDirection)) { 				// Virtual ship 				fleetRoster[i].create(x, y, Game.placeShipDirection, true); 				Game.placeShipCoords = fleetRoster[i].getAllShipCells();  				for (var j = 0; j < Game.placeShipCoords.length; j++) { 					var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 					classes = el.getAttribute('class'); 					// Check if the substring ' grid-ship' already exists to avoid adding it twice 					if (classes.indexOf(' grid-ship') < 0) { 						classes += ' grid-ship'; 						el.setAttribute('class', classes); 					} 				} 			} 		} 	} }; // Tworzy zdarzenia detekcji zdarzeń myszy, które nie rysują statku fantomowego // na siatce ludzkiego gracza, gdy użytkownik przechodzi przez inną komórkę Game.prototype.placementMouseout = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		for (var j = 0; j < Game.placeShipCoords.length; j++) { 			var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 			classes = el.getAttribute('class'); // Sprawdź, czy substrat 'grid-ship' już istnieje, aby uniknąć dodawania go dwukrotnie 			if (classes.indexOf(' grid-ship') > -1) { 				classes = classes.replace(' grid-ship', ''); 				el.setAttribute('class', classes); 			} 		} 	} }; // Click handler for the Rotate Ship button Game.prototype.toggleRotation = function(e) { 	// Toggle rotation direction 	var direction = parseInt(e.target.getAttribute('data-direction'), 10); 	if (direction === Ship.DIRECTION_VERTICAL) { 		e.target.setAttribute('data-direction', '1'); 		Game.placeShipDirection = Ship.DIRECTION_HORIZONTAL; 	} else if (direction === Ship.DIRECTION_HORIZONTAL) { 		e.target.setAttribute('data-direction', '0'); 		Game.placeShipDirection = Ship.DIRECTION_VERTICAL; 	} }; // Click handler for the Start Game button Game.prototype.startGame = function(e) { 	var self = e.target.self; 	var el = document.getElementById('roster-sidebar'); 	var fn = function() {el.setAttribute('class', 'hidden');}; 	el.addEventListener(transitionEndEventName(),fn,false); 	el.setAttribute('class', 'invisible'); 	self.readyToPlay = true; // Rozwiń krok samouczek 	if (gameTutorial.currentStep === 3) { 		gameTutorial.nextStep(); 	} 	el.removeEventListener(transitionEndEventName(),fn,false); }; // Kliknij przycisk obsługi programu Restart Game Game.prototype.restartGame = function(e) { 	e.target.removeEventListener(e.type, arguments.callee); 	var self = e.target.self; 	document.getElementById('restart-sidebar').setAttribute('class', 'hidden'); 	self.resetFogOfWar(); 	self.init(); }; // Funkcja debugowania służąca do umieszczania wszystkich statków i dopiero początek Game.prototype.placeRandomly = function(e){ 	e.target.removeEventListener(e.type, arguments.callee); 	e.target.self.humanFleet.placeShipsRandomly(); 	e.target.self.readyToPlay = true; 	document.getElementById('roster-sidebar').setAttribute('class', 'hidden'); 	this.setAttribute('class', 'hidden'); }; // Zakończenie umieszczania obecnego statku Game.prototype.endPlacing = function(shipType) { 	document.getElementById(shipType).setAttribute('class', 'placed'); 	 	// Mark the ship as 'used' 	Game.usedShips[CONST.AVAILABLE_SHIPS.indexOf(shipType)] = CONST.USED;  	// Wipe out the variable when you're done with it 	Game.placeShipDirection = null; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; }; // Sprawdza, czy wszystkie statki są umieszczone // Zwraca boolean Game.prototype.areAllShipsPlaced = function() { 	var playerRoster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < playerRoster.length; i++) { 		if (playerRoster[i].getAttribute('class') === 'placed') { 			continue; 		} else { 			return false; 		} 	} 	// Reset temporary variables 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; 	return true; }; // Zresetuje mgłę wojny Game.prototype.resetFogOfWar = function() { 	for (var i = 0; i < Game.size; i++) { 		for (var j = 0; j < Game.size; j++) { 			this.humanGrid.updateCell(i, j, 'empty', CONST.HUMAN_PLAYER); 			this.computerGrid.updateCell(i, j, 'empty', CONST.COMPUTER_PLAYER); 		} 	} 	// Reset all values to indicate the ships are ready to be placed again 	Game.usedShips = Game.usedShips.map(function(){return CONST.UNUSED;}); }; // Zresetowanie stylu CSS na pasku bocznym Game.prototype.resetRosterSidebar = function() { 	var els = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < els.length; i++) { 		els[i].removeAttribute('class'); 	}  	if (gameTutorial.showTutorial) { 		gameTutorial.nextStep(); 	} else { 		document.getElementById('roster-sidebar').removeAttribute('class'); 	} 	document.getElementById('rotate-button').removeAttribute('class'); 	document.getElementById('start-game').setAttribute('class', 'hidden'); 	if (DEBUG_MODE) { 		document.getElementById('place-randomly').removeAttribute('class'); 	} }; Game.prototype.showRestartSidebar = function() { 	var sidebar = document.getElementById('restart-sidebar'); 	sidebar.setAttribute('class', 'highlight');  	// Deregister listeners 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].removeEventListener('click', this.shootListener, false); 	} 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].removeEventListener('click', this.rosterListener, false); 	}  	var restartButton = document.getElementById('restart-game'); 	restartButton.addEventListener('click', this.restartGame, false); 	restartButton.self = this; }; // Tworzy divy HTML dla siatki dla obu graczy Game.prototype.createGrid = function() { 	var gridDiv = document.querySelectorAll('.grid'); 	for (var grid = 0; grid < gridDiv.length; grid++) { 		gridDiv[grid].removeChild(gridDiv[grid].querySelector('.no-js')); // Removes the no-js warning 		for (var i = 0; i < Game.size; i++) { 			for (var j = 0; j < Game.size; j++) { 				var el = document.createElement('div'); 				el.setAttribute('data-x', i); 				el.setAttribute('data-y', j); 				el.setAttribute('class', 'grid-cell grid-cell-' + i + '-' + j); 				gridDiv[grid].appendChild(el); 			} 		} 	} }; // inicjuje grę. Również resetuje grę, jeśli została wcześniej zainicjowana Game.prototype.init = function() { 	this.humanGrid = new Grid(Game.size); 	this.computerGrid = new Grid(Game.size); 	this.humanFleet = new Fleet(this.humanGrid, CONST.HUMAN_PLAYER); 	this.computerFleet = new Fleet(this.computerGrid, CONST.COMPUTER_PLAYER);  	this.robot = new AI(this); 	Game.stats = new Stats(); 	Game.stats.updateStatsSidebar();  	// Reset game variables 	this.shotsTaken = 0; 	this.readyToPlay = false; 	this.placingOnGrid = false; 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = [];  	this.resetRosterSidebar();  // Dodaj metodę kliknięć dla metody Grid.shoot () dla wszystkich komórek // Tylko dodaj tego słuchacza do sieci komputerowej 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].self = this; 		computerCells[j].addEventListener('click', this.shootListener, false); 	} // Dodaj listener do listy	 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].self = this; 		playerRoster[i].addEventListener('click', this.rosterListener, false); 	}  // Dodawanie detektora kliknięć do siatki ludzkiego gracza podczas wprowadzania 	var humanCells = document.querySelector('.human-player').childNodes; 	for (var k = 0; k < humanCells.length; k++) { 		humanCells[k].self = this; 		humanCells[k].addEventListener('click', this.placementListener, false); 		humanCells[k].addEventListener('mouseover', this.placementMouseover, false); 		humanCells[k].addEventListener('mouseout', this.placementMouseout, false); 	}  	var rotateButton = document.getElementById('rotate-button'); 	rotateButton.addEventListener('click', this.toggleRotation, false); 	var startButton = document.getElementById('start-game'); 	startButton.self = this; 	startButton.addEventListener('click', this.startGame, false); 	var resetButton = document.getElementById('reset-stats'); 	resetButton.addEventListener('click', Game.stats.resetStats, false); 	var randomButton = document.getElementById('place-randomly'); 	randomButton.self = this; 	randomButton.addEventListener('click', this.placeRandomly, false); 	this.computerFleet.placeShipsRandomly(); };  // Grid object // Constructor function Grid(size) { 	this.size = size; 	this.cells = []; 	this.init(); }  // Inicjowanie i wypełnienie siatki Grid.prototype.init = function() { 	for (var x = 0; x < this.size; x++) { 		var row = []; 		this.cells[x] = row; 		for (var y = 0; y < this.size; y++) { 			row.push(CONST.TYPE_EMPTY); 		} 	} };  // Aktualizuje klasę CSS komórki w oparciu o typ przekazany Grid.prototype.updateCell = function(x, y, type, targetPlayer) { 	var player; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		player = 'human-player'; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		player = 'computer-player'; 	} else { 		// Should never be called 		console.log(""There was an error trying to find the correct player's grid""); 	}  	switch (type) { 		case CONST.CSS_TYPE_EMPTY: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 		case CONST.CSS_TYPE_SHIP: 			this.cells[x+1][y+1] = CONST.TYPE_SHIP; 			break;  		case CONST.CSS_TYPE_MISS: 			this.cells[x][y] = CONST.TYPE_MISS; 			break; 		case CONST.CSS_TYPE_HIT: 			this.cells[x][y] = CONST.TYPE_HIT; 			break; 		case CONST.CSS_TYPE_SUNK: 			this.cells[x][y] = CONST.TYPE_SUNK; 			break; 		default: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 	} 	var classes = ['grid-cell', 'grid-cell-' + x + '-' + y, 'grid-' + type]; 	document.querySelector('.' + player + ' .grid-cell-' + x + '-' + y).setAttribute('class', classes.join(' ')); }; // Sprawdza, czy komórka zawiera nieuszkodzony statek // Zwraca boolean Grid.prototype.isUndamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_SHIP; }; // Sprawdza, czy strzał został pominięty. To jest równoważne // sprawdzenie, czy komórka zawiera kulę armatnią // Zwraca boolean Grid.prototype.isMiss = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_MISS; }; // Sprawdza, czy komórka zawiera uszkodzony statek, // uderzysz lub zatapia. // Zwraca boolean Grid.prototype.isDamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_HIT || this.cells[x][y] === CONST.TYPE_SUNK; };  // obiekt Floty // Ten obiekt służy do śledzenia portfela statków gracza // Konstruktor function Fleet(playerGrid, player) { 	this.numShips = CONST.AVAILABLE_SHIPS.length; 	this.playerGrid = playerGrid; 	this.player = player; 	this.fleetRoster = []; 	this.populate(); } // Posiada flotę Fleet.prototype.populate = function() { 	for (var i = 0; i < this.numShips; i++) { 		// loop over the ship types when numShips > Constants.AVAILABLE_SHIPS.length 		var j = i % CONST.AVAILABLE_SHIPS.length; 		this.fleetRoster.push(new Ship(CONST.AVAILABLE_SHIPS[j], this.playerGrid, this.player)); 	} }; // umieszcza statek i zwraca, czy miejsce docelowe jest skuteczne // Zwraca boolean Fleet.prototype.placeShip = function(x, y, direction, shipType) { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var shipTypes = this.fleetRoster[i].type;  		if (shipType === shipTypes && 			this.fleetRoster[i].isLegal(x, y, direction)) { 			this.fleetRoster[i].create(x, y, direction, false); 			shipCoords = this.fleetRoster[i].getAllShipCells();  			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 			} 			return true; 		} 	} 	return false; }; // Miejsca statków są losowo umieszczane na pokładzie // TODO: Unikaj umieszczania statków zbyt blisko siebie Fleet.prototype.placeShipsRandomly = function() { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var illegalPlacement = true; 	 		// Prevents the random placement of already placed ships 		if(this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] === CONST.USED) { 			continue; 		} 		while (illegalPlacement) { 			var randomX = Math.floor(10*Math.random()); 			var randomY = Math.floor(10*Math.random()); 			var randomDirection = Math.floor(2*Math.random()); 			 			if (this.fleetRoster[i].isLegal(randomX, randomY, randomDirection)) { 				this.fleetRoster[i].create(randomX, randomY, randomDirection, false); 				shipCoords = this.fleetRoster[i].getAllShipCells(); 				illegalPlacement = false; 			} else { 				continue; 			} 		} 		if (this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] !== CONST.USED) { 			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 				Game.usedShips[i] = CONST.USED; 			} 		} 	} }; // Znajduje statek według lokalizacji // Zwraca obiekt statku znajdujący się pod adresem (x, y) // Jeśli żaden statek nie istnieje w (x, y), zamiast tego zwraca null Fleet.prototype.findShipByCoords = function(x, y) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var currentShip = this.fleetRoster[i]; 		if (currentShip.direction === Ship.DIRECTION_VERTICAL) { 			if (y === currentShip.yPosition && 				x >= currentShip.xPosition && 				x < currentShip.xPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} else { 			if (x === currentShip.xPosition && 				y >= currentShip.yPosition && 				y < currentShip.yPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} 	} 	return null; }; // Znajduje statek według jego typu // Param shipType to ciąg znaków // Zwraca obiekt statku, który jest typu typu shipType // Jeśli żaden statek nie istnieje, zwraca null. Fleet.prototype.findShipByType = function(shipType) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		if (this.fleetRoster[i].type === shipType) { 			return this.fleetRoster[i]; 		} 	} 	return null; }; // Checks to see if all ships have been sunk // Returns boolean Fleet.prototype.allShipsSunk = function() { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		// If one or more ships are not sunk, then the sentence ""all ships are sunk"" is false. 		if (this.fleetRoster[i].sunk === false) { 			return false; 		} 	} 	return true; };  // Ship object // Constructor function Ship(type, playerGrid, player) { 	this.damage = 0; 	this.type = type; 	this.playerGrid = playerGrid; 	this.player = player;  	switch (this.type) { 		case CONST.AVAILABLE_SHIPS[0]: 			this.shipLength = 5; 			break; 		case CONST.AVAILABLE_SHIPS[1]: 			this.shipLength = 4; 			break; 		case CONST.AVAILABLE_SHIPS[2]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[3]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[4]: 			this.shipLength = 2; 			break; 		default: 			this.shipLength = 3; 			break; 	} 	this.maxDamage = this.shipLength; 	this.sunk = false; } // Sprawdza, czy umieszczenie statku jest legalne // Zwraca boolean Ship.prototype.isLegal = function(x, y, direction) { 	// najpierw sprawdź czy statek znajduje się w sieci ... 	if (this.withinBounds(x, y, direction))  	{ 	// ... sprawdź, czy nie koliduje z innym statkiem 		for (var i = 0; i < this.shipLength; i++)  		{ 			if (direction === Ship.DIRECTION_VERTICAL)  			{ 				if (this.playerGrid.cells[x + i][y] === CONST.TYPE_SHIP || 				this.playerGrid.cells[x - i][y] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_MISS || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_SUNK)  				 					{ 					return false; 				     } 			}  			else  			{ 				if (this.playerGrid.cells[x][y + i] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_MISS || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_SUNK)  					{ 					return false;}				 			}			 		}		 		return true; 	}  	else  		return false;	 }; // Sprawdza, czy statek znajduje się w granicach sieci // Zwraca boolean //statek mieści się w granicach gry Ship.prototype.withinBounds = function(x, y, direction) { 	if (direction === Ship.DIRECTION_VERTICAL) { 		return x + this.shipLength <= Game.size; 	} else { 		return y + this.shipLength <= Game.size; 	} }; // zwiększa licznik uszkodzeń statku // Zwraca statek Ship.prototype.incrementDamage = function() { 	this.damage++; 	if (this.isSunk()) { 		this.sinkShip(false); // Sinks the ship 	} }; // Sprawdza, czy statek jest zatopiony // Zwraca boolean Ship.prototype.isSunk = function() { 	return this.damage >= this.maxDamage; }; // Zanurzysz statek Ship.prototype.sinkShip = function(virtual) { 	this.damage = this.maxDamage; // Force the damage to exceed max damage 	this.sunk = true;  // Uczynienie klasy CSS zatopionej, ale tylko wtedy, gdy statek nie jest wirtualny 	if (!virtual) { 		var allCells = this.getAllShipCells(); 		for (var i = 0; i < this.shipLength; i++) { 			this.playerGrid.updateCell(allCells[i].x, allCells[i].y, 'sunk', this.player); 		} 	} };  Ship.prototype.getAllShipCells = function() { 	var resultObject = []; 	for (var i = 0; i < this.shipLength; i++) { 		if (this.direction === Ship.DIRECTION_VERTICAL) { 			resultObject[i] = {'x': this.xPosition + i, 'y': this.yPosition}; 		} else { 			resultObject[i] = {'x': this.xPosition, 'y': this.yPosition + i}; 		} 	} 	return resultObject; }; // Inicjuje statek o podanym współrzędnym i kierunku (łożyska). // Jeśli statek zostanie uznany za ""wirtualny"", wtedy statek zostanie zainicjowany // jego współrzędne, ale NIE umieszcza się na siatce. Ship.prototype.create = function(x, y, direction, virtual) { 	// This function assumes that you've already checked that the placement is legal 	this.xPosition = x; 	this.yPosition = y; 	this.direction = direction;  	// Jeśli statek jest wirtualny, nie dodaj go do sieci. 	if (!virtual) { 		for (var i = 0; i < this.shipLength; i++) { 			if (this.direction === Ship.DIRECTION_VERTICAL) { 				this.playerGrid.cells[x + i][y] = CONST.TYPE_SHIP; 			} else { 				this.playerGrid.cells[x][y + i] = CONST.TYPE_SHIP; 			} 		} 	} 	 }; // direction === 0 when the ship is facing north/south // direction === 1 when the ship is facing east/west Ship.DIRECTION_VERTICAL = 0; Ship.DIRECTION_HORIZONTAL = 1;  // Tutorial Object // Constructor function Tutorial() { 	this.currentStep = 0; 	// Check if 'showTutorial' is initialized, if it's uninitialized, set it to true. 	this.showTutorial = localStorage.getItem('showTutorial') !== 'false'; } // Advances the tutorial to the next step Tutorial.prototype.nextStep = function() { 	var humanGrid = document.querySelector('.human-player'); 	var computerGrid = document.querySelector('.computer-player'); 	switch (this.currentStep) { 		case 0: 			document.getElementById('roster-sidebar').setAttribute('class', 'highlight'); 			document.getElementById('step1').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 1: 			document.getElementById('roster-sidebar').removeAttribute('class'); 			document.getElementById('step1').removeAttribute('class'); 			humanGrid.setAttribute('class', humanGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step2').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 2: 			document.getElementById('step2').removeAttribute('class'); 			var humanClasses = humanGrid.getAttribute('class'); 			humanClasses = humanClasses.replace(' highlight', ''); 			humanGrid.setAttribute('class', humanClasses); 			this.currentStep++; 			break; 		case 3: 			computerGrid.setAttribute('class', computerGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step3').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 4: 			var computerClasses = computerGrid.getAttribute('class'); 			document.getElementById('step3').removeAttribute('class'); 			computerClasses = computerClasses.replace(' highlight', ''); 			computerGrid.setAttribute('class', computerClasses); 			document.getElementById('step4').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 5: 			document.getElementById('step4').removeAttribute('class'); 			this.currentStep = 6; 			this.showTutorial = false; 			localStorage.setItem('showTutorial', false); 			break; 		default: 			break; 	} };  // AI Object // Optimal battleship-playing AI // Constructor function AI(gameObject) { 	this.gameObject = gameObject; 	this.virtualGrid = new Grid(Game.size); 	this.virtualFleet = new Fleet(this.virtualGrid, CONST.VIRTUAL_PLAYER);  	this.probGrid = []; // Probability Grid 	this.initProbs(); 	this.updateProbs(); } AI.PROB_WEIGHT = 5000; // arbitrarily big number // jaka masa ma przynieść komórki wysokiego prawdopodobieństwa książki otwartej AI.OPEN_HIGH_MIN = 20; AI.OPEN_HIGH_MAX = 30; // ile wagi daje się średnim prawdopodobieństwom książki otwarcia AI.OPEN_MED_MIN = 15; AI.OPEN_MED_MAX = 25; // how much weight to give to the opening book's low probability cells AI.OPEN_LOW_MIN = 10; AI.OPEN_LOW_MAX = 20; // Amount of randomness when selecting between cells of equal probability AI.RANDOMNESS = 0.1; // AI's opening book. // This is the pattern of the first cells for the AI to target AI.OPENINGS = [ 	{'x': 7, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 2, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 7, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 2, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 5, 'y': 5, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 4, 'y': 4, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	// {'x': 9, 'y': 5, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 0, 'y': 4, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 5, 'y': 9, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 4, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 0, 'y': 8, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 1, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 8, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 9, 'y': 1, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 9, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 0, 'y': 0, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)} ]; // Zrzuca siatkę w oparciu o maksymalne prawdopodobieństwo i strzela do komórki // ma największe prawdopodobieństwo zawarcia statku AI.prototype.shoot = function() { 	var maxProbability = 0; 	var maxProbCoords; 	var maxProbs = []; 	 	// Add the AI's opening book to the probability grid 	for (var i = 0; i < AI.OPENINGS.length; i++) { 		var cell = AI.OPENINGS[i]; 		if (this.probGrid[cell.x][cell.y] !== 0) { 			this.probGrid[cell.x][cell.y] += cell.weight; 		} 	}  	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			if (this.probGrid[x][y] > maxProbability) { 				maxProbability = this.probGrid[x][y]; 				maxProbs = [{'x': x, 'y': y}]; // Replace the array 			} else if (this.probGrid[x][y] === maxProbability) { 				maxProbs.push({'x': x, 'y': y}); 			} 		} 	}  	maxProbCoords = Math.random() < AI.RANDOMNESS ? 	maxProbs[Math.floor(Math.random() * maxProbs.length)] : 	maxProbs[0];  	var result = this.gameObject.shoot(maxProbCoords.x, maxProbCoords.y, CONST.HUMAN_PLAYER); 	 	// If the game ends, the next lines need to be skipped. 	if (Game.gameOver) { 		Game.gameOver = false; 		return; 	}  	this.virtualGrid.cells[maxProbCoords.x][maxProbCoords.y] = result;  	// If you hit a ship, check to make sure if you've sunk it. 	if (result === CONST.TYPE_HIT) { 		var humanShip = this.findHumanShip(maxProbCoords.x, maxProbCoords.y); 		if (humanShip.isSunk()) { 			// Remove any ships from the roster that have been sunk 			var shipTypes = []; 			for (var k = 0; k < this.virtualFleet.fleetRoster.length; k++) { 				shipTypes.push(this.virtualFleet.fleetRoster[k].type); 			} 			var index = shipTypes.indexOf(humanShip.type); 			this.virtualFleet.fleetRoster.splice(index, 1);  			// Update the virtual grid with the sunk ship's cells 			var shipCells = humanShip.getAllShipCells(); 			for (var _i = 0; _i < shipCells.length; _i++) { 				this.virtualGrid.cells[shipCells[_i].x][shipCells[_i].y] = CONST.TYPE_SUNK; 			} 		} 	} 	// Update probability grid after each shot 	this.updateProbs(); }; // Update the probability grid AI.prototype.updateProbs = function() { 	var roster = this.virtualFleet.fleetRoster; 	var coords; 	this.resetProbs(); // Prawdopodobieństwa nie są znormalizowane, aby pasowały do przedziału [0, 1] // dlatego, że jesteśmy zainteresowani maksymalną wartością.  // Działa to poprzez dopasowanie każdego statku do każdej komórki w każdej orientacji // W każdej komórce, tym bardziej legalnym sposobem, w jaki statek może przechodzić przez niego, tym bardziej // prawdopodobnie komórka ma zawierać statek. // Komórki otaczające znane ""trafienia"" otrzymują arbitralnie duże prawdopodobieństwo // tak, że AI próbuje całkowicie zatopić statek przed przejściem dalej.  // TODO: Pomyśl o bardziej efektywnej implementacji 	for (var k = 0; k < roster.length; k++) { 		for (var x = 0; x < Game.size; x++) { 			for (var y = 0; y < Game.size; y++) { 				if (roster[k].isLegal(x, y, Ship.DIRECTION_VERTICAL)) { 					roster[k].create(x, y, Ship.DIRECTION_VERTICAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var i = 0; i < coords.length; i++) { 							this.probGrid[coords[i].x][coords[i].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _i = 0; _i < coords.length; _i++) { 							this.probGrid[coords[_i].x][coords[_i].y]++; 						} 					} 				} 				if (roster[k].isLegal(x, y, Ship.DIRECTION_HORIZONTAL)) { 					roster[k].create(x, y, Ship.DIRECTION_HORIZONTAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var j = 0; j < coords.length; j++) { 							this.probGrid[coords[j].x][coords[j].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _j = 0; _j < coords.length; _j++) { 							this.probGrid[coords[_j].x][coords[_j].y]++; 						} 					} 				}  				// Set hit cells to probability zero so the AI doesn't 				// target cells that are already hit 				if (this.virtualGrid.cells[x][y] === CONST.TYPE_HIT) { 					this.probGrid[x][y] = 0; 				} 			} 		} 	} }; // Initializes the probability grid for targeting AI.prototype.initProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		var row = []; 		this.probGrid[x] = row; 		for (var y = 0; y < Game.size; y++) { 			row.push(0); 		} 	} }; // Resets the probability grid to all 0. AI.prototype.resetProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			this.probGrid[x][y] = 0; 		} 	} }; AI.prototype.metagame = function() { 	// Inputs: 	// Proximity of hit cells to edge 	// Proximity of hit cells to each other 	// Edit the probability grid by multiplying each cell with a new probability weight (e.g. 0.4, or 3). Set this as a CONST and make 1-CONST the inverse for decreasing, or 2*CONST for increasing }; // Finds a human ship by coordinates // Returns Ship AI.prototype.findHumanShip = function(x, y) { 	return this.gameObject.humanFleet.findShipByCoords(x, y); }; // Checks whether or not a given ship's cells passes through // any cell that is hit. // Returns boolean AI.prototype.passesThroughHitCell = function(shipCells) { 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			return true; 		} 	} 	return false; }; // Gives the number of hit cells the ships passes through. The more // cells this is, the more probable the ship exists in those coordinates // Returns int AI.prototype.numHitCellsCovered = function(shipCells) { 	var cells = 0; 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			cells++; 		} 	} 	return cells; };  // Global constant only initialized once var gameTutorial = new Tutorial();  // Start the game var mainGame = new Game(10);  })();  // Array.prototype.indexOf workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf if (!Array.prototype.indexOf) { 	Array.prototype.indexOf = function (searchElement, fromIndex) {  		var k;  		// 1. Let O be the result of calling ToObject passing 		//    the this value as the argument. 		if (this === null || this === undefined) { 			throw new TypeError('""this"" is null or not defined'); 		}  		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get 		//    internal method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If len is 0, return -1. 		if (len === 0) { 			return -1; 		}  		// 5. If argument fromIndex was passed let n be 		//    ToInteger(fromIndex); else let n be 0. 		var n = +fromIndex || 0;  		if (Math.abs(n) === Infinity) { 			n = 0; 		}  		// 6. If n >= len, return -1. 		if (n >= len) { 			return -1; 		}  		// 7. If n >= 0, then Let k be n. 		// 8. Else, n<0, Let k be len - abs(n). 		//    If k is less than 0, then let k be 0. 		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);  		// 9. Repeat, while k < len 		while (k < len) { 			var kValue; 			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the 			//    HasProperty internal method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			//    i.  Let elementK be the result of calling the Get 			//        internal method of O with the argument ToString(k). 			//   ii.  Let same be the result of applying the 			//        Strict Equality Comparison Algorithm to 			//        searchElement and elementK. 			//  iii.  If same is true, return k. 			if (k in O && O[k] === searchElement) { 				return k; 			} 			k++; 		} 		return -1; 	}; }  // Array.prototype.map workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map // Production steps of ECMA-262, Edition 5, 15.4.4.19 // Reference: http://es5.github.io/#x15.4.4.19 if (!Array.prototype.map) {  	Array.prototype.map = function(callback, thisArg) {  		var T, A, k;  		if (this == null) { 			throw new TypeError("" this is null or not defined""); 		}  		// 1. Let O be the result of calling ToObject passing the |this|  		//    value as the argument. 		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get internal  		//    method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If IsCallable(callback) is false, throw a TypeError exception. 		// See: http://es5.github.com/#x9.11 		if (typeof callback !== ""function"") { 			throw new TypeError(callback + "" is not a function""); 		}  		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined. 		if (arguments.length > 1) { 			T = thisArg; 		}  		// 6. Let A be a new array created as if by the expression new Array(len)  		//    where Array is the standard built-in constructor with that name and  		//    len is the value of len. 		A = new Array(len);  		// 7. Let k be 0 		k = 0;  		// 8. Repeat, while k < len 		while (k < len) {  			var kValue, mappedValue;  			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the HasProperty internal  			//    method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			if (k in O) {  				// i. Let kValue be the result of calling the Get internal  				//    method of O with argument Pk. 				kValue = O[k];  				// ii. Let mappedValue be the result of calling the Call internal  				//     method of callback with T as the this value and argument  				//     list containing kValue, k, and O. 				mappedValue = callback.call(T, kValue, k, O);  				// iii. Call the DefineOwnProperty internal method of A with arguments 				// Pk, Property Descriptor  				// { Value: mappedValue,  				//   Writable: true,  				//   Enumerable: true,  				//   Configurable: true }, 				// and false.  				// In browsers that support Object.defineProperty, use the following: 				// Object.defineProperty(A, k, {  				//   value: mappedValue,  				//   writable: true,  				//   enumerable: true,  				//   configurable: true  				// });  				// For best browser support, use the following: 				A[k] = mappedValue; 			} 			// d. Increase k by 1. 			k++; 		}  		// 9. return A 		return A; 	}; }  // Browser compatability workaround for transition end event names. // From modernizr: http://stackoverflow.com/a/9090128 function transitionEndEventName() { 	var i, 		undefined, 		el = document.createElement('div'), 		transitions = { 			'transition':'transitionend', 			'OTransition':'otransitionend',  // oTransitionEnd in very old Opera 			'MozTransition':'transitionend', 			'WebkitTransition':'webkitTransitionEnd' 		};  	for (i in transitions) { 		if (transitions.hasOwnProperty(i) && el.style[i] !== undefined) { 			return transitions[i]; 		} 	} }  // Returns a random number between min (inclusive) and max (exclusive) function getRandom(min, max) { 	return Math.random() * (max - min) + min; }  // Toggles on or off DEBUG_MODE function setDebug(val) { 	DEBUG_MODE = val; 	localStorage.setItem('DEBUG_MODE', val); 	localStorage.setItem('showTutorial', 'false'); 	window.location.reload(); };"
"NIE CHCE abyście podawali mi tutaj opis tych stanowisk. Chodzi mi o różnice w zakresie sposobu myślenia o problemie i metodyki jego rozwiązywania. Wydaje mi się, że Full Stack Dev tworzy elementy(funkcjonalności) i składa je w całość. Natomiast Machine Learning szuka pewnych (nie)prawidłowości w bazie danych, następnie je optymalizuje poprzez np. sieci neuronowe. Idąc tym tokiem myślenia, Machine Learning to praca polegająca na statystycznej analizie i optymalizacji danych. Natomiast Full Stack Dev to tworzenie, doskonalenie i rozwój funkcjonalości. Co według Ciebie jest ciekawsze? bardziej pochłaniające i dlaczego? Data Science czy Full Stack Dev? precyzując, bierzemy pod uwagę pracę w tworzeniu i rozwoju fukcjonalności, a nie w utrzymanie.;"
"poza tym ta definicja co podal op jest zupelnie od czapy. Zalezy w jaką  specjalizacje pojdziesz (nlp,finanse,image processing, biostatystyka) to twoja praca będzie  zupełnie  inaczej wyglada. I to  są  różnice  rzędu  takiego jak pomiedzy front end developerem a embedded C developerem. Dodatkowo sieci neuronowe i szerzej uczenie maszynowe to tylko część  wiedzy jaką  trzeba posiadac w danej  branzy.;"
"Hmm software dev, pracuje jako data scientist w image processingu i my nie zajmujemy się danymi  wcale, od tego jest osobny zespol  (bardziej nazwałbym ich programistami niz data scientistami). Nasze codziennie obowiazki to uczenie maszynowe, statystyla, algorytmila, optymalizacja, continuous integration, języki  to python,czasem c++. Danymi i bazami danych zajmują  się  ""data engineerowie"" albo po prostu programisci. Ja na oczy nie widziałem  sqla ani crawlera sieci.;"
"Mi osobiście się wydaje, że programista to jeden z ostatnich zawodów, w którym maszyna w pełni zastąpi człowieka. To nie jest prosty zawód jak np. kasjer do zastąpienia przez automaty, w którym czynności są proste, jest ich mało oraz się powtarzają.;"
"Ale sądzisz, że liczba tego typu kierunków cokolwiek zmieni na rynku? Ja myślę, że jak długo programowanie będzie oparte na tworzeniu, rozumianym jako wymyślanie rozwiązań takie szkoły jak i wszelkiego rodzaju cud kursy czy szkolenia nic nie zmienią. Większość rozwiązań jest szyta na wymiar, a za szablony odpowiadają frameworki. oferty dotyczące takie programowania jak ww. zawsze będą dobrze płatne bo tylko malutka część społeczeństwa się do tego nadaje. Natomiast moim zdaniem jest pewne, że stawki dla wordpressów itp. będą maleć wraz z napływem ""przeszkolonego"" narybka. Ciekawi mnie tylko na ile rozwój sztucznej inteligencji może  zachwiać rynek. Na pewno zwiększy liczbę szablonów.;"
"Witam, Potrzebuję pomocy w modyfikacji kodu. Główną zasadą gry w statki jest, brak możliwości stykania się ścianami oraz rogami. Niestety nie mogę wprowadzić tej zmiany w zamieszczonym kodzie. Czy mógłby mi ktoś pomóc (function() {  // Global Constants var CONST = {}; CONST.AVAILABLE_SHIPS = ['carrier', 'battleship', 'destroyer', 'submarine', 'patrolboat']; // You are player 0 and the computer is player 1 // The virtual player is used for generating temporary ships // for calculating the probability heatmap CONST.HUMAN_PLAYER = 0; CONST.COMPUTER_PLAYER = 1; CONST.VIRTUAL_PLAYER = 2; // Possible values for the parameter `type` (string) CONST.CSS_TYPE_EMPTY = 'empty'; CONST.CSS_TYPE_SHIP = 'ship'; CONST.CSS_TYPE_MISS = 'miss'; CONST.CSS_TYPE_HIT = 'hit'; CONST.CSS_TYPE_SUNK = 'sunk'; // Grid code: CONST.TYPE_EMPTY = 0; // 0 = water (empty) CONST.TYPE_SHIP = 1; // 1 = undamaged ship CONST.TYPE_MISS = 2; // 2 = water with a cannonball in it (missed shot) CONST.TYPE_HIT = 3; // 3 = damaged ship (hit shot) CONST.TYPE_SUNK = 4; // 4 = sunk ship  // TODO: Utwórz ten lepszy kod OO. CONST.AVAILABLE_SHIPS powinna być tablicą // obiektów, a nie dwóch równoległych tablic. Albo lepiej // rozwiązaniem byłoby zapisanie ""USED"" i ""UNUSED"" jako właściwości // pojedynczy obiekt statku. // Te liczby odpowiadają CONST.AVAILABLE_SHIPS //1) ""pancernik"" 2) ""niszczyciel"" 3) ""okręt podwodny"" 4) ""patrolboat"" // Ta zmienna jest używana tylko wtedy, gdy DEBUG_MODE === true. Game.usedShips = [CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED]; CONST.USED = 1; CONST.UNUSED = 0;  // Game Statistics function Stats(){ 	this.shotsTaken = 0; 	this.shotsHit = 0; 	this.totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 	this.totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 	this.gamesPlayed = parseInt(localStorage.getItem('gamesPlayed'), 10) || 0; 	this.gamesWon = parseInt(localStorage.getItem('gamesWon'), 10) || 0; 	this.uuid = localStorage.getItem('uuid') || this.createUUID(); 	if (DEBUG_MODE) { 		this.skipCurrentGame = true; 	} } Stats.prototype.incrementShots = function() { 	this.shotsTaken++; }; Stats.prototype.hitShot = function() { 	this.shotsHit++; }; Stats.prototype.wonGame = function() { 	this.gamesPlayed++; 	this.gamesWon++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'win', this.uuid); 	} }; Stats.prototype.lostGame = function() { 	this.gamesPlayed++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'lose', this.uuid); 	} }; // Zapisuje statystyki gry do lokalnego magazynu, a także przesyła je, gdzie użytkownik umieścił // ich statki do Google Analytics, aby w przyszłości mogłem zobaczyć // które komórki ludzkie są nieproporcjonalnie nastawione do umieszczania statków. Stats.prototype.syncStats = function() { 	if(!this.skipCurrentGame) { 		var totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 		totalShots += this.shotsTaken; 		var totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 		totalHits += this.shotsHit; 		localStorage.setItem('totalShots', totalShots); 		localStorage.setItem('totalHits', totalHits); 		localStorage.setItem('gamesPlayed', this.gamesPlayed); 		localStorage.setItem('gamesWon', this.gamesWon); 		localStorage.setItem('uuid', this.uuid); 	} else { 		this.skipCurrentGame = false; 	} 	 	var stringifiedGrid = ''; 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			stringifiedGrid += '(' + x + ',' + y + '):' + mainGame.humanGrid.cells[x][y] + ';\n'; 		} 	}  	if (!DEBUG_MODE) { 		ga('send', 'event', 'humanGrid', stringifiedGrid, this.uuid); 	} }; // Aktualizuje pasek boczny z aktualnymi statystykami Stats.prototype.updateStatsSidebar = function() { 	var elWinPercent = document.getElementById('stats-wins'); 	var elAccuracy = document.getElementById('stats-accuracy'); 	elWinPercent.innerHTML = this.gamesWon + "" of "" + this.gamesPlayed; 	elAccuracy.innerHTML = Math.round((100 * this.totalHits / this.totalShots) || 0) + ""%""; }; // Zresetuj wszystkie statystyczne statystyki gry do zera. Nie zresetuj uuid. Stats.prototype.resetStats = function(e) { // Pomiń statystyki śledzenia do końca bieżącej gry lub innego // odsetek dokładności będzie niewłaściwy (ponieważ śledzisz // trafienia, które nie zaczęły się od początku gry) 	Game.stats.skipCurrentGame = true; 	localStorage.setItem('totalShots', 0); 	localStorage.setItem('totalHits', 0); 	localStorage.setItem('gamesPlayed', 0); 	localStorage.setItem('gamesWon', 0); 	localStorage.setItem('showTutorial', true); 	Game.stats.shotsTaken = 0; 	Game.stats.shotsHit = 0; 	Game.stats.totalShots = 0; 	Game.stats.totalHits = 0; 	Game.stats.gamesPlayed = 0; 	Game.stats.gamesWon = 0; 	Game.stats.updateStatsSidebar(); }; Stats.prototype.createUUID = function(len, radix) { 	var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), 	uuid = [], i; 	radix = radix || chars.length;  	if (len) { 		// Compact form 		for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix]; 	} else { 		// rfc4122, version 4 form 		var r;  		// rfc4122 requires these characters 		uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; 		uuid[14] = '4';  		// Fill in random data.  At i==19 set the high bits of clock sequence as 		// per rfc4122, sec. 4.1.5 		for (i = 0; i < 36; i++) { 			if (!uuid[i]) { 				r = 0 | Math.random()*16; 				uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r]; 			} 		} 	}  	return uuid.join(''); };  // Obiekt menedżera gier // Konstruktor function Game(size) { 	Game.size = size; 	this.shotsTaken = 0; 	this.createGrid(); 	this.init(); } Game.size = 10; // Domyślny rozmiar siatki to 10x10 Game.gameOver = false; // Sprawdza, czy gra jest wygrywana, a jeśli tak, ponownie zainicjuje grę Game.prototype.checkIfWon = function() { 	if (this.computerFleet.allShipsSunk()) { 		alert('brawo!'); 		Game.gameOver = true; 		Game.stats.wonGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} else if (this.humanFleet.allShipsSunk()) { 		alert('srobuj ponownie'); 		Game.gameOver = true; 		Game.stats.lostGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} }; // strzela do docelowego gracza w siatce. // Zwraca {int} Constants.TYPE: Co odkryto Game.prototype.shoot = function(x, y, targetPlayer) { 	var targetGrid; 	var targetFleet; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		targetGrid = this.humanGrid; 		targetFleet = this.humanFleet; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		targetGrid = this.computerGrid; 		targetFleet = this.computerFleet; 	} else { 		// Should never be called 		console.log("".................""); 	}  	if (targetGrid.isDamagedShip(x, y)) { 		return null; 	} else if (targetGrid.isMiss(x, y)) { 		return null; 	} else if (targetGrid.isUndamagedShip(x, y)) { // zaktualizować planszę / siatkę 		targetGrid.updateCell(x, y, 'hit', targetPlayer); // WAŻNE: Ta funkcja musi być nazwana _after_ aktualizacją komórki do ""trafienia"" // ponieważ zastąpi klasę CSS ""zatopioną"", jeśli okaże się, że statek został zatopiony 		targetFleet.findShipByCoords(x, y).incrementDamage(); // increase the damage 		this.checkIfWon(); 		return CONST.TYPE_HIT; 	} else { 		targetGrid.updateCell(x, y, 'miss', targetPlayer); 		this.checkIfWon(); 		return CONST.TYPE_MISS; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdej z 100 komórek siatki Game.prototype.shootListener = function(e) { 	var self = e.target.self; 	// Extract coordinates from event listener 	var x = parseInt(e.target.getAttribute('data-x'), 10); 	var y = parseInt(e.target.getAttribute('data-y'), 10); 	var result = null; 	if (self.readyToPlay) { 		result = self.shoot(x, y, CONST.COMPUTER_PLAYER);  		// Remove the tutorial arrow 		if (gameTutorial.showTutorial) { 			gameTutorial.nextStep(); 		} 	}  	if (result !== null && !Game.gameOver) { 		Game.stats.incrementShots(); 		if (result === CONST.TYPE_HIT) { 			Game.stats.hitShot(); 		} // Kula AI wystrzeliwa, gdy gracz kliknie komórkę, której jeszcze nie kliknąłeś 		self.robot.shoot(); 	} else { 		Game.gameOver = false; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdym ze statków w rosterze Game.prototype.rosterListener = function(e) { 	var self = e.target.self; 	// Usuń wszystkie klasy ""umieszczania"" z listy flot 	var roster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < roster.length; i++) { 		var classes = roster[i].getAttribute('class') || ''; 		classes = classes.replace('placing', ''); 		roster[i].setAttribute('class', classes); 	}  	// Move the highlight to the next step 	if (gameTutorial.currentStep === 1) { 		gameTutorial.nextStep(); 	} 	 	// Set the class of the target ship to 'placing' 	Game.placeShipType = e.target.getAttribute('id'); 	document.getElementById(Game.placeShipType).setAttribute('class', 'placing'); 	Game.placeShipDirection = parseInt(document.getElementById('rotate-button').getAttribute('data-direction'), 10); 	self.placingOnGrid = true; }; // Tworzy detektory zdarzeń kliknięcia na siatce ludzkiego gracza, aby obsługiwać // umieszczenie statku po wybraniu przez użytkownika nazwy statku Game.prototype.placementListener = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		// Extract coordinates from event listener 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		 	// Nie wkręcaj kierunku, jeśli użytkownik próbuje ponownie umieścić. 		var successful = self.humanFleet.placeShip(x, y, Game.placeShipDirection, Game.placeShipType); 		if (successful) { 		// Sporządzono umieszczenie tego statku 			self.endPlacing(Game.placeShipType);  		// Usuń strzałkę pomocniczą 			if (gameTutorial.currentStep === 2) { 				gameTutorial.nextStep(); 			}  			self.placingOnGrid = false; 			if (self.areAllShipsPlaced()) { 				var el = document.getElementById('rotate-button'); 				el.addEventListener(transitionEndEventName(),(function(){ 					el.setAttribute('class', 'hidden'); 					if (gameTutorial.showTutorial) { 						document.getElementById('start-game').setAttribute('class', 'highlight'); 					} else { 						document.getElementById('start-game').removeAttribute('class');	 					} 				}),false); 				el.setAttribute('class', 'invisible'); 			} 		} 	} }; // Tworzy zdarzenia obsługi zdarzeń mouseover, które obsługują mouseover na // siatka ludzkiego gracza narysuje statek fantomowy, co oznacza, że użytkownik // można tam umieścić statek Game.prototype.placementMouseover = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		var classes; 		var fleetRoster = self.humanFleet.fleetRoster;  		for (var i = 0; i < fleetRoster.length; i++) { 			var shipType = fleetRoster[i].type;  			if (Game.placeShipType === shipType && 				fleetRoster[i].isLegal(x, y, Game.placeShipDirection)) { 				// Virtual ship 				fleetRoster[i].create(x, y, Game.placeShipDirection, true); 				Game.placeShipCoords = fleetRoster[i].getAllShipCells();  				for (var j = 0; j < Game.placeShipCoords.length; j++) { 					var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 					classes = el.getAttribute('class'); 					// Check if the substring ' grid-ship' already exists to avoid adding it twice 					if (classes.indexOf(' grid-ship') < 0) { 						classes += ' grid-ship'; 						el.setAttribute('class', classes); 					} 				} 			} 		} 	} }; // Tworzy zdarzenia detekcji zdarzeń myszy, które nie rysują statku fantomowego // na siatce ludzkiego gracza, gdy użytkownik przechodzi przez inną komórkę Game.prototype.placementMouseout = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		for (var j = 0; j < Game.placeShipCoords.length; j++) { 			var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 			classes = el.getAttribute('class'); // Sprawdź, czy substrat 'grid-ship' już istnieje, aby uniknąć dodawania go dwukrotnie 			if (classes.indexOf(' grid-ship') > -1) { 				classes = classes.replace(' grid-ship', ''); 				el.setAttribute('class', classes); 			} 		} 	} }; // Click handler for the Rotate Ship button Game.prototype.toggleRotation = function(e) { 	// Toggle rotation direction 	var direction = parseInt(e.target.getAttribute('data-direction'), 10); 	if (direction === Ship.DIRECTION_VERTICAL) { 		e.target.setAttribute('data-direction', '1'); 		Game.placeShipDirection = Ship.DIRECTION_HORIZONTAL; 	} else if (direction === Ship.DIRECTION_HORIZONTAL) { 		e.target.setAttribute('data-direction', '0'); 		Game.placeShipDirection = Ship.DIRECTION_VERTICAL; 	} }; // Click handler for the Start Game button Game.prototype.startGame = function(e) { 	var self = e.target.self; 	var el = document.getElementById('roster-sidebar'); 	var fn = function() {el.setAttribute('class', 'hidden');}; 	el.addEventListener(transitionEndEventName(),fn,false); 	el.setAttribute('class', 'invisible'); 	self.readyToPlay = true; // Rozwiń krok samouczek 	if (gameTutorial.currentStep === 3) { 		gameTutorial.nextStep(); 	} 	el.removeEventListener(transitionEndEventName(),fn,false); }; // Kliknij przycisk obsługi programu Restart Game Game.prototype.restartGame = function(e) { 	e.target.removeEventListener(e.type, arguments.callee); 	var self = e.target.self; 	document.getElementById('restart-sidebar').setAttribute('class', 'hidden'); 	self.resetFogOfWar(); 	self.init(); }; // Funkcja debugowania służąca do umieszczania wszystkich statków i dopiero początek Game.prototype.placeRandomly = function(e){ 	e.target.removeEventListener(e.type, arguments.callee); 	e.target.self.humanFleet.placeShipsRandomly(); 	e.target.self.readyToPlay = true; 	document.getElementById('roster-sidebar').setAttribute('class', 'hidden'); 	this.setAttribute('class', 'hidden'); }; // Zakończenie umieszczania obecnego statku Game.prototype.endPlacing = function(shipType) { 	document.getElementById(shipType).setAttribute('class', 'placed'); 	 	// Mark the ship as 'used' 	Game.usedShips[CONST.AVAILABLE_SHIPS.indexOf(shipType)] = CONST.USED;  	// Wipe out the variable when you're done with it 	Game.placeShipDirection = null; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; }; // Sprawdza, czy wszystkie statki są umieszczone // Zwraca boolean Game.prototype.areAllShipsPlaced = function() { 	var playerRoster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < playerRoster.length; i++) { 		if (playerRoster[i].getAttribute('class') === 'placed') { 			continue; 		} else { 			return false; 		} 	} 	// Reset temporary variables 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; 	return true; }; // Zresetuje mgłę wojny Game.prototype.resetFogOfWar = function() { 	for (var i = 0; i < Game.size; i++) { 		for (var j = 0; j < Game.size; j++) { 			this.humanGrid.updateCell(i, j, 'empty', CONST.HUMAN_PLAYER); 			this.computerGrid.updateCell(i, j, 'empty', CONST.COMPUTER_PLAYER); 		} 	} 	// Reset all values to indicate the ships are ready to be placed again 	Game.usedShips = Game.usedShips.map(function(){return CONST.UNUSED;}); }; // Zresetowanie stylu CSS na pasku bocznym Game.prototype.resetRosterSidebar = function() { 	var els = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < els.length; i++) { 		els[i].removeAttribute('class'); 	}  	if (gameTutorial.showTutorial) { 		gameTutorial.nextStep(); 	} else { 		document.getElementById('roster-sidebar').removeAttribute('class'); 	} 	document.getElementById('rotate-button').removeAttribute('class'); 	document.getElementById('start-game').setAttribute('class', 'hidden'); 	if (DEBUG_MODE) { 		document.getElementById('place-randomly').removeAttribute('class'); 	} }; Game.prototype.showRestartSidebar = function() { 	var sidebar = document.getElementById('restart-sidebar'); 	sidebar.setAttribute('class', 'highlight');  	// Deregister listeners 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].removeEventListener('click', this.shootListener, false); 	} 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].removeEventListener('click', this.rosterListener, false); 	}  	var restartButton = document.getElementById('restart-game'); 	restartButton.addEventListener('click', this.restartGame, false); 	restartButton.self = this; }; // Tworzy divy HTML dla siatki dla obu graczy Game.prototype.createGrid = function() { 	var gridDiv = document.querySelectorAll('.grid'); 	for (var grid = 0; grid < gridDiv.length; grid++) { 		gridDiv[grid].removeChild(gridDiv[grid].querySelector('.no-js')); // Removes the no-js warning 		for (var i = 0; i < Game.size; i++) { 			for (var j = 0; j < Game.size; j++) { 				var el = document.createElement('div'); 				el.setAttribute('data-x', i); 				el.setAttribute('data-y', j); 				el.setAttribute('class', 'grid-cell grid-cell-' + i + '-' + j); 				gridDiv[grid].appendChild(el); 			} 		} 	} }; // inicjuje grę. Również resetuje grę, jeśli została wcześniej zainicjowana Game.prototype.init = function() { 	this.humanGrid = new Grid(Game.size); 	this.computerGrid = new Grid(Game.size); 	this.humanFleet = new Fleet(this.humanGrid, CONST.HUMAN_PLAYER); 	this.computerFleet = new Fleet(this.computerGrid, CONST.COMPUTER_PLAYER);  	this.robot = new AI(this); 	Game.stats = new Stats(); 	Game.stats.updateStatsSidebar();  	// Reset game variables 	this.shotsTaken = 0; 	this.readyToPlay = false; 	this.placingOnGrid = false; 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = [];  	this.resetRosterSidebar();  // Dodaj metodę kliknięć dla metody Grid.shoot () dla wszystkich komórek // Tylko dodaj tego słuchacza do sieci komputerowej 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].self = this; 		computerCells[j].addEventListener('click', this.shootListener, false); 	} // Dodaj listener do listy	 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].self = this; 		playerRoster[i].addEventListener('click', this.rosterListener, false); 	}  // Dodawanie detektora kliknięć do siatki ludzkiego gracza podczas wprowadzania 	var humanCells = document.querySelector('.human-player').childNodes; 	for (var k = 0; k < humanCells.length; k++) { 		humanCells[k].self = this; 		humanCells[k].addEventListener('click', this.placementListener, false); 		humanCells[k].addEventListener('mouseover', this.placementMouseover, false); 		humanCells[k].addEventListener('mouseout', this.placementMouseout, false); 	}  	var rotateButton = document.getElementById('rotate-button'); 	rotateButton.addEventListener('click', this.toggleRotation, false); 	var startButton = document.getElementById('start-game'); 	startButton.self = this; 	startButton.addEventListener('click', this.startGame, false); 	var resetButton = document.getElementById('reset-stats'); 	resetButton.addEventListener('click', Game.stats.resetStats, false); 	var randomButton = document.getElementById('place-randomly'); 	randomButton.self = this; 	randomButton.addEventListener('click', this.placeRandomly, false); 	this.computerFleet.placeShipsRandomly(); };  // Grid object // Constructor function Grid(size) { 	this.size = size; 	this.cells = []; 	this.init(); }  // Inicjowanie i wypełnienie siatki Grid.prototype.init = function() { 	for (var x = 0; x < this.size; x++) { 		var row = []; 		this.cells[x] = row; 		for (var y = 0; y < this.size; y++) { 			row.push(CONST.TYPE_EMPTY); 		} 	} };  // Aktualizuje klasę CSS komórki w oparciu o typ przekazany Grid.prototype.updateCell = function(x, y, type, targetPlayer) { 	var player; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		player = 'human-player'; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		player = 'computer-player'; 	} else { 		// Should never be called 		console.log(""There was an error trying to find the correct player's grid""); 	}  	switch (type) { 		case CONST.CSS_TYPE_EMPTY: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 		case CONST.CSS_TYPE_SHIP: 			this.cells[x+1][y+1] = CONST.TYPE_SHIP; 			break;  		case CONST.CSS_TYPE_MISS: 			this.cells[x][y] = CONST.TYPE_MISS; 			break; 		case CONST.CSS_TYPE_HIT: 			this.cells[x][y] = CONST.TYPE_HIT; 			break; 		case CONST.CSS_TYPE_SUNK: 			this.cells[x][y] = CONST.TYPE_SUNK; 			break; 		default: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 	} 	var classes = ['grid-cell', 'grid-cell-' + x + '-' + y, 'grid-' + type]; 	document.querySelector('.' + player + ' .grid-cell-' + x + '-' + y).setAttribute('class', classes.join(' ')); }; // Sprawdza, czy komórka zawiera nieuszkodzony statek // Zwraca boolean Grid.prototype.isUndamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_SHIP; }; // Sprawdza, czy strzał został pominięty. To jest równoważne // sprawdzenie, czy komórka zawiera kulę armatnią // Zwraca boolean Grid.prototype.isMiss = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_MISS; }; // Sprawdza, czy komórka zawiera uszkodzony statek, // uderzysz lub zatapia. // Zwraca boolean Grid.prototype.isDamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_HIT || this.cells[x][y] === CONST.TYPE_SUNK; };  // obiekt Floty // Ten obiekt służy do śledzenia portfela statków gracza // Konstruktor function Fleet(playerGrid, player) { 	this.numShips = CONST.AVAILABLE_SHIPS.length; 	this.playerGrid = playerGrid; 	this.player = player; 	this.fleetRoster = []; 	this.populate(); } // Posiada flotę Fleet.prototype.populate = function() { 	for (var i = 0; i < this.numShips; i++) { 		// loop over the ship types when numShips > Constants.AVAILABLE_SHIPS.length 		var j = i % CONST.AVAILABLE_SHIPS.length; 		this.fleetRoster.push(new Ship(CONST.AVAILABLE_SHIPS[j], this.playerGrid, this.player)); 	} }; // umieszcza statek i zwraca, czy miejsce docelowe jest skuteczne // Zwraca boolean Fleet.prototype.placeShip = function(x, y, direction, shipType) { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var shipTypes = this.fleetRoster[i].type;  		if (shipType === shipTypes && 			this.fleetRoster[i].isLegal(x, y, direction)) { 			this.fleetRoster[i].create(x, y, direction, false); 			shipCoords = this.fleetRoster[i].getAllShipCells();  			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 			} 			return true; 		} 	} 	return false; }; // Miejsca statków są losowo umieszczane na pokładzie // TODO: Unikaj umieszczania statków zbyt blisko siebie Fleet.prototype.placeShipsRandomly = function() { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var illegalPlacement = true; 	 		// Prevents the random placement of already placed ships 		if(this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] === CONST.USED) { 			continue; 		} 		while (illegalPlacement) { 			var randomX = Math.floor(10*Math.random()); 			var randomY = Math.floor(10*Math.random()); 			var randomDirection = Math.floor(2*Math.random()); 			 			if (this.fleetRoster[i].isLegal(randomX, randomY, randomDirection)) { 				this.fleetRoster[i].create(randomX, randomY, randomDirection, false); 				shipCoords = this.fleetRoster[i].getAllShipCells(); 				illegalPlacement = false; 			} else { 				continue; 			} 		} 		if (this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] !== CONST.USED) { 			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 				Game.usedShips[i] = CONST.USED; 			} 		} 	} }; // Znajduje statek według lokalizacji // Zwraca obiekt statku znajdujący się pod adresem (x, y) // Jeśli żaden statek nie istnieje w (x, y), zamiast tego zwraca null Fleet.prototype.findShipByCoords = function(x, y) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var currentShip = this.fleetRoster[i]; 		if (currentShip.direction === Ship.DIRECTION_VERTICAL) { 			if (y === currentShip.yPosition && 				x >= currentShip.xPosition && 				x < currentShip.xPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} else { 			if (x === currentShip.xPosition && 				y >= currentShip.yPosition && 				y < currentShip.yPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} 	} 	return null; }; // Znajduje statek według jego typu // Param shipType to ciąg znaków // Zwraca obiekt statku, który jest typu typu shipType // Jeśli żaden statek nie istnieje, zwraca null. Fleet.prototype.findShipByType = function(shipType) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		if (this.fleetRoster[i].type === shipType) { 			return this.fleetRoster[i]; 		} 	} 	return null; }; // Checks to see if all ships have been sunk // Returns boolean Fleet.prototype.allShipsSunk = function() { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		// If one or more ships are not sunk, then the sentence ""all ships are sunk"" is false. 		if (this.fleetRoster[i].sunk === false) { 			return false; 		} 	} 	return true; };  // Ship object // Constructor function Ship(type, playerGrid, player) { 	this.damage = 0; 	this.type = type; 	this.playerGrid = playerGrid; 	this.player = player;  	switch (this.type) { 		case CONST.AVAILABLE_SHIPS[0]: 			this.shipLength = 5; 			break; 		case CONST.AVAILABLE_SHIPS[1]: 			this.shipLength = 4; 			break; 		case CONST.AVAILABLE_SHIPS[2]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[3]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[4]: 			this.shipLength = 2; 			break; 		default: 			this.shipLength = 3; 			break; 	} 	this.maxDamage = this.shipLength; 	this.sunk = false; } // Sprawdza, czy umieszczenie statku jest legalne // Zwraca boolean Ship.prototype.isLegal = function(x, y, direction) { 	// najpierw sprawdź czy statek znajduje się w sieci ... 	if (this.withinBounds(x, y, direction))  	{ 	// ... sprawdź, czy nie koliduje z innym statkiem 		for (var i = 0; i < this.shipLength; i++)  		{ 			if (direction === Ship.DIRECTION_VERTICAL)  			{ 				if (this.playerGrid.cells[x + i][y] === CONST.TYPE_SHIP || 				this.playerGrid.cells[x - i][y] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_MISS || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_SUNK)  				 					{ 					return false; 				     } 			}  			else  			{ 				if (this.playerGrid.cells[x][y + i] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_MISS || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_SUNK)  					{ 					return false;}				 			}			 		}		 		return true; 	}  	else  		return false;	 }; // Sprawdza, czy statek znajduje się w granicach sieci // Zwraca boolean //statek mieści się w granicach gry Ship.prototype.withinBounds = function(x, y, direction) { 	if (direction === Ship.DIRECTION_VERTICAL) { 		return x + this.shipLength <= Game.size; 	} else { 		return y + this.shipLength <= Game.size; 	} }; // zwiększa licznik uszkodzeń statku // Zwraca statek Ship.prototype.incrementDamage = function() { 	this.damage++; 	if (this.isSunk()) { 		this.sinkShip(false); // Sinks the ship 	} }; // Sprawdza, czy statek jest zatopiony // Zwraca boolean Ship.prototype.isSunk = function() { 	return this.damage >= this.maxDamage; }; // Zanurzysz statek Ship.prototype.sinkShip = function(virtual) { 	this.damage = this.maxDamage; // Force the damage to exceed max damage 	this.sunk = true;  // Uczynienie klasy CSS zatopionej, ale tylko wtedy, gdy statek nie jest wirtualny 	if (!virtual) { 		var allCells = this.getAllShipCells(); 		for (var i = 0; i < this.shipLength; i++) { 			this.playerGrid.updateCell(allCells[i].x, allCells[i].y, 'sunk', this.player); 		} 	} };  Ship.prototype.getAllShipCells = function() { 	var resultObject = []; 	for (var i = 0; i < this.shipLength; i++) { 		if (this.direction === Ship.DIRECTION_VERTICAL) { 			resultObject[i] = {'x': this.xPosition + i, 'y': this.yPosition}; 		} else { 			resultObject[i] = {'x': this.xPosition, 'y': this.yPosition + i}; 		} 	} 	return resultObject; }; // Inicjuje statek o podanym współrzędnym i kierunku (łożyska). // Jeśli statek zostanie uznany za ""wirtualny"", wtedy statek zostanie zainicjowany // jego współrzędne, ale NIE umieszcza się na siatce. Ship.prototype.create = function(x, y, direction, virtual) { 	// This function assumes that you've already checked that the placement is legal 	this.xPosition = x; 	this.yPosition = y; 	this.direction = direction;  	// Jeśli statek jest wirtualny, nie dodaj go do sieci. 	if (!virtual) { 		for (var i = 0; i < this.shipLength; i++) { 			if (this.direction === Ship.DIRECTION_VERTICAL) { 				this.playerGrid.cells[x + i][y] = CONST.TYPE_SHIP; 			} else { 				this.playerGrid.cells[x][y + i] = CONST.TYPE_SHIP; 			} 		} 	} 	 }; // direction === 0 when the ship is facing north/south // direction === 1 when the ship is facing east/west Ship.DIRECTION_VERTICAL = 0; Ship.DIRECTION_HORIZONTAL = 1;  // Tutorial Object // Constructor function Tutorial() { 	this.currentStep = 0; 	// Check if 'showTutorial' is initialized, if it's uninitialized, set it to true. 	this.showTutorial = localStorage.getItem('showTutorial') !== 'false'; } // Advances the tutorial to the next step Tutorial.prototype.nextStep = function() { 	var humanGrid = document.querySelector('.human-player'); 	var computerGrid = document.querySelector('.computer-player'); 	switch (this.currentStep) { 		case 0: 			document.getElementById('roster-sidebar').setAttribute('class', 'highlight'); 			document.getElementById('step1').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 1: 			document.getElementById('roster-sidebar').removeAttribute('class'); 			document.getElementById('step1').removeAttribute('class'); 			humanGrid.setAttribute('class', humanGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step2').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 2: 			document.getElementById('step2').removeAttribute('class'); 			var humanClasses = humanGrid.getAttribute('class'); 			humanClasses = humanClasses.replace(' highlight', ''); 			humanGrid.setAttribute('class', humanClasses); 			this.currentStep++; 			break; 		case 3: 			computerGrid.setAttribute('class', computerGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step3').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 4: 			var computerClasses = computerGrid.getAttribute('class'); 			document.getElementById('step3').removeAttribute('class'); 			computerClasses = computerClasses.replace(' highlight', ''); 			computerGrid.setAttribute('class', computerClasses); 			document.getElementById('step4').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 5: 			document.getElementById('step4').removeAttribute('class'); 			this.currentStep = 6; 			this.showTutorial = false; 			localStorage.setItem('showTutorial', false); 			break; 		default: 			break; 	} };  // AI Object // Optimal battleship-playing AI // Constructor function AI(gameObject) { 	this.gameObject = gameObject; 	this.virtualGrid = new Grid(Game.size); 	this.virtualFleet = new Fleet(this.virtualGrid, CONST.VIRTUAL_PLAYER);  	this.probGrid = []; // Probability Grid 	this.initProbs(); 	this.updateProbs(); } AI.PROB_WEIGHT = 5000; // arbitrarily big number // jaka masa ma przynieść komórki wysokiego prawdopodobieństwa książki otwartej AI.OPEN_HIGH_MIN = 20; AI.OPEN_HIGH_MAX = 30; // ile wagi daje się średnim prawdopodobieństwom książki otwarcia AI.OPEN_MED_MIN = 15; AI.OPEN_MED_MAX = 25; // how much weight to give to the opening book's low probability cells AI.OPEN_LOW_MIN = 10; AI.OPEN_LOW_MAX = 20; // Amount of randomness when selecting between cells of equal probability AI.RANDOMNESS = 0.1; // AI's opening book. // This is the pattern of the first cells for the AI to target AI.OPENINGS = [ 	{'x': 7, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 2, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 7, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 2, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 5, 'y': 5, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 4, 'y': 4, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	// {'x': 9, 'y': 5, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 0, 'y': 4, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 5, 'y': 9, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 4, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 0, 'y': 8, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 1, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 8, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 9, 'y': 1, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 9, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 0, 'y': 0, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)} ]; // Zrzuca siatkę w oparciu o maksymalne prawdopodobieństwo i strzela do komórki // ma największe prawdopodobieństwo zawarcia statku AI.prototype.shoot = function() { 	var maxProbability = 0; 	var maxProbCoords; 	var maxProbs = []; 	 	// Add the AI's opening book to the probability grid 	for (var i = 0; i < AI.OPENINGS.length; i++) { 		var cell = AI.OPENINGS[i]; 		if (this.probGrid[cell.x][cell.y] !== 0) { 			this.probGrid[cell.x][cell.y] += cell.weight; 		} 	}  	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			if (this.probGrid[x][y] > maxProbability) { 				maxProbability = this.probGrid[x][y]; 				maxProbs = [{'x': x, 'y': y}]; // Replace the array 			} else if (this.probGrid[x][y] === maxProbability) { 				maxProbs.push({'x': x, 'y': y}); 			} 		} 	}  	maxProbCoords = Math.random() < AI.RANDOMNESS ? 	maxProbs[Math.floor(Math.random() * maxProbs.length)] : 	maxProbs[0];  	var result = this.gameObject.shoot(maxProbCoords.x, maxProbCoords.y, CONST.HUMAN_PLAYER); 	 	// If the game ends, the next lines need to be skipped. 	if (Game.gameOver) { 		Game.gameOver = false; 		return; 	}  	this.virtualGrid.cells[maxProbCoords.x][maxProbCoords.y] = result;  	// If you hit a ship, check to make sure if you've sunk it. 	if (result === CONST.TYPE_HIT) { 		var humanShip = this.findHumanShip(maxProbCoords.x, maxProbCoords.y); 		if (humanShip.isSunk()) { 			// Remove any ships from the roster that have been sunk 			var shipTypes = []; 			for (var k = 0; k < this.virtualFleet.fleetRoster.length; k++) { 				shipTypes.push(this.virtualFleet.fleetRoster[k].type); 			} 			var index = shipTypes.indexOf(humanShip.type); 			this.virtualFleet.fleetRoster.splice(index, 1);  			// Update the virtual grid with the sunk ship's cells 			var shipCells = humanShip.getAllShipCells(); 			for (var _i = 0; _i < shipCells.length; _i++) { 				this.virtualGrid.cells[shipCells[_i].x][shipCells[_i].y] = CONST.TYPE_SUNK; 			} 		} 	} 	// Update probability grid after each shot 	this.updateProbs(); }; // Update the probability grid AI.prototype.updateProbs = function() { 	var roster = this.virtualFleet.fleetRoster; 	var coords; 	this.resetProbs(); // Prawdopodobieństwa nie są znormalizowane, aby pasowały do przedziału [0, 1] // dlatego, że jesteśmy zainteresowani maksymalną wartością.  // Działa to poprzez dopasowanie każdego statku do każdej komórki w każdej orientacji // W każdej komórce, tym bardziej legalnym sposobem, w jaki statek może przechodzić przez niego, tym bardziej // prawdopodobnie komórka ma zawierać statek. // Komórki otaczające znane ""trafienia"" otrzymują arbitralnie duże prawdopodobieństwo // tak, że AI próbuje całkowicie zatopić statek przed przejściem dalej.  // TODO: Pomyśl o bardziej efektywnej implementacji 	for (var k = 0; k < roster.length; k++) { 		for (var x = 0; x < Game.size; x++) { 			for (var y = 0; y < Game.size; y++) { 				if (roster[k].isLegal(x, y, Ship.DIRECTION_VERTICAL)) { 					roster[k].create(x, y, Ship.DIRECTION_VERTICAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var i = 0; i < coords.length; i++) { 							this.probGrid[coords[i].x][coords[i].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _i = 0; _i < coords.length; _i++) { 							this.probGrid[coords[_i].x][coords[_i].y]++; 						} 					} 				} 				if (roster[k].isLegal(x, y, Ship.DIRECTION_HORIZONTAL)) { 					roster[k].create(x, y, Ship.DIRECTION_HORIZONTAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var j = 0; j < coords.length; j++) { 							this.probGrid[coords[j].x][coords[j].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _j = 0; _j < coords.length; _j++) { 							this.probGrid[coords[_j].x][coords[_j].y]++; 						} 					} 				}  				// Set hit cells to probability zero so the AI doesn't 				// target cells that are already hit 				if (this.virtualGrid.cells[x][y] === CONST.TYPE_HIT) { 					this.probGrid[x][y] = 0; 				} 			} 		} 	} }; // Initializes the probability grid for targeting AI.prototype.initProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		var row = []; 		this.probGrid[x] = row; 		for (var y = 0; y < Game.size; y++) { 			row.push(0); 		} 	} }; // Resets the probability grid to all 0. AI.prototype.resetProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			this.probGrid[x][y] = 0; 		} 	} }; AI.prototype.metagame = function() { 	// Inputs: 	// Proximity of hit cells to edge 	// Proximity of hit cells to each other 	// Edit the probability grid by multiplying each cell with a new probability weight (e.g. 0.4, or 3). Set this as a CONST and make 1-CONST the inverse for decreasing, or 2*CONST for increasing }; // Finds a human ship by coordinates // Returns Ship AI.prototype.findHumanShip = function(x, y) { 	return this.gameObject.humanFleet.findShipByCoords(x, y); }; // Checks whether or not a given ship's cells passes through // any cell that is hit. // Returns boolean AI.prototype.passesThroughHitCell = function(shipCells) { 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			return true; 		} 	} 	return false; }; // Gives the number of hit cells the ships passes through. The more // cells this is, the more probable the ship exists in those coordinates // Returns int AI.prototype.numHitCellsCovered = function(shipCells) { 	var cells = 0; 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			cells++; 		} 	} 	return cells; };  // Global constant only initialized once var gameTutorial = new Tutorial();  // Start the game var mainGame = new Game(10);  })();  // Array.prototype.indexOf workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf if (!Array.prototype.indexOf) { 	Array.prototype.indexOf = function (searchElement, fromIndex) {  		var k;  		// 1. Let O be the result of calling ToObject passing 		//    the this value as the argument. 		if (this === null || this === undefined) { 			throw new TypeError('""this"" is null or not defined'); 		}  		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get 		//    internal method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If len is 0, return -1. 		if (len === 0) { 			return -1; 		}  		// 5. If argument fromIndex was passed let n be 		//    ToInteger(fromIndex); else let n be 0. 		var n = +fromIndex || 0;  		if (Math.abs(n) === Infinity) { 			n = 0; 		}  		// 6. If n >= len, return -1. 		if (n >= len) { 			return -1; 		}  		// 7. If n >= 0, then Let k be n. 		// 8. Else, n<0, Let k be len - abs(n). 		//    If k is less than 0, then let k be 0. 		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);  		// 9. Repeat, while k < len 		while (k < len) { 			var kValue; 			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the 			//    HasProperty internal method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			//    i.  Let elementK be the result of calling the Get 			//        internal method of O with the argument ToString(k). 			//   ii.  Let same be the result of applying the 			//        Strict Equality Comparison Algorithm to 			//        searchElement and elementK. 			//  iii.  If same is true, return k. 			if (k in O && O[k] === searchElement) { 				return k; 			} 			k++; 		} 		return -1; 	}; }  // Array.prototype.map workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map // Production steps of ECMA-262, Edition 5, 15.4.4.19 // Reference: http://es5.github.io/#x15.4.4.19 if (!Array.prototype.map) {  	Array.prototype.map = function(callback, thisArg) {  		var T, A, k;  		if (this == null) { 			throw new TypeError("" this is null or not defined""); 		}  		// 1. Let O be the result of calling ToObject passing the |this|  		//    value as the argument. 		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get internal  		//    method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If IsCallable(callback) is false, throw a TypeError exception. 		// See: http://es5.github.com/#x9.11 		if (typeof callback !== ""function"") { 			throw new TypeError(callback + "" is not a function""); 		}  		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined. 		if (arguments.length > 1) { 			T = thisArg; 		}  		// 6. Let A be a new array created as if by the expression new Array(len)  		//    where Array is the standard built-in constructor with that name and  		//    len is the value of len. 		A = new Array(len);  		// 7. Let k be 0 		k = 0;  		// 8. Repeat, while k < len 		while (k < len) {  			var kValue, mappedValue;  			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the HasProperty internal  			//    method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			if (k in O) {  				// i. Let kValue be the result of calling the Get internal  				//    method of O with argument Pk. 				kValue = O[k];  				// ii. Let mappedValue be the result of calling the Call internal  				//     method of callback with T as the this value and argument  				//     list containing kValue, k, and O. 				mappedValue = callback.call(T, kValue, k, O);  				// iii. Call the DefineOwnProperty internal method of A with arguments 				// Pk, Property Descriptor  				// { Value: mappedValue,  				//   Writable: true,  				//   Enumerable: true,  				//   Configurable: true }, 				// and false.  				// In browsers that support Object.defineProperty, use the following: 				// Object.defineProperty(A, k, {  				//   value: mappedValue,  				//   writable: true,  				//   enumerable: true,  				//   configurable: true  				// });  				// For best browser support, use the following: 				A[k] = mappedValue; 			} 			// d. Increase k by 1. 			k++; 		}  		// 9. return A 		return A; 	}; }  // Browser compatability workaround for transition end event names. // From modernizr: http://stackoverflow.com/a/9090128 function transitionEndEventName() { 	var i, 		undefined, 		el = document.createElement('div'), 		transitions = { 			'transition':'transitionend', 			'OTransition':'otransitionend',  // oTransitionEnd in very old Opera 			'MozTransition':'transitionend', 			'WebkitTransition':'webkitTransitionEnd' 		};  	for (i in transitions) { 		if (transitions.hasOwnProperty(i) && el.style[i] !== undefined) { 			return transitions[i]; 		} 	} }  // Returns a random number between min (inclusive) and max (exclusive) function getRandom(min, max) { 	return Math.random() * (max - min) + min; }  // Toggles on or off DEBUG_MODE function setDebug(val) { 	DEBUG_MODE = val; 	localStorage.setItem('DEBUG_MODE', val); 	localStorage.setItem('showTutorial', 'false'); 	window.location.reload(); };"
"@piotrpo: (odnośnie komentarzy do powyższego posta) Bootcampowcy dorosną, się douczą, a ci obecni programiści będą lata świetlne przed nimi :) Każdego dnia tworzy się jakaś nowa nisza na rynku.  20lat temu mało kto wierzył w to, że GPS'y będą dostępne nawet dla dzieci w byle słabym telefonie. 15 lat temu mało kto by myślał, że może powstać coś takiego jak uber czy wykorzystanie AI. 10 lat temu nikt sobie nie zaprzątał głowy augumented i virtual reality 5 lat temu większość ludzi mało co wiedziała o bitcoinach.  Idąc Twoim tokiem rozumowania zakładam że za 5 lat nic nowego nie powstanie, boom na programistów zmaleje, zaleją nas hindusi, bootcampowcy i pewnie jeszcze powiesz, że AI nas zastąpi. No ciekawe. Nie jestem żadnym świeżakiem, na 4p konto mam od ponad 10 lat i widzę co się dzieje. Ty natomiast wypisujesz jakieś herezje :) Rozumiem, że prywatne linie lotnicze które umożliwią loty w kosmos, naśladując działalność Muska, zatrudnią tam tanich hindusów, a ich frontendowe stronki/sklepy do sprzedawania tego typu usług będą generowane z automatu lub przez Panią krysię z HR'ów (wix.com?) Administracji możliwe że będzie coraz mniej, bo coraz więcej instytucji przechodzi na IT - tak więc Pani Krysia zamiast latać po 4 piętrach biurowca by zebrać podpisy, wyśle jednego requesta w appce i tyle. W razie potrzeby druknie. Polecam spytać kogoś znajomego jak wygląda praca w urzędzie miejskim, to się załamiesz jak zobaczysz jaki beton siedzi tam obecnie.;"
"Jak będzie swoje dziecko zachęcał do programowania i kiedyś AI wyprze zwykłych programistów i jego dziecko będzie przez niego bezrobotne to przynajmniej będzie potrafił przyznać się do swojej winy, a nie wmawiać dziecku, że to jego wina.;"
"Chłopaki, byłem rekruterem technicznym w jednej z większych korporacji w Warszawie. W 2015 roku byłem na okoły 20+ rozmowach. I jak najbardziej poziom absolwentów koreluje z uczelnią i kierunkiem. Oczywiście wśród studentów informatki też jest duże zróżnicowwanie i całe mnóstwo osób które przebimało studia. Nawet nie wiesz jak - przykładowo - trudno znaleźć gościa znającego porządnie C i C++, algorytmikę, architekturę komputerów (ARM albo x86) i systemy operacyjne (na poziomie programisty) ;) ... a to przecież podstawy ze studiów. Sam skończyłem dobry uniwerek, do pracy poszedłem jednak podczas studiów po 3 roku. Uczyłem się samemu, do tej pory zawszę znajduję czas na naukę. Ale tak jak napisałem, jak się nie wie, jak się edukować, to nazwyczajniej na świecie można popełnić błąd. Informatyka to nie tylko Java i C# ;). Coraz większą popularność zdobywa analiza danych, data science, uczenie maszynowe, wizja komputerowa, chmura, wirtualizacja. Jest też zapotrzebowanie na programistów embedded, a do tego czasami potrzebne są podstawy elektorniki i architektury komputerów. Jest większa szansza że zostanie wyeksponowany na takie tamaty na informatyce niż na informatyce i ekonometrii. Mówiąc brutalnie, na informatyce masz większą szansę spotkać ludzi - geeków - (kolegów), którzy są dobrzy, od których można się uczyć i robić wspólne projekty, niż na kierunku mieszanym. Większe szanse na wykłady na dobrym poziomie. Nie neguję wkładu własnego, mówię o potencjale który daje uczelnia i kierunek, a to jak się to wykorzysta zależy od konkretnej osoby. W moim subiektywnym odczuciu lepiej wybrać infę. Ale to Twoja decyzja.;"
"Na jakiej uczelni rozpatrujesz IiE? W Łodzi na UŁ? Studiuję to, jednak miałem nieco inne plany- analityka finansowa + it, jednak po zajęciach z programowania c,vb,java, bazy danych stwierdzilem ze wole isc w tym kierunku. Jest jedna specjalnosc bardziej ukierunkowana na Informatyke, jednak przedmioty te sa prowadzone niechlujnie i jesli sam sie nie przylozysz to za wiele z nich nie wyniesiesz. Plusem uznaje poznanie metod ilosciowych, matematyki, podstaw ekonomii i finansow, bo  kazda wiedza moze kiedys sie przydac. Sam kierunek Informatyka tez Ci nic nie da jak wyjdziesz z zalozenia byleby zdac. Teraz sam papierek nie gwarantuje pracy, dlatego rownie dobrze mozesz isc na zarzadzanie i uczyc sie w wolnym czasie programowania. Jak jestes juz swiadomy co chcesz robic w zyciu to lepiej isc w tym kierunku, ja niestety sam nie wiedzialem bo wiele rzeczy mi sie podobalo (w tym ekonomia). Na roku wiekszosc osob tylko sie przeslizguje i ma zerowe pojecie o metodach ilosciowych, o programowaniu nie wspominajac. Ggdybym mial mozliwosc pojscia jeszcze raz na studia, wybralbym cos bardziej informatycznego, bo tutaj mimo wielu dobrych wykladowcow (sporo osob wlasnie po tym kierunku, pracujacych jako programisci baz danych, javy, projektanci systemow inf. itp.) przedmioty sa zbyt mocno obkrojone lub ulatwiane, bo ludzie nie wiedza jak wybrac rekody z tabeli za pomoca sqla. Jednak samozaparciem i praca idzie sporo nadrobic, dlatego musisz zdecydowac, IiE daje tez furtke bezpieczenstwa, ze w razie gdy nie spodoba Ci sie programowanie to mozesz zawsze pojsc w kierunku analizy danych czy wspomaganie decyzji men. Pozdrawiam!;"
sieci neuronowe Dla 4-9 parametrów szybkość nie powinna mieć znaczenia - na upartego brute force z lekkim tuningiem też by przeszło... 1-100 to liczby całkowite czy float?;
Całkowite. Jedna symulacja trwa 200-300ms czyli dla 4 parametrów i zakresu 1-100 brute force zajmie prawie rok. Obecnie optymalizuję po 1-2 parametrze. Sieci neuronowe chyba mnie teraz przerastają - choć wgryzę się w to pewnie kiedyś. Poczytam o metodach gradientowych bo wykres zależności pewnie będzie miał gdzieś maksimum.;
"Jak najbardziej Python znajduje się zasłużenie na liście, być może w polsce gdzie klepie się głównie stronki dla janusza w javie -  python nie jest zbyt popularny, ale ten język od jakichś 5 lat jest głównym językiem rewolucji AI/uczenie maszynowe, czyli to będzie chyba 4 wielkiej rewolucji technologicznej (czy tam którejś tam, zależy jak się liczy). Gdyby nie prostota pythona ludzie po matematyce, statystyce, ekonometrii mieliby duże problemy z wejściem w tą dziedzine, a tym samym jej rozwój byłby znacznie wolniejszy.;"
"https://fossbytes.com/wp-content/uploads/2016/12/machine-learning-data-science-programming-language.png czlowieku co ty dajesz, całe uczenie maszynowe idzie w pythonie. statystyka i ekonometrie to osobna sprawa.;"
"Cześć wszystkim! Sprowadził mnie tutaj WIELKI dylemat życiowy. Chcę, żeby wypowiedziały się osoby, które czują podobnie, jak i takie, które nie rozumieją mojego podejścia do życia. Najpierw przedstawię swoje doświadczenia, a później spostrzeżenia. O mnie / krótko-długa historia: Od 6 klasy szkoły podstawowej  (ok. 2001-02 rok) mam kontakt z programowaniem. W ten świat wprowadziła mnie książka Romana Poznańskiego pt. ""Przygody z komputerem i bez komputera"" oraz moje ukochane Commodore 64. Tak zacząłem się uczyć programować w języku BASIC. Później w gimnazjum spędzałem popołudnia u kolegi, który wybywał do dziewczyny, a ja mogłem na jego komputerze tworzyć pierwsze strony w HTMLu w notatniku, a później w Pajączku i FrontEndzie (kto jeszcze pamięta?). Kiedy w końcu rodzice kupili pierwszego PCta, byłem przeszczęśliwy, że będę mógł edytować zapisane na dyskietkach swoje strony. Oczywiście zaangażowałem się wtedy w stronę gimnazjum i drużyny harcerskiej. Liznąłem nawet Macromedia Flash i tajemny ActionScript. W liceum również byłem jedynym specjalistą od strony szkoły. Znałem już CSS, JS, PHPa. W wieku 16 lat zrobiłem swojego pierwszego CMSa, bo to była kwestia honoru. Ówczesny PHPNuke i PHPFusion nie spełniały moich oczekiwań. To były piękne czasy fascynacji technologią. Wspominam je z łezką w oku. Po liceum, czyli od 2009 roku zacząłem zawodowo zajmować się programowaniem, ale też innymi rzeczami pomiędzy zleceniami. Studia olałem po paru miesiącach, bo nie mogłem realizować swoich pomysłów, od których nie mogłem zasnąć. Postanowiłem zdobyć chociaż tytuł zawodowy informatyka o specjalizacji programisty w technikum policealnym, w końcu to tylko dwa lata, a nie 5 lat. Odbyłem w międzyczasie jakieś kursy informatyczne i programowania np. C#/WPF, RedHat. Zdobywałem zatrudnienie w różnych firmach, ale po paru miesiącach sam podejmowałem decyzję o zakończeniu współpracy, ponieważ nie odpowiadała mi atmosfera. Pracowałem w Januszpolach, Łagropolach, Korpo, na UoP i na B2B. Najdłużej pracowałem w jednym ""zakładzie pracy"" 1,5 roku. Zawsze dużo wymagałem od siebie, tworzyłem czytelny, samoopisujący się kod, według obowiązujących standardów, z zachowaniem konkretnej struktury i metodyk programowania, dokumentowałem moje postępy. Ostatnio zrezygnowałem ze współpracy w jednej ze stabilnych firm, gdzie atmosfera koleżeńska była bardzo w porządku, kasa była zawsze na czas. O odejściu zdecydowało pogarszające się zdrowie, brak kompetencji ze strony kierownictwa projektu, brak rozwoju i zbyt słabe warunki finansowe. Wnioski: Obserwując rynek z perspektywy ostatnich kilku lat kiedy to utknąłem w jakimś stacku technologicznym, widzę, że trochę się pozmieniało. Nie tylko w zakresie trendów technologicznych, terminologii, ale też namnożyło się bootcampów, które roztaczają wizję, jak to każdy może kosić hajs, kto przejdzie kurs. Poza tym docierają do mnie sygnały, że niebawem zastąpi nas AI, albo, że klient będzie w stanie sam z klocków zaprojektować cały proces zbierania i przetwarzania danych. Boję się, że programista nie będzie już tak niezbędny dla biznesu, bo będą narzędzia, które skrócą czas oczekiwania na produkt. W większości firm z którymi miałem kontakt, wyglądało to tak, jakby firma zajmowała się mówiąc obrazowo uprawianiem pola bawełny, z której powstawała tkanina i nici, projektowało się w międzyczasie ubranie, szyło t-shirta, a później okazywało się, że ma to być garnitur! Pytania: Czy to normalne, żeby często zmieniać ""pracodawców"" poszukując lepszego miejsca dla siebie? Czy to normalne, że podczas kiedy inni widzą nadzieję w programowaniu, ja odnajduję spokój i ukojenie w pracach fizycznych, gdzie widzę jak własnymi rękami kształtuję materię? Czy tylko ja uważam, że to wszystko dzieje się tak szybko i tak nieprzewidywalnie, że nawet nie wiadomo co będzie za rok? Z pewnością nie wyczerpałem tematu i będę się odnosił w komentarzach do poszczególnych wypowiedzi. Chciałbym, żebyście przedstawili swój punkt widzenia niezależnie do tego jaką rolę pełnicie w zespole.;"
"Mam taki pomysł, żeby zrobić sieć neuronową rozpoznajacą cyfry w javie. Taką prostą raczej. I dać linka do githuba z tym w cv, żeby pokazać tam coś takiego bardziej wow poza wpisaniem w cv znam jave. Czy to w ogóle ma sens? Czy kobiety z hr w ogóle patrzą na linki do githubu? W końcu i tak to ściana tekstu po ""chinsku"". Poza tym moze java i sieci neuronowe to głupi pomysł i nikt nie szuka takich ludzi?;"
"Java i sieci neuronowe to nie głupi pomysł. Warto, chociażby dla siebie, nie dla HR. Czy HR na to spojrzy? Kto wie, większość pań z HR nie, ale to pójdzie dalej i tam już zapewne ktoś spojrzy. W mniejszych firmach może to nawet od razu pójść 'gdzieś dalej'. Możesz też trafić na kogoś unikalnego z HR, kto wchodzi na githuba, nigdy nie wiadomo.;"
"Próbujesz trollować sam siebie czy nieudolnie mnie? Z samą znajomością Java nikt nawet na Ciebie nie spojrzy. Nie słyszałem o firmach robiących sieci neuronowe w Javie. Chociaż na uczelni w tym się robiło (ale była dowolność). Bardziej Python jeśli to jest kierunek Twoich zainteresowań to zmień język. Jeśli chcesz zrobić sieć, a pracować w web to daruj sobie bo to nie ten kierunek. O ile w ogóle ktoś zajrzy na tego githuba.;"
"Sieci neuronowe (i sporo innej AI) to algebra liniowa a w tych zastosowaniach Java nie jest ani wydajna, ani przyjemna. W dodatku jeśli nawet się zabierzesz za pisanie czegoś takiego, zakładam, że z użyciem jakiejś biblioteki, to ten kod nie świadczy dokładnie o niczym - nie rozwiązujesz jakiegoś problemu, wykazać się biegłością implementacji i opanowania języka nie ma gdzie. Interesują cię NN - ok - opanuj teorię, wymyśl sobie jakiś niebanalny problem (klasyfikator na danych MNIST to naprawdę banał jest) i spróbuj go rozwiązać. Niebanalnym problemem jest np. stwierdzenie, jakie cyfry są na zdjęciu. Możesz też napisać prostą grę w zgadywanie orzeł czy reszka, gdzie próbujesz za pomocą AI przewidzieć, czy człowiek w kolejnym kroku powie A, czy B, albo wymyśl coś sam. To czy będzie to Python, R, Matlab, czy Tensorflow - twój wybór - java może być, ale nie jest to naturalny wybór dla tej klasy problemów. Jeżeli to jest twoja pierwsza praca, to nikt nie wymaga doświadczenia, za to wymaga się wiedzy - jakiej, to już zależy od rodzaju pracy - zestaw pytań o różnego rodzaju ficzery i niuanse składniowe w Javie jest dość typowy. Teoretyczna przynajmniej znajomość wzorców projektowych też jest bardzo mile widziana. Zdarzają się pytania ogólne o algorytmy i struktury, złożoność obliczeniową i generalnie wszystko co wpiszesz w CV - więc pisz dużo, ale nie kłam, bo to wychodzi błyskawicznie i generalnie dyskwalifikuje kandydata.;"
"uczenie maszynowe == python statystyka, ekonometria, matematyka finansowa == R lub SAS daj plusa jak pomogłem ;);"
"Akurat sieci neuronowe w Javie się oprogramowuje również, Jest kilka pakietów rozsądnych - ten znam: https://deeplearning4j.org/ Wykonuje równiez obliczenia na GPU  (obecnie w zasadzie standard) i obsługuje różnego rodzaju sieci i uczenia. Natomiast powiedziałbym, że sieci neuronowe to  działka sama w sobie i trochę niezależnaod języka - jak się nauczysz w jednym to i w drugim sobie poradzisz. Problemy typu dobór sposobu uczenia, rozmiaru sieci, obróbka danych  itp. są uniwersalne. Natomiast chyba nadal nie jest tak, że łatwo z ulicy dostać prace w tej działce... raczej większość firm szuka klepaczy formatek. Poza tym niestety całe sieci, ogólnie machine learning i obróbka  to już ogromna działka - nie wiem ile trzeba na to lat poświęcić :-).;"
"Zdzichu :-) ciężki z Ciebie człowiek i nie chciałbym z Tobą pracować. Napisałem Ci technologie, które na tym stanowisku przejawiają się w ogłoszeniach. @slayer9 również wymienił Ci kilka. Skąd my mamy wiedzieć co masz umieć, a czego nie? Ani nie napisałeś w jakim kierunku chciałbyś się rozwijać. Aplikacje okienkowe, web, mobilne, sieci neuronowe, gry (wszak Minecraft w tym zrobiony). Czekam jeszcze aż zaczniesz pytać czy już wiesz na tyle dużo żeby gdzieś aplikować czy jeszcze nie? Weź rusz d*** i poszukaj sam w końcu bo nikt Ci nie poda gotowego rozwiązania do problemu, którego nikt oprócz Ciebie nie jest w stanie rozwiązać :P;"
"Sieci neuronowe, przynajmniej te bardziej rozwinięte, trzymają się raczej od Javy z daleka.;"
"Zacząć studia informatyczne aby uzyskać tytuł inżyniera albo znaleźć pracę w zawodzie to dopiero kiepsko :D Tytuł inż nic nie znaczy... za granicą tytuł inż jest nawet niżej w ""hierarchii"" niż licencjat, ponieważ studia inżynierskie z definicji powinny być bardziej praktyczne / przygotowujące do zawodu, natomiast studia licencjackie powinny być bardziej ""naukowe"", a w praktyce to wychodzi różnie... przynajmniej w Polsce ;D Moim zdaniem zupełnie nie opłaca się studiować zwykłej informatyki. Programowania i tak trzeba nauczyć się samemu, studia w tej branży są nie potrzebne. Jeśli już studiować to lepiej rozszerzyć sobie pole manewru w karierze poprzez wybór kierunku zbliżonego do informatyki ;) Informatyka i ekonometria daje dużo możliwości, bo możesz pracować jako programista, finansista, statystyk, analityk (np. ryzyka kredytowego). Więc jeśli wypalisz się jako programista albo AI wyprze większość programistów z rynku to zawsze będziesz mieć większe pole manewru niż absolwent zwykłej informatyki (których jest pełno jak mrówek w mrowisku, a będzie coraz więcej).;"
"Niestety mam nikłą wiedzę dotyczącą analizowania obrazu - sieci neuronowe, algorytmy genetyczne :) ale pomysł doceniam. Chociaż jak dobrze pomyśleć to analiza obrazu nie jest niezbędna: filmy mają rankingi nie tylko jako film ale także jako popularność wycinka - to gdyby ktoś chciał rozwijać ten temat :))));"
W sieciach z propagacją wsteczną - minimalnie (trochę więcej jeśli używasz do uczenia algorytmów genetycznych). Ale w ogólnie w AI czy data miningu - bardzo. Ktoś tu 10 lat temu wyskrobał całkiem pokaźny artykuł n.t.: Sztuczne sieci neuronowe i algorytmy genetyczne;
"pyBrain (używany przeze mnie ostatnio), Matlab Machine Learning Toolbox ;) Uczenie maszynowe to przede wszystkim wyciąganie pewnych wniosków na podstawie istniejących danych, tak aby wykorzystać je w przyszłości. Więc w grę wchodzi rozpoznawanie czegokolwiek co potrafisz przedstawić w postaci cyfrowej. Mowa, pismo, dźwięk, obraz - owszem. Ale także tworzenie systemów ekspertowych, które swoją bazę wiedzy mają zbudowane w oparciu o techniki uczenia maszynowego. Wraz z tym wchodzi tutaj pojęcie 'softcomputing', które wykorzystuje i łączy różne rodzaje uczenia maszynowego (sieci neuronowe różnego typu, systemy ekspertowe, logika rozmyta czy algorytmy genetyczne). No i nie zapominajmy o tym czym jest Big Data. Tam takie rzeczy jak uczenie maszynowe i analizy statystyczne to narzędzia używane nagminnie. Zastosowań uczenia maszynowego nie zliczysz. Ostatnio próbuję zrobić rozpoznawanie sygnału wibrometrycznego, tak aby system odpowiedział mi na pytanie 'co się dzieje'.;"
"Bardzo 'ciekawie' wyglądają ceny API(Piszę, w wątku o zwolnieniach, bo jest dużo szumu jak to zastąpi analityków danych). Zakładając, że chcesz wysłać CSV zawierający 1000 wierszy do API, to kost wejściowych tokenów wyniósłby około. (8000 * 0.06)/1000 tj.0.48$ 123,100,1683670098 -> około 8 tokenów (id, ilosc, timestamp) Nie liczę kosztu wyjściowych, bo to zależy od analizy itd. Ciekawie, jak będą wyglądały ceny 'code interpreter', bo cały Twitter już stwierdził, że to nowy analityk danych, jednak jeżeli koszty będą porównywalne z API, to wielu się zdziwi i zrozumie, że czasami oprogramowanie zbudowane do konkretnego celu daje lepszy koszt/efekt.;"
"W pewnym sensie nie. Na ""zwykłej"" informatyce nie będziesz się uczyć rzeczy specyficznych dla pewnej ""domeny"". Żeby pokazać co mam na myśli, weźmy takie AGH które ma informatykę na połowie wydziałów (i do niedawna każda nazywała się ""informatyką stosowaną"", a teraz każda ma jakaś unikalną nazwę, żeby się nie myliły, stąd masz np. informatykę techniczną i geoinformatykę). Masz np. jakieś: https://sylabusy.agh.edu.pl/pl/1/1/17/1/4/12/7 niby zaczyna się normalnie, ale potem wchodzą ci przedmioty w stylu Wymiana ciepła i masy , Podstawy mechaniki płynów czy Podstawy mechaniki ciała stałego albo analogicznie masz kierunek jak https://sylabusy.agh.edu.pl/pl/1/1/17/1/4/49/101 na którym wchodzą ci jakieś Podstawy teledetekcji i fotogrametrii, Systemy GIS w naukach o Ziemi, Geozagrożenia, Kartografia geologiczna wspomagana komputerowo itp. To są właśnie informatyki stosowane. Na ""zwykłej"" informatyce będziesz zamiast tego miał rzeczy bliżej związane z informatyką dla informatyki jak jakieś uczenie maszynowe, tworzenie kompilatorów czy kryptografię.;"
"Biblioteka FANN ma przykładowe programy, zobacz jak tam jest to zrobione. Jeśli nie wiesz jak działają sieci neuronowe (co to znaczy uczyć/trenować sieć neuronową) to doucz się.;"
"Zarobki pominę milczeniem W sumie wygrałeś los na loterii. Przez dwa lata mogłeś się uczyć na środowisku produkcyjnym, a tego nie zastąpi żaden  kurs czy książka Drugi człowiek jest zabezpieczeniem  w sytuacjach losowych np. wypadek, ale nie daje 100% gwarancji. Znam przypadek gdzie w tym samym czasie odeszło do konkurencji dwóch administratorów szczęściem dla firmy został jeszcze trzeci co zapobiegło naprawdę nieciekawej sytuacji.;"
"BI zajmuje się tez data science? Ja znan parę  osób  co się  zajmuja tyn calym Bi i one raczej nie wyglądają  na takie co by umialy ogarnac cokolwiek w sumie. Poza excellem sqlem i robieniem prezentacji w powerpoincie. Ta twoja definicja  BI to jest tak  szeroka że  aż  nic nie mówiąca. Okej czyli z tego co ja rozumiem to BI to jest zastosowanie metod matematycznych  do zarządzania  ludzmi oraz podwykonawcami. Ocena wydajności  pracy. Czasem oznacza to zaawansowane metody ekonometryczne i optynalizacyjne oraz uczenie maszynowe, jak frma jest poważna. A z reguły  w polsce to oznacza excell, sql i powerpoint?;"
"Ja bym wybrał Python, jest dużo łatwiejszy od Javy, do tego Django i PostgreSQL. Zarobki wcale nie małe, a z czasem Ruby i Python zastąpi wysłużone PHP.;"
Dwa słowa: sieci neuronowe. Język i platforma nie robią większej różnicy w tym przypadku.;
"Witam. Czy ktoś z Was pisał już kiedyś coś w C / C++ implementujące mechanizmy znane ze sztucznej inteligencji ? Alogorytmy genetyczne, sieci neuronowe, automaty komórkowe ? Szukam pomysłów i uwag a nie konkretnych pełnych rozwiązań (w końcu sam mam głowę powysilać  :d  ) Dopiero zaczynam ten temat i chciałbym się dowiedzieć np. jakie struktury czy algorytmy mogą  być pomocne w pisaniu tego typu programów. Z góry dziękuję za wszelką pomoc i uwagi. Pozdrawiam;"
"Czemu sieci neuronowe? Do klasyfikacji lepiej wziąć SVM. Skutecznością miażdży sieci neuronowe, choć trochę trudniejsza matematyka.;"
"Jest bardzo źle... Co prawda AI nas nie zastąpi, ale 1/4 firm planuje zwolnienia. Tak więc jak ktoś ma dostęp to proszę niech sprawdzi kto nas zastąpi, skoro nie AI to obstawiam:  Hindusów / kraje low-cost low code / no code wezwania do wojska;"
"Trochę już pracuje w IT  i do końca nie mogę zrozumieć nagłego nasycenia rynku. Np w fintechu zeszły rok wiele banków i instytucji finansowych miało tłusty i obfity dochód ale projekty IT dalej wstrzymywali/cięli. Co jest dziwne w branży nie możesz po prostu przestać inwestować w IT bo jest wysoce kompetytywna a do tego nigdy żadna aplikacja/usługa nie jest wieczna. Potrzeba updatów, nowych alternatywnych pomysłów. Kto pamięta naszą klasę czy gadu gadu albo my space? Facebook/Meta też nie będzie wieczny to samo dotyczy OS czy frameworków. Wniosek jest taki, że rynek wiecznie nie będzie 'nasycony' chyba, że mamy zacząć się cofać w rozwoju (back to the monkey). Jakoś nie mogę uwierzyć, że rozumni ludzie liczą na to, że Devil czy inne AI wszystko zastąpi a ludzkość nareszcie będzie mogła się skupić na roli i tyraniu na pańszczyznę.;"
"Mi się wydaje że z GPT-5,6,... biedne kraje staną się jeszcze biedniejsza a bogate jeszcze bogatsze. Już wyjaśniam: generalnie w pierwszej kolejności na automaty przesiądą się Ci którzy już poprzednio próbowali ograniczać koszta przez outsourcing. Także firmy ubezpieczeniowe, banki ogólnie sfera poza stricte IT. Jeżeli pojawi się jakiś dostawca usług IT w stylu GPT Outsourcing Poland i kod będzie porównywalny z kodem hinduskim a cena 30% to firmy zaczną korzystać po wypróbowaniu produktu na kilku ""pilotach"". Z drugiej strony zawód analityka przeżyje renesans, ktoś w końcu musi z tym GPT rozmawiać i to raczej nie będzie pan prezes bo on nie ma ochoty omawiać tych 273 branchy flow do aktywacji karty kredytowej. Zapewne przy GPT-100 ta jedna osoba zastąpi nie tyle wszystkich programistów co cały dział IT! Natomiast w bogatych krajach ludzie dosłownie rzucą się na AI. Już teraz z GPT integruje się kto tylko może. Rynek zaleje fala nowych produktów, to spowoduje wzrost gospodarczy i jeżeli za GPT pójdzie zwiększenie produktywności to wzrośnie również bogactwo tych krajów. To że jedna osoba może zrobić robotę 3 oznacza że usługa będzie tańsza, ergo zwiększy się na nią popyt. Oczywiście część ludzi straci pracę, jak dużo ciężko to teraz przewidzieć. Generalnie biznes ma to do siebie że stara się pozbyć zbyt drogich pracowników, jak programiści będą tańsi to i presja na pozbywanie się ich zmaleje.;"
"Na tym etapie - po co w ogóle kod? Jeśli AI jest takie sprytne, to niech nie tworzy kodu w języku programowania, tylko od razu niech tworzy bajtkod. No i też po co pisać input dla AI? To też bezproduktywne? Przecież można by łatwiej. Gdyby tylko zrobiono coś takiego, że dałoby się wyklikać aplikację i napisać w języku naturalnym logikę, a później AI automatycznie przerobiło by to na bajtkod! To programiści by potracili pracę jak muchy! XD Tylko... że to już było. Jeszcze niedawno się ludzie zachwycali low-code. Czy należy więc oczekiwać, że kolejna fala low-code, opierająca się na AI wreszcie zastąpi programistów? Nie sądzę. Mam wrażenie, że zataczamy ciągle koła wokół wariacji na temat tych samych dwóch idei.  zastąpienie ""trudnego"" programowania przez ""łatwe"" pisanie komend w języku naturalnym albo zbliżonym do naturalnego zastąpienie programowania przez klikanie myszą i wyklikiwanie apek (nocode, lowcode itp.)  I potem ciągle się okazuje, że ""to nie było prawdziwe AI"" albo ""klikanie nie starcza"". Tylko, że:  jeśli programowanie jest za trudne, to może potrzebujemy po prostu łatwiejszych w użyciu (tj. bardziej wysokopoziomowych) języków programowania (i lepszych bibliotek/ekosystemu i łatwiejszych w obsłudze API), a nie protezy za pomocą asystenta, który napisze kod za ciebie. Czyli może lepiej budować kompilatory, frameworki, tooling zamiast nieprzewidywalnego AI klikanie apek się sprawdza w niektórych działkach (gamedev), a w innych działkach niekoniecznie się to przyjęło;"
"Meanwhile, GPT-4 (Ten co was zastąpi jutro) public static void main(String[] args) {         Properties props = new Properties();         props.put(""bootstrap.servers"", ""localhost:9092"");         props.put(""group.id"", ""test-group"");         props.put(""key.deserializer"", KafkaAvroDeserializer.class.getName());         props.put(""value.deserializer"", KafkaAvroDeserializer.class.getName());         props.put(""schema.registry.url"", ""http://localhost:8081"");         props.put(""specific.avro.reader"", ""true"");          KafkaConsumer<String, GenericRecord> consumer = new KafkaConsumer<>(props);         consumer.subscribe(Collections.singletonList(""topic-a""));          Properties producerProps = new Properties();         producerProps.putAll(props);         producerProps.put(""key.serializer"", KafkaAvroSerializer.class.getName());         producerProps.put(""value.serializer"", KafkaAvroSerializer.class.getName());          KafkaProducer<String, GenericRecord> producer = new KafkaProducer<>(producerProps);          while (true) {             ConsumerRecords<String, GenericRecord> records = consumer.poll(100);             for (ConsumerRecord<String, GenericRecord> record : records) {                 GenericRecord value = record.value();                  // Assuming all fields are of type String for simplicity                 value.getSchema().getFields().forEach(field -> {                     String oldValue = value.get(field.name()).toString();                     String newValue = oldValue.toUpperCase();                     value.put(field.name(), newValue);                 });                  producer.send(new ProducerRecord<>(""output-topic"", record.key(), value));             }         }     } };"
"Za 2+ lat rynek się uspokoi, Chatgpt pozostanie ciekawostką jak wiele innych technologicznych rewolucji które dalej są tylko ciekawostką(Autonomiczne pojazdy, VR etc) i będzie można odsyłać młodzików którzy myślą że trzeba posiadać wielkie zdolności analityczne aby zostać programistom do wątków ""Chatgpt zastąpi programistów"" jako motywacja do dalszej nauki.;"
"Miejmy nadzieję, że czacik GPT zastąpi tych darmozjadów w ciągu kilku lat. Tylko kto zwolni tych wszystkich nepotków?;"
"Trochę z mojej strony, odnośnie tego co napisał kolega:  próg wejścia do IT jest OLBRZYMI, między innymi dlatego nikt nie chce zatrudniać juniorów.. w IT zarabia się jednak więcej niż na wszystkich innych stanowiskach w firmie, poza kadrą zarządzającą to prawda, że na działalności można zarobić więcej, ale ze względu na skalę. Jak ktoś myśli, że zarobi miliony będąc fryzjerem to niech się puknie w łeb. Ale rozwijając sieć salonów fryzjerskich.. no to już coś zupełnie innego. 200 zł/g za pracę na niskim ryczałcie to NAPRAWDĘ dużo. Wiem inflacja ostatnio dojeżdża wszystkich, ale poza nieruchomościami przez ostatnie 10 lat inflacja była średnio dużo niższa niż potencjalne podwyżki boom w pandemii sprawił, że w IT zaczęło się pojawiać mnóstwo patologii. Junior po kursie na Udemy za 100zł/g, gdzie 10 lat temu tyle zarabiał senior. Brak podstawowej wiedzy dziedzinowej, jak np. jak działa hashmapa. Ogólne wpuszczenie na rynek mnóstwa 'szrotu', tylko po to aby zapełnić fikcyjne wakaty. Ci ludzie nazywali się programistami, ale tak naprawdę nic nie umieli i teraz lecą jeden, po drugim. robienie kilku projektów jednocześnie, ostatnie naprawdę częsta sprawa, kiedyś naprawdę rzadkość naiwne jest myślenie ze chat GPT akurat zastąpi programistów. Wpierw wymiecie Hindusów, klepaczy Exceli i Powerpointów brak dostosowania się do rynku. Ludzie nie chcą robić w starych projektach z legacy codem (JSF, GWT, Java EE) a z drugiej strony nie znają też chmury, kubertenessa, itp. Siłą rzeczy sami sobie robią pod górkę.  Ogólnie zarobki w IT są wysokie, ale dla tych, którzy naprawdę poświęcili dużo czasu na opanowanie rzadkich umiejętności. Jak ktoś myśli, że jeśli potrafi napisać hello world to dostanie 150 zł//g to się teraz rozczaruje..;"
"idąc dalej w tę (algorytmiczną) stronę:  Parser jakiegoś języka, być może swojego wymyślonego (jakiś prosty DSL?). Sieci neuronowe. Machine learning. Zaimplementowanie algorytmu znajdowania drogi (np. A-star) w prostej grze etc.;"
"Zakladam ze rzeczy z pracy sie nie licza, wiec na szybko:  rozne skrypty do przetwarzanai danych, wyciagania czegos ze stron, automatyzacji etc. Prosciutki timer do Pomodoro (wybieram po jakim czasie chce miec alarm, i po tym czasie wyskakuje dialog). Chyba najczesciej uzywany przeze mnie tool wlasnej roboty:) Prototypy roznych gier Tool do robienia koordynatow do gier (czyli mamy wczytany obrazek, klikamy po nim myszka i zapisujemy wspolrzedne, pozniej mozna to wykorzystac w grze sprawiajac ze postacie chodza po sciezkach ktore nie sa liniemai prostymi i przecinaja sie pod dowolnymi katami). Fraktale (agregacja, Mandelbrot, grafika zolwia etc.) Dawno, dawno prosty chat na bazie TCP/IP, programik do przesylania plikow itp. Przetwazarka grafiki - rozne filtry oparte o FFT do tego cos co wyszlo przypadkiem a bylo bardzo fajne, przetwarzanie obrazkow do ASCII. Mozna bylo u dziewczyn spoza it zapunktowac jak na bazie ich zdjecia podeslalo im sie ich zdjecie w ASCII :) Sieci neuronowe Troche stron internetowych program do budzetu domowego (tu jest ciagle work in progress) prototypy z nauki roznych technologii i zadan kwalifikacyjnych. mnostwo zaczetych i porzuconych rzeczy.;"
"Witam Mam takie pytanie - czy jest możliwość podłączenia się jako klient do czatu zrobionego w javie za pomocą delphi (np. interia itp.)? Chciałbym zrobić program, który nie będzie wymagał javy w systemie i będzie możliwość wysłania jakiegoś tekstu czy rozmawiania z użytkownikiem za pomocą mojego programu. Czy jest taka możliwość? Jeśli nie, to czy mogę zrobić program w javie, który zastąpi oryginalnego klineta moim? W jaki sposób to uczynić?;"
"Ciekawe czy dożyjemy czasów, gdy mikrofon zastąpi klawiaturę ...;"
"Niestety będą musieli, bo będą chcieli zostać ekspertami (kiedyś) ilość ekspertów jest ograniczona, co rok ich ilość zmienia się, spada bo umierają/przechodzą na wczesną emeryturę, zakładają swój business bo ileż można kodzić albo doradzać w projektach za jakieś śmieszne 80k-100k PLN kiedy można być na swoim i cash out robić 300k miesięcznie albo i więcej :) Wracając do początku mojej myśli. Junior będzie chciał się uczyć i kodzić, bo bez tego nie zrozumie języka i jego podstaw, ChatGPT oczywiście pomoże mu w zdobyciu wiedzy ale do pewnego stopnia, bo tego co sam zakodzi nic mu nie zastąpi. Ilość firm będzie wzrastać i potrzebować obok Copilota ekspertów tak jak to piszesz ale tych ekspertów musi przybywać kiedy również ubywa. Jedynie rzeczywiście entry level będzie wyższy i obecne zespoły będzie można z 6-10 osobywych podzielić na 2-3 zespoły po 2-3 osoby z AI i więcej projektów in parallel ogarniać. Ewentualnie pozwalniać juniorów/midów i zostawić seniorów/ekspertów/architektów + AI w uciętym o 50% zespole/zespołach i zatrudniać wyłącznie kolejnych programistów z expert level jeśli firma ma chęć na agresywną ekspansję.;"
"W mojej ocenie Chat GPT nie jest i raczej nie będzie czymś co zastąpi programistę. Jest jednak narzędziem które doprowadzi do rewolucji na rynku pracy w sektorze it. Tak już się działo w przeszłości w innych branżach. Weźcie np. Inżynierów zajmujących się projektowaniem. Kiedyś to był prestiżowy i całkiem nieźle płatny fach. Działy konstrukcyjne zatrudniały po kilkuset ludzi zajmujących się projektowaniem bo robota była robiona ręcznie na deska kreślarskich. Na starych zdjęciach można zobaczyć jak wielkie były biura konstrukcyjne. Obecnie programy typu CAD/CAM sprawiły, że pracę 100 owych  projektantów zastępuje 10 inżynierów. Komputer nie zastąpił tych ludzi ale zwiększył ich wydajność w efekcie obecnie taki konstruktor nie zarabia fortuny bo popyt i podarz ustabilizowały się na neutralnym poziomi. W mojej ocenie w IT będzie podobnie. Wynagrodzenia będą spadać bo zwiększenie wydajności pracy sprawi, że na rynku będzie dostępna spora ilość wolnych zasobów chętna do podjąć zatrudnienie. Konkurencja o miejsce pracy będzie większa tym samym osoby te będą musiały zweryfikować swoje oczekiwania finansowe. Nie sądzę aby zwiększenie wydajności doprowadziło do tego, że będzie produkowana większa ilość projektów bo i po co. Ktoś musi chcieć to kupić. Co do twierdzenia, że pracy na pewno nie zabraknie dla seniorów to nie był bym tego taki pewien. Czas pokażę czy firmy będą wolały zatrudniać drogich seniorów czy w ich miejsc midów którzy z pomocą ChataGPT zrobią tą samą robotę. Osobiście gdybym był właścicielem małego SH wolał bym zatrudnić 3 mid-ów niż 1 seniora z prostego powodu. Gdy ucieknie mi senior tracę 100% mocy przerobowych. Gdy ucieknie jeden z trzech mid-ów tracę 30% i mogę jakoś działać dalej. Co do juniorów pewnie nic się nie zmieni czyli jak była wujnie tak będzie i tylko najlepsi będą się dostawać. O ile będzie jeszcze tak wielu chętnych bo jak fama pójdzie, że w IT skończyło się eldorado to ilu z nich będzie chciało się uczyć/ przekwalifikowywać;"
"Obstawiam, że rynek sam się wyreguluje, był faktycznie przez lata problem, że brakowało na rynku programistów i programista to był poszukiwany zawód. Trąbiło się o tym wszędzie. To spowodowało, że mnóstwo osób się zaczęło przekwalifikowywać, bo rynek ich chłonął. Jednak czara się przebrała i za dużo się zrobiło programistów i w sytuacji dość trudnej ekonomicznie są już zwalniani (stąd masowe layoffy). Powstało również ChatGPT i teraz się mówi o tym, że AI zastąpi programistów. Kij z tym, czy naprawdę zastąpi, ale chodzi o same nastroje społeczne - o ten apokaliptyczny ton, że za późno już, żeby zostać programistą, bo ""AI ukradnie pracę"". Dodaj do tego całą chmarę ludzi, którzy chcą zostać programistami, a nie mogą znaleźć pracy, bo za dużo się zrobiło na rynku juniorskim. Nawet nie tylko juniorskim, na wyższych szczeblach też coraz trudniej. Ogólnie nieciekawie się robi. Myślę, że ogólne ponure nastroje mogą spowodować to, że coraz mniej ludzi będzie się przekwalifikować na programistę i że wkrótce sytuacja wróci do normy i liczba osób programujących zmniejszy się do poziomu, który będzie odpowiadał rzeczywistemu zapotrzebowaniu (bo teraz jest sporo zawyżona, każdy chce dzisiaj programować, a rynek albo nie przyjmuje takich ludzi albo wypluwa z opóźnieniem, stąd layoffy).  Nie potrzeba więcej słabych programistów, tylko więcej ludzi z potencjałem, a mniej ludzi, którzy się do programowania nie nadają. Ktoś z potencjałem może być słaby technicznie, ale się wyrobi. Niestety większość osób się całkowicie do programowania nie nadaje i nawet po iluś latach zostaną słabi.;"
"Tak samo jak automat do robienia kawy zastąpił baristów, tak ChatGPT zastąpi programistów. Tak będzie. Nie zmyślam.;"
"Właśnie się tym chwile pobawiłem i powiem tak. Fajnie narzędzie do nauki programowania czy coś. Ja nie potrzebuje w pracy czegoś co mi będzie przepisaywać język ludzki na ify bo nie widze w tym nic więcej. W realnym projekcie nie zastąpi nawet juniora. EDIT: Jeśli już gdzieś bym upatrywał zagrożenia to w tym że zagraniczne korpa przeniosą się na tańsze rynki np do Indi. EDIT_2: I fajnie że potrafi trzymać wątek, być może ma też przyszłość jako nowa wyszukiwarka, widzę tu duży potencjał żeby ten tool dawał dużo lepsze wyniki wyszukiwania od googla.;"
"Genialne narzędzie. Używam na co dzień zamiast wyszukiwarki w związku z programowaniem lub pisaniem yamli. Poza tym używam go do przygotowywania wpisów na swoje social media. Narzędzie nadaje się również do generowania artykułów, wpisów na blogu lub po prostu zaproponować tematy wpisów. Można go użyć dosłownie do wszystkiego czego się zapragnie, a jeszcze wizja automatyzacji tego to już w ogóle kosmos. Dobrze zautomatyzowane ChatGPT może zastąpić miliony pracowników biurowych, prawników, dziennikarzy, copy writerów, obsługę klienta, a nawet programistów wykonujących proste czynności. Jesteśmy jeszcze we wczesnej fazie, ale już widać potencjał, a przepowiednie wywołania masowego bezrobocia przez AI nie są w ogóle przesadzone. Myślę, że jedyny zawód który powstanie po udoskonaleniu tego narzędzia to moderator AI, a wszystkie inne będę mogły być zastąpione. Z czasem AI zastąpi również ludzi wydających polecenia AI. Aż w końcu nastąpi dzień w którym AI stwierdzi, że ludzie stanowią zagrożenie i nas zlikwiduje albo zamieni w źródło prądu.;"
