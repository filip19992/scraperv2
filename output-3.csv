A jak myślicie czy w przyszłości AI zastąpi grafika całkowicie?;
"oryginalny news: https://www.bloomberg.com/news/articles/2023-05-01/ibm-to-pause-hiring-for-back-office-jobs-that-ai-could-kill#xj4y7vzkg polski: https://www.computerworld.pl/news/W-ciagu-5-lat-IBM-zastapi-30-pracownikow-sztuczna-inteligencja,445372.html;"
"Powinniśmy współczuć, ale redaktorom polskich gazetek, że zostaną zastąpieni przez AI jeszcze szybciej. Szczególnie jeśli redaktorzy jedyne co umieją, to streszczać swoimi zdaniami czyjeś artykuły, które na dodatek albo kiepsko zrozumieli albo kiepsko opisali. Chyba że ChatGPT to pisał.;"
"Nie no, co jak co, ale kiedy AI zastąpi twórców tych artykułów na polskich stronach to poziom wzrośnie diametralnie. Często jest to taka patologia, że grzechem jest czytać bez adblocka.;"
"Dzień dobry! Mam 14 lat i ostatnio pomyślałem sobie: ""Chciałbym się nauczyć programowania, jeśli będę się czuć w tym dobry i będzie mi to sprawiać fun to może będę pracować jako programista"". No i mam zamiar się zacząć uczyć od przyszłego tygodnia już mniej więcej mam plan nauki  jak poznać podstawy podstaw programowania. Jednak też pojawiają się w głowie liczne wątpliwości i pytania... Sztuczna inteligencja rozwija się prężnie. Teraz nie stanowi żadnego zagrożenia dla programistów. Ale co będzie za 5, 10 15 lat? Czy jako nastolatek warto myśleć o wiązaniu kariery z programowaniem? Myślę, że sztuczna inteligencja się tak rozwinie że będzie w stanie myśleć tak jak człowiek, czyli nie tylko klepać kod ale też będzie w stanie dostosować się do problemu jaki przed nią stoi i rozwiązać problem tak jak człowiek - czyli będzie mogła zastąpić człowieka (jak coś to jestem zielony w temacie programowania i na chwilę obecną nie napisałem żadnego kodu i jedynie co zrobiłem to obejrzalem kilka krótkich filmików na YT na temat programowania, więc mogę się bardzo mylić). Nie chcę żeby teraz w liceum przygotowywać się do matury informatycznej a potem iść na studia informatyczne i poświęcać swój czas na coś co okaże się bezużyteczne bo sztuczna inteligencja wyparła programistów i nie ma dla nich miejsc pracy i tak naprawdę te wszystkie lata edukacji poszły na marne. Stąd właśnie takie moje wątpliwości.;"
"Ta AI, która jest teraz, zastąpi sporo programistów, ale nie tyle ile nam się wydaje: a:) myli się b:) ma mały kontekst, kilkadziesiąt tysięcy słów? Oczywiście sytuacja jest dynamiczna;"
"Rozwój techniczny jest szybszy niż kulturowy czy społeczny. Np. potrzeba było aż pandemii, żeby firmy przeszły na pracę zdalną, a teraz i tak wiele firm powraca do pracy stacjonarnej bądź hybrydowej. Ludzie lubią być ludźmi - komunikować się twarzą w twarz (nawet przez kamerkę) itp. Więc potencjalna AI będzie miała utrudnione zadanie. Bo programowanie to nie tylko klepańsko kodu, ale w dużej mierze komunikacja z ludźmi, klarowanie wymagań. Żeby zastąpić programistów, należałoby również zastąpić całą kulturę w firmie i dostosować ją do potrzeb AI. Tak, żeby biznes rozmawiał bezpośrednio z AI, a ona by wykrywała również mowę ciała, emocje oraz używała jakichś heurystyk, żeby odcyfrować, co chce biznes i formułowała własne hipotezy. Plus to, że poza komunikacją, programista też musi umieć rozkminiać coś, przewidywać przyszłe problemy, naprawiać bugi, myśleć o architekturze kodu, zastanawiać się, czy czegoś nie da się prościej zrobić, to też nie jest hop siup, że naklepiesz kod i on będzie. Nie wiem, czy obecnie AI jest w ogóle na takim poziomie. Bawię się czasem ChatGPT 3.5 (w tej darmowej wersji) i to jest mega-imponujące biorąc pod uwagę, że to komputer wymyśla, jednak jeśli to porównać do człowieka, to ChatGPT to taki wyuczony przygłup, który dużo widział i dużo podpowiada i może być przydatny jako chodząca encyklopedia, ale jednak nie potrafi myśleć głębiej, podejmować bardziej głębszego rozumowania, a jak czegoś nie wie, to zmyśla. Gdyby ChatGPT byłby człowiekiem, to strach byłoby takiego zatrudnić.;"
"Może po prostu ktoś powiedział ""król jest nagi"". Ludzie myśleli, że wykonują zawód intelektualny, a w rzeczywistości robili coś rutynowo, co AI może zastąpić za pomocą zwykłej statystyki i przewidywania wzorców. Jednak zawód umysłowy to dzisiaj zwykle zawód społeczny. Potrzebni tak czy siak będą ludzie, żeby gadali z innymi ludźmi, zbierali wymagania, a potem ""gadali"" z komputerem, tłumaczyli z ludzkiego na komputerowe i odwrotnie. Dzisiaj się to nazywa programista, jutro może się to nazywać prompt engineer. Myślę, że całkowita rewolucja będzie wtedy, jak AI będzie potrafiło samo zaprojektować apkę, oraz ją zaimplementować w całości i rozwijać (reagując na feedback od użytkowników), ale na razie o tym chyba się nie mówi jeszcze. AI dzisiaj używa się miejscowo, a nie całościowo. A wyobraźcie sobie usługę, gdzie zamawiasz grę np. mówisz zrób mi MMORPG dziejące się w klimatach średniowiecznej Polski i komputer robi. A potem mówisz przerób, żeby był większy nacisk na ekonomię, a mniej na walki i komputer zmienia. To dopiero byłoby AI.;"
"Na dzień dzisijeszy klienci mają zbyt niesprecyzowane potrzeby i zbyt popi$%dolone pomysły by ai to ogarniała. Jeszcze sporo wody w wiśle upłynie zanim ai nas zastąpi, ale o pracę się nie martwię, bo jak ai nas zastąpi to już nikt nie będzie pracował, będzie globalny komunizm :);"
"Jak widzę takie przykłady, że ktoś coś wrzucił w AI i wypluło mu kod, to po prostu automatyzacja tego, co od lat ludzie robią za pomocą Google i StackOverflow. Czy istnienie StackOverflow zagroziło jakoś zawodowi programisty? No nie, wręcz przeciwnie. Obstawiam, że takie zabawy skończą się tym, że Microsoft i Jetbrains będą dodawać do swoich IDE jakieś machine learning (Microsoft już robi Copilota), a nie że nagle programiści zostaną zastąpieni przez AI. Już prędzej no-code zastąpią programistów, bo designerzy będą mogli wyklikać apkę i się skompiluje do HTML/CSS/JS. Tylko znowu, narzędzia no-code (wcześniej znane jako WYSIWYG) też nie są wcale nowe.;"
"@obscurity: W końcu gdzieś czytam opinie zbliżona do mojej, a przynajmniej tak ją rozumiem, że implementacja (pisanie kodu) to jedynie pisanie bardziej szczegółowych wymagań, w sformalizowanej i łatwej do zrozumienia przez komputer formie. Według mnie, jedyną prawdziwą przeszkodą na drodze do zastąpienia nas (programistów) przez AI jest w tej chwili problem w komunikacji pomiędzy AI, a człowiekiem. To nie dotyczy jedynie web dev, a ogólnie całego programowania. To co robimy jako software developerzy (czy jest jakiś sensowny polski termin?), to przełożenie jakiegoś mglistego wymagania ""chcę mieć ładną stronkę"" na coś co wyświetli się w przeglądarce i będzie robiło to czego oczekuje zamawiający. Najtrudniejszym zadaniem w tym wszystkim nie jest napisanie takiego CSS, żeby jakiś element wyświetlił się na środku okna, ale wyciągnięcie od zamawiającego informacji czego konkretnie oczekuje. Jakie możliwości ta aplikacja ma mu oferować, wspomaganie się własną wiedzą, żeby uzupełnić te braki, o których zamawiający nie pomyślał. Średnio ogarnięty programista (znający język programowania, którego używa), większość czasu spędza na dowiadywaniu się co ma zrobić, a nie zastanawianiu się jak ma to zrobić. Ta druga część staje się zresztą coraz łatwiejsza, bo potrafimy sobie stworzyć wygodne dla człowieka narzędzia (języki programowania). Jestem sobie w stanie wyobrazić taki działający w oparciu o AI system, który rozmawia z zamawiającym i w czasie rzeczywistym tworzy program robiący to, czego ten zamawiający oczekuje.  Siri, chcę stronkę! ""pyk"" no ale nie taką, ja chcę sklep, a nie stronę porno ""pyk"", już poprawiam większość stron w Internecie to porno, wybrałam najbardziej prawdopodobny przypadek ok, rozumiem, ale teraz przegięłaś w drugą stronę, motywy biblijne nie pasują do seks shopu ""pyk"", już poprawiam Dużo lepiej, powiem nawet, że nieźle, ale to ma być sklep dla par i kobiet, a ty wrzuciłaś wszędzie facetów w skórach z kutasami na wierzchu... ""pyk"" Poprawiłam ""Normalna rodzina, chłopak i dziewczyna""?! I jeszcze wszystko w barwach narodowych?! Przecież oni nie bzykają, w dodatku teraz inkwizycjobot 2.0 biega po Internecie i nas spalą, albo ukrzyżują, nie wiem tylko co pierwsze.... Chcę internetowy seks shop dla heteroseksualnych par i kobiet, nie obrażający mniejszości seksualnych i bez nawiązań religijno-patriotycznych Nie znalazłam rozwiązania, które nie obraża nikogo. No dobra, to troche może... ""pyk"" No widzisz, jest ok, pastele, parka się całuje, o to chodziło. Jeszcze powiększ jej trochę cycki, a on ma miec garnitur a nie t-shirt i zrobione..;"
"Przede wszystkim szum medialny sprawia, że wygląda to tak jak to opisujesz. W mediach słyszymy, że za parę lat programistów nie będzie, bo komputer sam się zaprogramuje. Każdy będzie miał rozumnego robota w domu. Wszystkie zawody przestaną istnieć, bo mądre roboty nas zastąpią. To wynika z tego, że media pisząc sztuczna inteligencja mają wyobrażenie robotów rodem ze Star Warsów. Dla nich jakiś bardziej rozbudowany algorytm, który nawet niekoniecznie ma cokolwiek wspólnego z jakąkolwiek sztuczną inteligencją jest już niemalże takim robotem. Wyobrażenie o C3PO we własnym domu + wrzucanie machine learning, strong AI, weak AI itd. do jednego worka = taka sytuacja. Duży szum, brak widocznych osiągnięć.;"
"Hej, AI do składania zamówień, to raczej nie jest dobry pomysł :) Excel, plus jakieś zrzuty z (ewentualnego) systemu, plus zdrowy rozsądek. No i nic nie zastąpi rozmowy z drugim Człowiekiem, szczególnie w negocjacjach, mimo, że u nas to nie jest modny temat, i ludzie się bardziej targują (o ile to robią) niż negocjują :);"
Ehh i gdzie ta sztuczna inteligencja co ma nas zastąpić...;
https://pl.investing.com/news/economy/gigant-informatyczny-rozwaza-zwolnienie-30-pracownikow-ma-ich-zastapic-sztuczna-inteligencja-384433;
@bakunet: Tytuł: Gigant informatyczny rozważa zwolnienie 30% pracowników. Ma ich zastąpić sztuczna inteligencja. Faktyczna liczba pracowników: 288 000 Tekst:  click bait;
"Jeszcze kilka miesięcy temu, testując GPT-3, w sporze pod tytułem ""czy AI zastąpi programistów"" byłem raczej po stronie twierdzącej ""nie sądzę"". Ale z biegiem czasu zaczynam mieć coraz więcej wątpliwości. Do napisania tego posta zainspirował mnie filmik pewnego dotnetowego youtubera, który użył go do napisania webowego API. O ile wcześniej trzeba było faktycznie ""popychać"" model w odpowiednim kierunku, sugerować mu rozwiązania, wytykać błędy, to tu właściwie mamy przykład utworzenia małego serwisu tak po prostu bez większych problemów. Był na filmie problem z hasłami w connection stringu, ale zauważcie że ze strony użytkownika nie trzeba było podpowiadać żadnych konkretów. Nick wpisał po prostu ""zrób żeby było bezpieczniej"" a GPT tak zrobiło. Problem ze skalowaniem? Wpisał ""zrób żeby się skalowało"". I tyle. Coś co zajęło mi długie lata nauki, testowania, prób i błędów, tutaj dostajemy w parę sekund. Ze skutkiem może i nawet lepszym. Ktoś mógłby powiedzieć: no dobra, ale tu jest tylko pokazane proste API. Ale czy mamy właściwie przesłanki żeby twierdzić, że z większym projektem nie będzie to działać podobnie? Ogranicza nas teraz liczba tokenów, które model jest w stanie przyjąć. Ale czy to faktycznie jest nie do przeskoczenia w ciągu najbliższych paru lat (a może miesięcy)? Czyżbyśmy właśnie byli świadkami momentu w którym nauka składni języków i algorytmów przestaje mieć sens? Czyżby stereotypowy, aspołeczny programista studiujący ficzery różnich języków właśnie przestał być potrzebny, a jedyne co zostanie na rynku to osoba definiująca wymagania biznesowe?;"
"Trochę nie rozumiem, czemu ""osoba definiująca wymagania biznesowe"" ma się ostać. Mając dane i metody analizy tych danych to AI będzie generować wymagania biznesowe. Ludzie od biznesu i wykonujący inny ""bullshit job"" wmawiają innym, że są potrzebni, bo mają jakieś nieuchwytne ""umiejętności miękkie"" rzekomo nie dające się zastąpić przez machine learning, podczas gdy taki Netflix już teraz wykorzystuje ML to do decyzji biznesowych https://research.netflix.com/research-area/machine-learning to wykracza już poza technikalia. To, co kiedyś robili chómaniści, teraz może robić ML.;"
"Jak sie ktoś boi, że zostanie zastąpiony przez AI to najlepiej będzie jak już teraz się zwolni;"
"Ja od dobrych kilku miesięcy pracuje  ChatGpt + Copilot (firma nam kupiła), jak na razie chata czy tam barda od google wykorzystuje się fajnie właśnie do opisu jakieś rzeczy, napisani testu jednostkowego małej funkcji, czy tłumacza... Copilot dla mnie super opcja... ale trzeba dokładnie czytać co generuje bo potrafi się bardzo często mylić... oj bardzo albo generować straszny kod :( Wiec bez review doświadczonej osoby ani rusz. Na ten moment jako inteligenty inteli code super sprawa i nie chciałbym z tego rezygnować... ale do zastąpienia to chyba jeszcze nie ten czas.;"
"Kiedyś czytałem na jakiejś anglojęzycznej stronie, że jak ludzie zastąpią wszystkie języki skryptowe i te korzystające z maszyn wirtualnych typu JVM, CLR językami kompilowanymi typu C/C++, Rust to roczne zużycie energii na świecie może spaść o jakieś 75%. Ale co będzie jak sztuczna inteligencja będzie mogła wszystko napisać i przepisać do asemblera? W porównaniu do C to jeszcze bardziej obniży koszty energetyczne?;"
"artykuł:   Serio będziemy lykać propagandę, że już lada moment ""AI nas zastąpi"", skoro AI to ciągle matematyczny model statystyczny przewidujący kolejne słowa (nie tak działa nasz mózg) -ani ""sztuczna"" ani ""inteligencja"", na razie to matematyka z dużą mocą obliczeniową;"
"mam nadzieję, że chatgpt zastąpi programistę, który zastanawia się co zrobić, gdy chatgpt zastąpi programistów i wtedy nie będę musiał się zastanawiać;"
"Założę jednoosobowy software house Dokończę wszystkie moje nieukończone projekty Podłączę AI do sztucznego ramienia, każę napisać program który zbuduje robota Zakładam restauracje w pełni obsługiwaną przez roboty zaprogramowane przez AI, można zamówić dowolne danie z każdej kuchni świata i zawsze wychodzi perfekcyjnie Składam armię robotów która będzie pracować na mnie W tym momencie mógłbym przejąć władzę nad światem, będąc ochraniany przez armię robotów, ale zamiast tego likwiduję jedynie rządy całego świata i zastępuję AI. Urzędy nie będą za chwilę potrzebne ponieważ w kolejnych krokach wszystkie miejsca pracy zostaną zlikwidowane i zastąpione robotami. Zakładam plantacje, magazyny, transport w pełni obsługiwane przez roboty. Zmniejszam do minimum potrzeby transportu przez hodowanie, uprawę i produkcję lokalną na całym świecie. Transportowane będą tylko niedostępne lokalnie surowce, likwiduję transport gotowych wyrobów. Liczę że pozwoli to na zmniejszenie zanieczyszczeń, głodu na świecie, depresji i tiktoka. Ludzie nie muszą na nic pracować, pieniądze zresztą i tak nie mają w tym momencie sensu. Następuje zapaść behawioralna, ludzie wymierają. Światem rządzą roboty i AI. Brzmi niewiarygodnie? Poczekaj tylko na GPT-5;"
"Razem z kumplami z projektu zakładamy firmę budowlano-remontową. Na razie robimy kosztorys i panujemy zakupy. Myślimy ,że jeszcze 2,3 lata i AI nas zastąpi więc szykujemy się na najgorsze.;"
"Bo źle patrzysz, ona nie ma pomóc userowi tylko zastąpić usera. A w takim przypadku możesz zaoszczędzisz trochę na QA, stress-testach a nawet zoptymalizować trochę ruch na potrzeby analityki. Tyle możliwości.;"
"Na businessinsider można przeczytać, że firmy zwalniają ludzi od tworzenia gier. W tle kluczowe wydaje [mi] się IA, bardziej niż to co tam wymienili jako kluczowe. Warto wspomnieć że Duolingo sam wydał oświadczenie że zwalnia 10% ludzi na rzecz IA. https://businessinsider.com.pl/technologie/nowe-technologie/branza-gier-zaczyna-sie-sypac-powody-zwolnien-sa-jeszcze-gorsze-niz-w-it/pmvgel5  Dla jednej Szczecińskiej firmy w której robię ostatnio umowy, redukują 80% stanu programistów :-D - czyli z 5 - zostanie 1. Tam nie kryją, że ze względu na IA i jego automatyzację. Jeden typek będzie obsługiwał teraz wszystko  jako nadzór, oraz ewentualne dostosowania. Jedna z wielkich firm dla jakich pracuje okazjonalnie (którą każdy z was zna :-D na 101%) właśnie robi próbne testy, czy da się i w jakim zakresie zastąpić ludzi od księgowości kontraktów i wyliczeń wartości obmiarów kontraktowych... Powoli zaczyna robić się ciekawie i przyspieszać automatyzacja. Warto jednak cofnąć się o 15 lat wstecz - czy wiecie ile ludzi pracowało dawniej nad filmem dobrej kasowej produkcji amerykańskiej, nawet kilka tysięcy. Obecnie automatyzacja zastępuje ich większość, od kadrów, efektów itp. Więc będzie to pochłaniało coraz więcej zawodów umysłowych... bezpieczni nadal są elektrycy, kafelkarze i całkowicie zbędny oraz szkodliwy element, którym są politycy.;"
"To mi przypomina szał na no-code. Kilka lat temu to miało zastąpić programistów, a teraz jakoś temat magicznie zniknął i weszła narracja, że to AI zabierze pracę. Robią nas, jak chcą. A nawet w tym artykule piszą, że w tych zwolnieniach chodzi bardziej o biznesowo-ekonomiczne fluktuacje (jakaś firma przesadziła z ekspansją i przestrzeliła się z estymacjami. itp.). A o AI artykuł wspomina tylko na szarym końcu jako pewną spekulację.  Moim zdaniem problemem jest konserwatywne przywiązanie firm do tego, żeby zmuszać pracowników, żeby pracowali na 40 godzin w tygodniu, nawet jak nie mają tyle do roboty, żeby zapełnić te godziny (albo jeśli jako ludzie i tak nie są w stanie być produktywni przez 8h, bo jednak praca umysłowa wymaga pewnego skupienia). Szczególnie programiści, którzy zarabiają kilka razy więcej od innych ludzi, więc zatrudnianie ich na cały etat i jednoczesne niewykorzystanie ich potencjału to masa hajsu w błoto. Więc firmy, gdyby były rozsądne, to zatrudniałyby na pół etatu oszczędzając hajs. Ale teraz już po herbacie, bo ludzie już skapnęli się, że firma płaci jak za cały etat, nawet jeśli roboty jest tylko na pół etatu, więc co bardziej pracowici zaczęli robić OE, a ci mniej pracowici po prostu robią mniej, a dostają tyle samo. Więc pół etatu za 50% hajsu już dzisiaj nie jest zbyt atrakcyjne, skoro można się zatrudnić na cały etat i robić pół.;"
"Czemu podałeś link w taki sposób żeby nie dało się go kliknąć Powody są podane w tym artykule i bynajmniej nie jest to AI Przykład podany w artykule że ktoś był w stanie za pomocą AI w pojedynkę stworzyć grę przypominającą Angry Birds. Czy ktoś w ogóle miał wątpliwości że jedna osoba jest w stanie stworzyć klon angry birds nawet bez pomocy sztucznej inteligencji? Co to mają za sztuczną inteligencję że zastąpi 80% programistów? Znane mi narzędzia być może byłyby w stanie zastąpić może 20% i to tylko przy założeniu że robili jakieś powtarzalne bzdety. Nie pozostaje nic tylko życzyć tej firmie powodzenia. U mnie w firmie jakiś czas temu dano wszystkim copilota, od razu otwarcie powiedziano że mają nadzieję oszczędzić w ten sposób 0.5 miliona dolarów rocznie. Dzieląc to przez średnią pensję programisty w firmie wychodzi że liczą na zastąpienie 0.1% programistów co jest moim zdaniem dość realnym oczekiwaniem.;"
"Bo nie chcę promować tej strony. Ostatni punkt IA w tle przecież jest opisany na tamtej stronie, a moim zdaniem pewnie dominujący. Nie wiem tego, ale na pewno wystarczy mniej ludzi do ogarnięcia niż dawniej skoro wiele rzeczy można zautomatyzować i przyspieszyć. IA to nie tylko to co znamy a open IA ale także są dostosowane boty do zadań - niektóre gałęzie mają takie dostosowane do ich typów działalności w dużym zakresie. A jednak zastąpi w przypadku tej firmy - gdzie było ich 5 i robili na bazie potrzeby dostosowania do wykonywanych zadań przez urządzenia.  Myślę że to będzie się zmieniać, na pewno będą przemiany kultorowo pracownice dzięki takim rozwiązaniom. Powoli już je widać. Jak tutaj przykład wcale nie najnowszego generatora - co z 1 fotki robi film do podkładu.;"
"Odnoszę takie samo wrażenie. Połowa to boty hrowe, 1/4 jacyś frustraci życiowi, którzy nie zgadzają się z każdym autorem wątku o czymkolwiek by nie był aby tylko się nie zgadzać co do zasady, paru trolli i może z 10% to serio programiści, którzy opiniują obiektywnie dany temat, tak jak jest w rzeczywistości. To był mój ostatni wątek około karierowy na tym forum, bo widzę, że tutaj jakakolwiek poważna dyskusja nie ma sensu. To co jest na forum, czy linkedinie, a to z czym się spotykam na co dzień w pracy, w projektach, rozmawiając ze znajomymi z branży to jakby 2 różne światy. Nie znam nikogo kogo by zwolnili z projektu/z kontraktorni, nie znam nikogo komu by kazali przyjść do biura ze 100% remote, nie znam nikogo kto by pracy szukał dłużej niż tydzień. Jedyne co mnie boli to to, że samych ofert na linku dostaję coraz więcej w hybrydzie i tak jak ktoś wyżej napisał traktuję to jako zwykłe ""sprawdzam"" hr-owców, tak samo jak i większość tych wysrywów w niniejszym wątku. ps, ucinając jakieś powyższe spekulacje, nie szukam pracy i jestem świeżo po podwyżce, ale lubię mieć kontakt z rynkiem pracy i czasem chodzę na rozmowy dla sportu. Tak, kupiłem chatę na zadupiu, bo wolałbym się zastrzelić niż mieszkać w betonozie. Nie muszę pracować w IT, mam już inne źródła dochodu, których się dorobiłem ciężką pracą, także jak kiedyś stanę przed wyborem iść do pracy stacjonarnej czy olać IT to wypnę gołą dupę w stronę branży i tyle mnie widzieli. Na dzień dzisiejszy mam 30k papieru na fakturze z jednego projektu i kontraktornia prawie całowała mnie po rękach jak przedłużyłem kontrakt. Oczywiście o jakiejś hybrydzie nikt mi nigdy nawet nie wspomniał, bo bym się posikał ze śmiechu. Jak przychodziłem do firmy to powiedziano mi, że fajnie jakbym wpadał do firmy chociaż 2-3 roku się pokazać, na jakieś grubsze planningi. Zaznaczyłem od razu, że nigdy tam nie pojadę, bo nie ma takiej potrzeby i w żaden sposób nie wpłynie to moją pracę więc nie będę tracił czasu. Od tamtej pory temat nigdy się nie pojawił. Fakty są takie, że albo ktoś jest mężczyzną, fachowcem, albo popychadłem, który dzisiaj jest na remote, a jutro biegnie na hybrydę bo się boi, że ktoś go zastąpi, albo Pan manager okrzyczy.;"
"Ja do tej grupy dorzuciłbym jeszcze 'wanna be' programistów. Świetnie widać to w wątkach z chatgpt, gdzie namiętnie piszą jak to już za chwile całe działy IT zastąpi jedna osoba. Co do tematu, to mam podobne spostrzeżenia. Ustępstwa i zgadzanie się na kolejne durne pomysły to sranie do własnego gniazda. Jeśli w firmie dostarcza się 'wartość' i jest to w dodatku widoczne w jakimś backlogu to jest się bezpiecznym. Zwłaszcza jeśli poza wiedzą techniczną idzie wiedza domenowa.;"
"Serio kobietom placicie mniej? Macie gdzies jakies widelki typu, ""dla perfekcyjnego kandydata: max 30k, dla perfekcyjnej kandydatki: max 15k"" ?  Alez aplikacje typu facebook sa bardzo potrzebne. Sluza do tresowania nowego pokolenia komunistow.  Komunizm w najczystszej formie. Po co samemu miec lepiej jesli da sie zrobic zeby wszyscy inni mieli gorzej.  Bzdura. AI w najblizszym czasie nie ma kompletnie zadnych szans zastapic programistow. Ale takie idiotyzmy to potrafi wypisywac ze np. dziennikarze czy politycy moga niedlugo byc niepotrzebni. Moze  programisci zarabiaja troche wiecej niz w niektorych innych zawodach dlatego ze takie oczywiste rzeczy sa dla nich oczywiste (no ok, czytajac to forum dla wielu nie jest) ? A moze dlatego ze potrafia takie AI napisac (no ok, wiekszosc nie potrafi) ?;"
"jestem dosc blisko z szefem w kontraktorni który jezdzi na wszystkie spotkania biznes-it z wazniejszymi ludzmi (mimo ze spolka jest mała) i powiedzial mi, ze firmy it chca zastapic rekruterów it sztuczna inteligencja, a dzieki zaoszczezdzonej kasie (podobno rekrutacje sa w cholere drogie wbrew pozorom) zatrudniac wiecej programistow potwierdzone info z pierwszej ręki a tak w ogole to przez tyle lat powstawały narzedzia, ktore umozliwiaja ludziom nietechnicznym tworzenie stron internetowych (edytory wyswig), aplikacje wspierane przez najwieksze korpo ktore wspomagaja tworzenie flow/przeplywu danych (cos jak program robiacy program)... a programistow nadal brakuje no i w mojej ocenie w stosunku do marca polepsza sie (jak takiemiu cieniasowi jak ja daja coraz lepsze oferty to wiedz ze cos sie dzieje, a w wakacje z reguly sa male zastoje);"
"Na pewno łatwiej zastąpić tzw ""rekruterów"" bo zawsze łatwiej zastąpić ludzi do niczego nie potrzebnych. Zamiast normalnego cv może być przecież formularz online, dane mogą być filtrowane automatycznie i zaproszenia na rozmowę mogą być też wysyłane automatycznie, w terminach wygenerowanych automatycznie na podstawie firmowego kalendarza. Nie trzeba tu nawet żadnego AI. Tzw rekruter to sztuczne stanowisko do niczego nie potrzebne, może jakieś aktywne negocjacje i szukanie pracownika miało sens jeszcze do niedawna gdy był rynek pracownika, teraz już będzie to się zmieniać. Przy czym tzw pani z hr jedyne co, to ma być ozdobą, a zazwyczaj jest po prostu osobą mało rozgarniętą, o zerowej wiedzy na każdy temat a już zwłaszcza w dziedzinie it.;"
"Tak, natomiast można napisać ""continue"" i chat kontynuuje długi tekst, który się nie zmieścił. Dodatkowe ograniczenie to maksymalnie 25 wiadomości na 3 godziny z ChatGPT-4, po przekroczeniu limitu dostajemy informację o której godzinie blokada zostanie zdjęta i propozycję przejścia na ChatGPT-3.5. Na korzystanie z ChatGPT-3.5 z kolei nie ma żadnego limitu i można korzystać do woli. ChatGPT-3.5 z wersji płatnej odpowiada dużo szybciej niż darmowy, z kolei ChatGPT-4 odpowiada wolno, podobnie jak darmowy, za to odpowiedzi są lepsze jakościowo. Kolejna korzyść dla płacących to dostęp do nowości przed ich wprowadzeniem do wersji darmowej. Na razie ChatGPT nie ma pluginów. Z tego względu nie ma dostępu do internetu, ani nie możemy go zapoznać z naszym repozytorium na Github i poprosić o poprawki w kodzie. Natomiast to tylko kwestia miesięcy kiedy Microsoft to zrobi. Już zapowiedzieli GitHub Copilot X oraz zapowiedzieli pluginy do ChatGPT. W końcu w tych usługach pojawi się coś na podobieństwo AutoGPT czyli ChatGPT sam zapozna się z kontekstem aplikacji i będzie sam tworzył pull requesty, a wtedy serio juniorzy mogą zacząć się bać. Tysiące stanowisk pracy w IT będzie zagrożonych, im bardziej powtarzalna i mniej skomplikowana praca tym większe ryzyko zastąpienia pracowników przez AI.;"
"Uczyć się robić bardziej skomplikowanych rzeczy np właśnie tworzenia model AI, albo klepania bardzo dużych projektów itd Coś w czym sztuczna inteligencja nas nie zastąpi jeszcze przez długie lata. Ale w sumie nie wiem czy QA zastąpi AI bo oni mają testować to tak jakby było użytkownikami a nimi są ludzie, więc w tym wypadku AI nigdy nie zastąpi człowieka myślę;"
"Nie wiem ale wydaje mi się że sztuczna inteligencja zacznie wypierać prawdziwą. Jeśli nie będzie motywacji do uczenia się czegokolwiek bo AI zrobi to szybciej, lepiej i wystarczy tylko zapytać to społeczeństwo dość szybko zidiocieje. Szykuje się prawdziwa idiokracja. Nie wydaje mi się żeby jakikolwiek zawód był bezpieczny jeśli AI zdoła zastąpić programistów. Wszystko będzie w takim razie mogło być zautomatyzowane po zerowych kosztach i będzie.;"
"AI to jest sztuczny twór, zastąpi najpewniej pewne zawody, ale tylko niektóre. Problem z AI jest taki, że to będzie czyjaś własność (przynajmniej na początku) i można ja sparametryzować - trochę to przypomina kontrolę nad szlakami handlowymi i przepływem pieniędzy. Drugi problem jaki dostrzegam - nie da się zastąpić dobrej jakości prac rzemieślniczych (nie mówie tu o stukaniu młotkiem w kawałek metalu) i już. Inspiracja i talent to jest jakby punktowe IQ na poziomie infinity, żadne AI nigdy temu nie dorówna. Odtwarzanie istniejących rzeczy w różnych permutacjach / wariantach - spoko, kreacja - to jest jakby niewykonalne z definicji, bo nigdy nie powstanie model działania przewyższający wyobraźnię. ""Pojemność"" umysłu i jego kwantowa natura jest niewyobrażalna.;"
"Opiszę sytuację z pracy mojego Kolegi. Zatrudnili gostka który nakłamał w CV, czego on nie umie do analizowania danych. Rozbraja mnie, że rekrutują człowieka bez sprawdzania wiedzy ale skoro firma chce wywalać pieniądze kto jej zabroni. Gostek młody jeszcze student, wciąż opowiada jak to AI zastąpi wszystko. Jest on totalnym głąbem który nic nie ogarnia. Ciężko mi to pisać bo to takie irracjonalne ale odkrycie znaku nowej linii to było dla typa coś nielada wielkiego. Wszystko co robi, robi używając chatGP. Jest właśnie w fazie wylotu z firmy. Bo szefostwo się pokapowało po sześciu( !!! ) miesiącach, ze zatrudnili idiotę. Także zbytnia wiara w Ai zdecydowanie może przybliżyć do bezrobocia. + generować tylko więcej problemów gdy jakiś przygłup traktuje to co wypluwa za prawdę objawioną;"
"Moim zdaniem obawa, że AI zabierze pracę programistom, jest słuszna jak na warunki 2023, ale w perspektywie np. dekady okaże się, że nie. Po prostu teraz dokonał się przełom i zobaczyliśmy cuda i wydaje się nam, że AI nas zastąpi. Ale potem spowszednieje to i trzeba będzie wrócić do prawdziwej roboty. I dokonać jakiejś reewaluacji tego, co to znaczy być programistą (bo już nie można będzie powiedzieć, że ""programista pisze kod"", tylko trzeba będzie się szerzej zdefiniować np. ""projektuję architekturę rozwiązań technologicznych"") Swoją drogą ja się zastanawiam, czy ChatGPT mogłoby pomóc również w architekturze - np. tutaj gościu kazał napisać AI 5 mikroserwisów: https://twitter.com/joeprkns/status/1635933638725451779 a jeśli tego byłoby więcej - czyli co jeśli ChatGPT pisałoby 100 mikroserwisów (albo jakiś złożony monolit podzielony na wiele modułów). Czy zaprojektowałoby dobrą architekturę do tego? Na ile to jest utrzymywalne na większą skalę? Czy ChatGPT umiałby się poruszać we własnym spaghetti czy jednak jego własne spaghetti by go powstrzymywało i nawet apka pisana w 100% przez AI musiałaby być dobrze zaprojektowana?;"
"To zastąpienie pracy programistów/QA będzie po czy przed zastąpieniem kierowców przez samochody autonomiczne? Pogubiłem się już w tych szurskich teoriach, a nie wiem, czy opłaca się przebranżowić na kierowcę :⁠-⁠|;"
"15 minut gadania o czymś co może trwać 30 sekund byle żeby wcisnąć więcej reklam. Nie obejrzałem całości bo mam ciekawsze rzeczy do roboty ale zgaduję, że to ten sam typ gadania który wraca do kilka miesięcy, wiec strzelam że nadal potrafi pisać tylko nowe rzeczy. Nie naprawi buga w programie na 2mln linii kodu, więc czuję się bezpiecznie. Prędzej AI zastąpi ludzi którzy produkują filmy na 10+minut żeby algorytm YT mógł proponować ich filmiki.;"
"No myślę, że na tym etapie mógłby zastąpić kierownictwo średniego szczebla w dowolnej firmie. (A także naszego premiera.);"
"Do tej pory podchodziłem mocno sceptycznie do tego, że AI zastąpi programistów ale coraz bardziej jestem przekonany, że eldorado w IT skończy się, a zarobki bardzo mocno spadną.;"
"Jestem backend developerem w Javie no i chciałem utworzyć prosty Front do mojej aplikacji w Angularze wykorzystując Boostrapa. Ogólnie w Angularze programowałem tyle co jakiś projekt na studiach. No ale ogólnie jestem zielony. Podając czatowi GPT przykładowe responsy z backendu w JSON'ach i prosząc go o robienie logiki byłem w szoku. Ale w ciągu jednego dnia napisał mi cały Frontend aplikacji gdzie mam dość ładne UI, możliwość przewijania, scrollowania, dodawania, odejmowania rzeczy i komunikację z backendem. Opisywałem mu logikę backendu i on dostosował zmiany. A tak jak mówię, z Angulara i Boostrapa, frontendu jestem totalny noga. Bez czatu GPT robiłbym coś takiego po godzinach tydzień? Tutaj byłem w stanie wygenerować cały widok w jeden dzień. Naprawdę do dzisiaj jestem w szoku. Jeszcze 5 lat temu normalnie klepałbym to po Bożemu, zaczynając od nauki Angulara na Udemy, następnie metodą prób i błędów robiłbym front. Tutaj od razu dostaję kod i jeszcze w razie czego mogę zapytać o wytłumaczenie. Wnioski jakie mi się nasuwają, to że np. taki czat mi zastąpił Juniora w Angularze, ale naprawdę boję się co będzie za kolejne 5-10 lat, bo to co teraz widzimy to dopiero przedsmak :D;"
"Wiele już napisano i powiedziano o GPT, ale moim zdaniem to nie jest taki game changer jak go przedstawiają. Owszem- może pomóc, może nawet zastąpić programistę w prostszych sprawach, ale jest wiele rzeczy, które programista zrobi lepiej (może zacząć od rozwiązania zaproponowanego przez GPT, a potem je optymalizować). I nie czarujmy się- z każdego materiały czy to jakieś forum czy GPT trzeba umieć korzystać. Do dziś pamiętam jedno kolokwium na studiach- prowadzący pozwolił nam mieć wszystko- laptopy, książki, notatki, kalkulatory. I co? I większość nie zdała, chociaż odpowiedzi były tu i tam, ale nie potrafiła z nich skorzystać i sklecić czegoś sensownego.;"
Ma ktos info kiedy wreszcie AI zastapi dzialy reklamacji w bankach?   ai.png (44 KB) - ściągnięć: 5;
"Świetne dialogi, świetnie nakręcony. Jeśli nikogo nie zmierzi fakt, że w dialogach język portugalski został zastąpiony angielskim, to polecam serial Shōgun;"
"Dziedziczenie i metody abstrakcyjne można zastąpić do pewnego stopnia domknięciami. Tzn zamiast: class Klasa {   def metoda: Int =      doNadpisania + 1    def doNadpisania: Int // abstrakcyjna metoda do nadpisania w podklasach }  można napisać: class Klasa(doPodaniaZZewnątrz: () => Int) {   def metoda: Int =     doPodaniaZZewnątrz() + 1 }  Ktoś kto bardzo nie lubi OOP, dziedziczenia, metod wirtualnych, etc będzie się bardzo cieszył, ale moim zdaniem nawigacja i analiza kodu bardzo cierpi na tym, przynajmniej w obecnych IDE typu IntelliJ. Mając klasę IntelliJ po jednym skrócie klawiaturowym pokaże mi hierarchię dziedziczenia. Przy metodzie IntelliJ pokaże ikonki dzięki którym szybko można dojść do metod nadpisanych lub nadpisujących/ implementujących. Inaczej mówiąc w przypadku OOP nawigacja w kodzie jest ""pierwsza klasa"". W przypadku domknięć/ lambd natomiast jest strasznie kiepsko bo te lambdy mają tendencję do bycia przesyłanymi wzdłuż i w poprzek, więc samo ich szukanie wybija mnie z toku myślenia. Dziedziczenie i kompozycja działają dla mnie lepiej niż szastanie lambdami. Z drugiej strony mamy pojedynek dziedziczenie vs kompozycja i tutaj nie ma wygranego, bo oba podejścia mają sens. Dziedziczenie jest lekkie jeśli hierarchia klas jest lekka i w takich przypadkach dobrze się sprawdza. Kompozycja wprowadza pewien narzut (bolierplate), więc rozdrabnianie wszystkiego na siłę jak najmniejsze komponenty rozdmucha kod nie przynosząc zysku netto. Z drugiej strony jednak w wielu przypadkach ma sens, zwłaszcza jeśli hierarchia dziedziczenia staje się skomplikowana i można ją uprościć rozbijając ją na kompozycję i mniejsze hierarchie dziedziczenia. Co do programowania funkcyjnego to powtórzę jeszcze raz, że podstawą funkcyjności jest niemutowalność danych, a co za tym idzie kolekcje w bibliotece standardowej muszą wspierać ten sposób pisania. Dodawanie elementu do niemutowalnej mapy ma zwracać nową mapę, a nie rzucać błędem. Tego typu kolekcje są w standardzie w Scali i Haskellu, ale np w C, C++, Ruście, Javie, Kotlinie, C#, Pythonie, JavaScripcie itp itd ich w standardzie nie ma. Gdy ich nie ma to przy pisaniu funkcyjnym trzeba by skorzystać z bibliotek niestandardowych, a potem mieć poważny problem z integracją z kodem, który używa standardowych kolekcji. Bez funkcyjnych kolekcji dane stają się dużym grafem mutowalnych obiektów/ struktur/ czegokolwiek tak jak tu zostało przytoczone. Co do obiekt vs struktura to jak napisał @zyxist struktury często udają obiekty jeżeli robimy ręcznie to co kompilator zrobiłby za nas. W szczególności takie podejście wydaje się strukturalne: class Klasa {   val typ: Int   val dane: Int }  def wyciągnijDane(klasa: Klasa): Int = {   klasa.typ match {     case 0 => klasa.dane + 1     case 1 => klasa.dane + 8     case 2 => klasa.dane * 3     case _ => klasa.dane - 9   } }  Ale to tak naprawdę zakamuflowane dziedziczenie typu: class Klasa(dane: Int) {   def wyciągnijDane: Int = dane - 9 } class KlasaTyp0(dane: Int) extends Klasa(dane) {   override def wyciągnijDane: Int = dane + 1 } ... // kolejne klasy analogicznie  Ifologia emulująca dziedziczenie jest antywzorcem w językach OOP, bo jest zwyczajnie gorsza. Kompilator nie jest w stanie sprawdzić czy ifologia ma sens i jest poprawna, ale jest w stanie to sprawdzić w przypadku hierarchii klas. Podobnie analiza kod i nawigacja działa wygodnie i szybko w przypadku hierarchii klas, ale w przypadku ifologii jest z tym sporo gorzej. PS: Podawanie C++ jako przykładowej implementacji OOPa jest jak podawanie COBOLa jako przykładowej implementacji języka strukturalnego. Solidnymi implementacjami OOPa są Java i C#, więc w ich kontekście powinno się analizować skuteczność OOPa.;"
"No, ale wtedy w ogóle odsieje 99,9% pytań, no i też nie zastąpi tych profesjonalnych programistów, których ma niby zastąpić.;"
"Oj tam zaraz bezmyślni. Gdyby dziennikarze pisali to co Ty piszesz, to nikt poza programistami nie chciałby tego czytać i taki dziennikarz nic by nie zarobił. Ten problem nie tylko dotyczy AI. Na przykład w polityce jest taki Jacek Bartosiak i Marek Budzisz, a nawet niektórzy generałowie, którzy pierniczą straszne głupoty na temat Rosji, Putina i armii rosyjskiej, a dziennikarze te bzdury chętnie podchwytują bo one dobrze się sprzedają i biznes się kręci. Tak samo Konfederacja i Mentzen opowiadają straszne debilizmy, ale że więcej jest ludzi głupich niż mądrych to dzięki temu kanał Mentzena na youtube się rozwija. Ostatnio szef Nvidii Jensen Huang powiedział żeby młodzi ludzie nie uczyli się programować tylko żeby zajęli się rolnictwem. Myślę, że sztuczna inteligencja zastąpi tzw. ""klepaczy kodu"", a do rozwiązywania skomplikowanych problemów programistycznych będzie potrzebny człowiek, który będzie umiał korzystać z pomocy sztucznej inteligencji.  Projekty w całości nie składają się wyłącznie z monotonnych, powtarzalnych ticketów, ale myślę, że w Polsce takie tickety stanowią przeważającą większość.;"
To co - zastąpi czy nie?;
zastąpi;
nie zastąpi;
"Pytanie jest niejasne bo jeśli okaże się że Devin w 2024 wykona w teamie 10 osób (wliczając scrum mastera) pracę dwóch juniorów to nie zastąpi. Jeśli jednak w 2030 wykona w teamie pracę 6 seniorów to też nie zastąpi bo team będzie liczył 20 osób (10 analityków, scrum mastera + 10 QA);"
"Niby jak to miałoby działać? Fizyka powstała po to, żeby móc przewidywać pewne zjawiska. Tzn. wiemy, że jeśli włożymy piłkę o objętości V i ciężarze Q do wody to jesteśmy w stanie wyliczyć, czy piłka zanurzy się całkowicie czy nie. Takie teoretyczne modele powstają w dwojaki sposób:  albo ktoś tworzy sobie równanie i potem sprawdza, czy pasuje do rzeczywistości. Czyli najpierw zakłada, że Q = g x ro x V i potem wrzuca różne piłki żeby sprawdzić, czy mu się to zgodzi. albo ktoś robi pomiary i na ich podstawie tworzy model. Czyli najpierw wrzuca piłkę, potem obserwuje i wybiega nago krzycząc ""EUREKA"" by w końcu zapisać równanie.  W obu przypadkach sieć neuronowa nie nadaje się jako zamiennik pomiarów z prostej przyczyny - nigdy przewidywania sieci nie będą bardziej prawdziwe od poprawnie przeprowadzonych pomiarów. Natomiast jest jeszcze kwestia symulacji. Mając jakiś dobrze opisany model, np. sieć krystaliczną, można patrzeć co się stanie gdy zaaplikujemy jakieś dodatkowe warunki. Tutaj sieci neuronowe mogą się przydać, przy czym nie mogą one w całości zastąpić modelu.;"
"No to jeszcze raz - mając model matematyczny, tj. np. a = dv/dt jesteś w stanie łatwo przeliczyć, że skoro F = ma to F = mv/t. Znając ten model i mając przebieg F(t) oraz znając m jesteś w stanie łatwo wyznaczyć, jak zmieniała się prędkość danego ciała. Takie coś możesz podstawić do kolejnego modelu, i do kolejnego, i do kolejnego itp. itd.  Ja też.  Nie. Podstawą każdej sieci neuronowej są pomiary empiryczne więc nie ma potrzeby nic ""konfrontować"".  Podpowiem ci coś: przy każdym eksperymencie empirycznym istnieje coś takiego jak ""błąd pomiaru"" i każda hipoteza jest testowana z pewnym prawdopodobieństwem. Różnica jest taka, że model matematyczny powstaje bez udziału błędu pomiaru, sieci neuronowe powstają z ich udziałem. Powiem jeszcze coś więcej: prawo fizyki jest czymś bardzo ""słabym"". Tzn. dowolne prawo fizyki może zostać podważone jeśli tylko znajdziesz lepszy sposób opisu. Przykładowo - stwierdzenie, że Słońce się kręci wokół Ziemi jest prawdą. Tak samo jak to, że Ziemia kręci się wokół Słońca. To jedynie kwestia tego, gdzie ci wygodniej postawić obserwatora.  Tak, ale na podstawie właśnie przewidywań teoretycznych wiadomo, gdzie szukać. Wspomniana przeze mnie transformacja Lorentza - przekształcenie stricte matematyczne - doprowadziło do tego, że Einstein opracował teorię względności (któr  Wartość tego modelu jest większa ponieważ pozwala na przewidywanie co się stanie. I jeśli to dla ciebie ""numerologia"" to tak, to jest numerologia.  Nie można tego tak podsumować.  Modele matematycznie nie są ""w tej chwili lepsze"" bo tutaj nie ma czegoś takiego jak ""lepsze"" czy ""gorsze"". Kwestia jest taka, że nie możesz zastąpić modeli matematycznych sieciami neuronowymi bo są to rzeczy, które służą do innych rzeczy.  Tłumaczyłem ci już, że istnieją zachowania chaotyczne gdzie z powodu błędów pomiarowych sieć neuronowa nie będzie w stanie zwrócić ci prawidłowego wyniku.;"
"Gdyby za inteligencję podaną przez Ciebie definicję, że to zdolność rozwiązywania jakiegoś problemu optymalizacji, to tak, geny są inteligentne. Myślę że to jednak za mało jak na obecny stan wiedzy o matematycznych sposobach rozwiązywania problemów, o czym wspominali przedmówcy. Bardziej przemawia do mnie, że samoreplikujące się DNA (przy udziale enzymów) stało się częścią większego układu, według Teorii endosymbiozy. Natomiast problem skali czasowej wiążę się z problemem skali fizycznej. Małe byty, takie wirusy czy bakterie potrafią mnożyć się i mutować szybciej od nas, więc ich pokolenia są krótkie, nieporównywalne do skali geologicznej :) W ramach ciekawostki - są naukowcy, jak Roger Penrose, którzy dokonali pewnych przemyśleń w zakresie inteligencji i świadomości w mikroskali. Granica uznawania bytów za inteligentne będzie się przesuwała wraz z postępem, automaty będą rozwiązywały coraz bardziej skomplikowane problemy wykorzystując algorytmy i zbiory danych, a my nadal będziemy mieli świadomość, że są automatami. Dlatego problem wyznaczania definicji inteligencji proponowałbym zastąpić refleksją nad tym, czy geny są żywe i świadome. Znów wracamy do skali. Żywy organizm w ujęciu jednostkowym może nie rozwiązywać żadnego problemu optymalizacji, jak pojedyncza mrówka, ale rój w całości wyszukuje optymalne ścieżki. Również DNA samo w sobie jest tylko związkiem chemicznym, lecz przy udziale enzymów replikuje się - wykazuje więc cechy bytu żywego. Wykazuje też cechy świadomości w układzie, reagując na zjawiska zachodzące w środowisku zewnętrznym. Tylko tyle i aż tyle :);"
"To jest dobry argument. Pytanie czy Collector to Strategia czy już Metoda Szablonowa, bo a Strategii tu rozmawiamy. I czy Strategia może mieć więcej niż jedną metodę publiczną. Bo przecież nie jestem szaleńcem który chciałby każdy wstrzykiwany obiekt zastąpić skończoną ilością funkcji. Da się, ale to nie ma sensu. Nawet w Haskellu tak się nie robi, tylko używa Type Class do zmiany implementacji. A potem kompilator Haskella zamienia wszystko na skończoną ilość funkcji :D;"
"@piotrpo proszz 1. data class Collector<T,A,R>(val accumulator:(A,T)->(), val combiner: (A,A)->A, val finisher:(A)->R, //itd... możemy to nawet zupełnie zastąpić funkcją (ale będzie średnie w użyciu): <A,T>() -> ((A,T)->(), (A,A)->A, (A)->R ....//itd) 2. Collector to przykład dość topornego interfejsu (nie jest najgorszy w javie - bo tu Collection chyba wygrywa),  w zasadzie to nawet widać... że to zestaw mniejszych interfejsów (i ten koncept z data class całkiem pasuje  - bo można łatwiej współdzielić kod (np. różne kombinacje  accumulator i finisher są przy obecnym designie w java.util. utrudnione, do każdej kombinacji trzeba zrobić osobną ""klasę"" implementującą).;"
"Przecież  na tym forum połowa  użytkowników  to aspergery, wystarczy zobaczyć  na ciągłe  gownoburze na dowolny  losowy temat. Asperger tworzy logiczny świat, jak ktoś  się  z nim nie zgadza to potrafi spedziec parę  dni nad udowodnieniem że  jego logiczna wizja świata  jest prawidłowa. Wejdzcie sobie na forum  wedkarzy, kucharzy, finansistow stezenie gownoburz jest tam 10 razy mniejsze i dotyczą  one z reguły  problemów  nie logicznych. Asperger tworzy różne  logiczne schematy które  są  dla niego powodem do dumy, podwazenie takiego schematu to najgorsza obraza dla aspergera. Poza tym cechy aspergera to introwertycznosc, obsesyjne zainteresowania np.programowaniem, generalna arogancja i pogarda dla ludzi,emocje zastapione logiką. No wypisz wymaluj przeciętny  programista backend albo matematyk.;"
"Sztuczne inteligencja zastępuje programistów Javy. https: // www .dobreprogramy.pl/Sztuczna-inteligencja-juz-dzis-pisze-kod-za-programiste-czy-jutro-go-zastapi,News,87796.html;"
"No właśnie, oto przykład - waszym problemem nie jest rząd ani nawet Oriończycy - waszym problemem jak to mówicie jest przysłowiowy brak mózgu. Ja mam słabe argumenty, że maseczka antybakteryjna przepuszcza wirusa mimo, że tak twierdzi jej producent. I wy się śmiejecie z płaskoziemców? xD Ja wam mówię (a właściwie nauka), że wydychane kropelki wody to nie tylko te milimetrowe, ale także, że nanometrowe** i dlatego** producent twierdzi, że to maska tylko antybakteryjna, bo** przepuszcza** wirusy, a wy mi odpisujecie, że mam słabe argumenty i rozumowanie:)) No to ostatnio taki poziom moi drodzy inżynierowie i magistrowie, prezentował jeden płaskoziemiec, bo również usilnie mnie przekonywał, że nie ma grawitacji a wszystkie fakty, które przeczyły jego argumentom, wyjaśniał, że jeszcze niezbadane. Prowadzimy badania praktycznie w każdej grupie społecznej i mogę wam powiedzieć, że nie ma reguły wykształcenie a szczepienie. Nie można powiedzieć, że ludzie zaszczepieni to głównie ludzie o większej wiedzy niż niezaszczepieni. W obydwu grupach są kompletni idioci jak i również jednostki inteligentne więc wytłumaczeniem na to jest doświadczenie waszego ducha (waszego wyższego Ja), który komunikuje się z wami poprzez odczucie w tym przypadku tzw. przeczucie. Jednak powiedziałbym, że wśród niezaszczepionych są jednostki wybitne jak Elon Musk, a także wielu ludzi z tytułami naukowymi profesora jak np: prof. Lucu Montagnier, noblista i odkrywca wirusa HiV. Powiedział, że część genomu koronawirusa ma sekwencje genetyczne wirusa HiV, a oficjalna narracja mówi, że podobieństwo jest znikome. I wiecie jak to wygląda? Noblista i odkrywca HiV (wiec zna jego genom bardzo dobrze) twierdzi, że widzi te same sekwencje, a oni wam mówią, że podobieństwo znikome. Umarł 3 dni po szczepieniu, a wtedy wam mówią, że nie ma związku. Czujecie się zdrowi i robicie test, okazuje się, że jesteście superroznosicielami (w Polsce tak nie było to odczuwalne, ale w Chinach...). A zaszczepionych odseparowywuje się od zaszczepionych, czego się nie robiło nawet przy żółtej febrze (a żółta febra jest znacznie groźniejszym antygenem). Bob Marley powiedział, że niektórzy są tak biedni, że jedyne co mają to pieniądze. Ja to zmodyfikuję, że niektórzy są tak biedni, że jedyne co mają to umysł logiczny. Umysł logiczny może opanowywać coś latami np: inżynierię genetyczną, a duch wie to od razu poprzez doświadczenie nabyte poprzez generalnie mówiąc - całościową egzystencję (jej ciągłość) - i duch (wyższe Ja) może przekazać tę wiedzę umysłowi logicznemu właśnie w formie odczucia / przeczucia / intuicji. Na nic super inteligentny umysł logiczny, kiedy duch głupi. Tak jest w przypadku wielu waszych naukowców głównego nurtu. Nie mówię, że wszyscy, ale wszyscy z głupiem duchem mogą zostać z pewnością zastąpieni deep learning WATSON®, bo... bo nie mają wyobraźni, a jedynie umysł logiczny i ten umysł logiczny przegra z AI. Jeśli chcecie pokonać AI to musicie ją zaskoczyć tym czego ona nie posiada, a to co macie tylko wy - wyobraźnia. Sztuczna inteligencja może tylko modyfikować to co wy stworzycie, ale brak jest jej BOSKIEGO potencjału twórczości - waszej esencji. Taka wskazówka na przyszłość xD;"
"Szatan jako anioł jest hermafrodytą, posiada obie cechy płci. Generalnie chodzi o zniszczenie obrazu na jaki człowiek został stworzony - na obraz Boga i zastąpienie go szatańskim. Dlatego lucyferianie w swoich rytuałach satanistycznych zakładają maski, żeby przykryć swoją tożsamość, a teraz założyli je wszystkim ludziom pod pretekstem COVIDA. Maska jest starożytnym i potężnym magicznym pośrednikiem wśród światów żywych, umarłych i duchów. Maski były noszone w celach magicznych, religijnych i rozrywkowych od początku pisanej historii. W rzeczywistości maski ujawniają więcej niż ukrywają. Starożytni ludzie dobrze rozumieli moc maski. Dowody na noszenie masek w społeczeństwach prehistorycznych pokazują, że maski mogły mieć na celu magiczne przekształcenie noszącego, aby coś osiągnąć lub coś zdobyć. Być może pierwszym prehistorycznym tancerzem w masce jest „Sorcerer”, malowidło jaskiniowe z epoki neolitu w Trois Freres we Francji. Zamaskowana postać jest pół-człowiekiem, pół-zwierzęciem, ma na sobie poroże jelenia i unosi się w tanecznym kroku. Obraz sugeruje Rytuał udanego polowania. Jego maska ujawnia i wyzwala zwierzęcą naturę w człowieku, co umożliwiłoby mu kontakt z siłami nadprzyrodzonymi lub duchem zwierząt i proszenie ich o pomoc. Maski były używane na przestrzeni dziejów w licznych obrzędach, liturgiach, teatrze i sztuce ludowej. Maska była czczona jako święty przedmiot mocy, żywa istota, która albo ma swoją własną osobowość, albo reprezentuje osobowość innej istoty. Pozwala noszącemu w magiczny sposób ożywić, a nawet stać się osobą lub duchem reprezentowanym przez maskę. Gdy maska jest założona, osoba nosząca nie jest już całkowicie sobą, ale dzieli swoją tożsamość z tożsamością maski. Ma wolność – i pozwolenie w społeczeństwie – na działanie inaczej, nawet oburzająco. Transformacja ma swoje granice i kontrolę: użytkownik nie może wyjść poza granice samej maski i ulega przemianie tylko podczas noszenia maski. Kiedy maska zostanie zdjęta, noszący musi wrócić do zwykłej rzeczywistości. Transformacyjną moc maski można wyjaśnić w kategoriach jungowskich. Maska łączy nosiciela z archetypowymi mocami drzemiącymi w zbiorowej nieświadomości. Maska jest pośrednikiem między ego a archetypem , przyziemnością a nadprzyrodzonym, sacrum a komizmem. Łączy teraźniejszość z przeszłością, jednostkę z całym kolektywem rasy, kultury, kraju i ludzkości. W kulturach, w których maska jest traktowana z szacunkiem, tworzenie masek jest szanowaną i wykwalifikowaną sztuką. Na przykład na Bali maski odgrywają główną rolę w rytuałach i przedstawieniach. Maski są wyrzeźbione z drewna. Przed rozpoczęciem rzeźbienia rzeźbiarze medytują nad przeznaczeniem maski, nad postacią samej maski i wykonawcą, który ją założy. Performerka również medytuje nad maską przed jej założeniem. Może nawet spać z nim obok niego, aby inkubować sny oparte na jego wyglądzie i osobowości, co zainspiruje spektakl do większej głębi. Wyzwanie balijskiego performera polega na dosłownym ożywieniu maski – sprawienie, by drewno wydawało się elastyczne i zdolne do rozświetlenia swojego utrwalonego wyrazu. Aktorzy, którzy mają dar animowania swoich masek, są szanowani jako „mający taksu”. Taksu oznacza „miejsce, które otrzymuje światło”. Aktorzy, którzy nie mają taksu, nazywani są stolarzami – po prostu pchają drewno po scenie. W większości kultur maski symbolizują dobroczynne duchy: istoty natury, bóstwa, zmarłych przodków i królestwo zwierząt. Indianie północnoamerykańscy używali masek, aby przedstawiać złe duchy, nad którymi uważa się, że mają władzę. Podobna atrybucja odbywa się na Cejlonie.;"
"Pierwsze próby dotyczyłyby przepisania istniejącego prawa na język programowania. W tym zadaniu znajomość domeny byłaby minimalna, bo ona jest potrzebna przy tworzeniu specyfikacji, którą jest właśnie dany tekst prawny, przy założeniu, że jest napisany jednoznacznie. Oczywiście to to założenie nie musi być spełnione, ale błędy powstałe z tego powodu można wyeliminować w fazie testów, gdy działanie automatu prawnego jest porównywane z interpretacją ludzkiego eksperta, a ewentualne różnice trejsowałoby się wstecz do kodu. Uważam zresztą, że potrzebna wiedza programistyczna byłaby tu również na niewielkim poziomie. Na początku odpada dużo problemów występujących we współczesnej inżynierii oprogramowania, jak interfejs użytkownika, wydajność, wieloplatformowość, itp. Zostają wyłącznie dane i algorytm. Gdyby powstał standard takiego języka, to podejrzewam, że wystarczyłyby 2 semestry jego nauki na studiach prawniczych, by potem takie prawo tworzono bezpośrednio w formie cyfrowej.  Kod automatu nie musi być czytelny dla użytkownika, bo on i tak by w niego nie zaglądał. Jedyne co musiałoby być dla niego jasne, to kod opisu problemu prawnego, czyli danych wejściowych dla automatu prawnego.  Wydaje się dobrym wyborem  Nie sądzę by to było konieczne, bo problemu prawnego nie formułowałoby się w postaci języka naturalnego, więc problemy natury składniowej czy generalnie NLP by tu nie występowały.  O ile w medycynie w rozumiem, dlaczego system ekspertowy nie jest w stanie zastąpić lekarza, to mam wrażenie, że z prawem jest trochę inaczej. Tu przyczyną moim zdaniem jest to, że nikt nie podjął poważnej próby stworzenia czegoś takiego, prawo i technologia przenikają się w mniejszym stopniu niż medycyna i technologia, a prawnicy raczej nie oddadzą chętnie swojej roli wyroczni.;"
"Nie, nie ma racji. Pieniądze w budżecie mogą się znaleźć bardzo szybko.  500+ kosztuje budżet państwa 40 mld złotych, dodatkowo wnioski o 500+ trzeba przyjąć, a potem sprawdzić, w tym celu trzeba zatrudnić urzędników. Zlikwidować 500+, urzędników na bruk i nagle mamy pieniądze w budżecie 13 i 14 emerytura kosztują budżet państwa 22 mld złotych, dodatkowo tak samo jak powyżej są urzędnicy, którzy przyjmują i weryfikują wnioski. Zlikwidować 13 i 14 emeryturę, urzędników na bruk i nagle mamy pieniądze w budżecie kredyt 2% to koszt 1-1,5 mld złotych, tak samo wnioski trzeba przyjąć i zweryfikować. Zlikwidować kredyt 2%, urzędników na bruk i nagle mamy pieniądze w budżecie W połowie lat 90. w całym aparacie administracyjnym było zatrudnionych nieco ponad 100 tys. osób. W ubiegłym roku natomiast, jak wynika z ostatniej informacji na ten temat Głównego Urzędu Statystycznego, w sektorze administracji publicznej, obronie narodowej i zabezpieczenia społecznego pracowało 525 tys. osób. Ludzie na tym forum zakładam pracują jako programiści i pewnie część z was zajmuje się data engineering, big data, ML itd. Dobrze wiecie, że firmy optymalizują procesy biznesowe, obcinają koszty i zwalniają ludzi dzięki temu, że część pracy, którą kiedyś musieli wykonać ręcznie ludzie mogą wykonać za nich komputery. Tymczasem nasza administracja wciąż puchnie i jakoś nie widać, żeby do państwa zawitał jakiś postęp. ustawa o vat liczy już niemal 1000 stron. To jasne, że w celu policzenia tego podatku zarówno po stronie przedsiębiorców, jak i po stronie aparatu skarbowego trzeba zatrudnić ludzi, którzy będą to liczyć i weryfikować. Marnotrawimy energię ludzi i pieniądze na bezsensowny i bardzo skomplikowany podatek. Zlikwidujmy obecny vat i zastąpmy go jedną stawką, a ustawę zapiszmy na 5 stronach zamiast na 1000 stron. Już widzę ile za te pieniądze mogłoby powstać nowych szpitali, szkoda że zwolennicy wysokich i trudnych podatków nie widzą :( PGE EJ1 czyli spółka powołana już w czasie rządów Tuska w celu budowy elektrowni atomowej Tylko na wynagrodzenia poszło ponad 100 mln zł, a łączne koszty działalności już w zeszłym roku wyniosły 447 mln zł. Powołana w 2010 roku państwowa spółka PGE EJ 1 miała przygotować inwestycję w pierwszą polską elektrownię atomową, ale do dzisiaj wszystko pozostaje w sferze niejasnych, odległych planów. Minister Grad w 2013 roku mówił, że w 2024 będziemy mieli pierwszą elektrownię atomową, nie prostytutka nie będziemy mieli, nawet nie zaczęli jej budować. Natomiast minister Grad opuścił fotel ministra i został prezesem spółki PGE EJ1, wziął pieniążki i tyle go widzieli... Zdzisław Gawlik, który był wiceprezesem w atomowych spółkach PGE. W pierwszej połowie 2013 r. uzyskał wtedy dochód w wysokości 599 340 zł, czyli niemal 100 tys. zł miesięcznie. Izera kosztowała nas już 500 mln złotych, tymczasem państwowego samochodu elektrycznego jak nie było, tak i nie ma nadal...  Dobra kończę, bo już mi się nie chce podawać kolejnych przykładów gdzie można osiągnąć oszczędności, ale mógłbym wymieniać jeszcze długo.;"
"Musisz napisać coś więcej na temat tej gry.  Wszystko zależy od tego, co konkretnie robi się w tej grze, na czym gameplay polega. Dynamicznie dostosowujący się poziom trudności co prawda brzmi bardzo interesująco, ale trzeba pamiętać, że nie jest to standard, nie do każdej gry będzie pasować.  Tak czy siak każdą grę należy ręcznie zbalansować, bo to musi być fundament dla mechaniki zmieniającego się poziomu trudności, aby wiedziała, jakie są granice trudności — dolna, dla niedzielnych graczy (również dla dzieci) oraz górna, dla hardkorowców. Te granice musisz znaleźć samodzielnie, jako punkt startowy do dalszego balansowania.  Zależy co masz na myśli pisząc o pomocy AI. IMO bez beta-testów się nie obejdzie, dlatego że żadne oprogramowanie nie zastąpi człowieka w tej kwestii. Powinieneś skorzystać z pomocy beta-testerów i finalnie zbalansować grę na podstawie ich feedbacku. Natomiast nic nie stoi na przeszkodzie, aby wersja beta przeznaczona do testów gromadziła dane telemetryczne. Takie dane są bardzo cenne, bo nie tylko dostarczą mnóstwo dodatkowych informacji, których człowiek nie wyłapie i nie zgromadzi, ale i będą one zdecydowanie bardziej wiarygodne i bardziej precyzyjne, niż prosty feedback. Pamiętać trzeba, że człowiek to nie maszyna, nie zauważy mnóstwa szczegółów, może i będzie się mylić, ale też może mieć zły humor, być uprzedzonym czy po prostu kłamać dla własnych korzyści. A telemetria nie kłamie, nie myli się i niczego nie pomija.  To zależy czym ta gra jest, jak istotny jest globalny ranking i czego w ogóle dotyczy. Ale nic nie stoi na przeszkodzie, aby użyty w trakcie gameplay'u poziom trudności wykorzystywać do obliczenia końcowego wyniku gracza (jeśli miałby to być wynik punktowy).;"
"Spoiler jakby ktoś nie wiedział, to programistów zastąpią testerzy, a ich potem sztuczna inteligencja.;"
"nie polecam programowania, mnie juz zastapil robot(kuchenny) i zostalem bez pracy, nie wiem co robic jestem w potrzasku;"
":D Ktoś tą ""automatyzacje"" musi robić i robią to właśnie inżynierowie, w tym programiści. To będą ostatnie osoby zastąpione przez automaty. Zresztą przecież automatyzujemy cały czas! Dzis jedna linijką kodu w języku wysokiego poziomu można zrobić coś, co wymagałoby 20 lat temu pewnie co najmniej kilku tygodni klepania. Wiele aplikacji dziś składa sie z gotowych komponentów, frameworków, bibliotek, i zewnętrznych aplikacji. Jedna linijka i mamy w projekcie bazę danych i nie musimy przez kilka miesięcy pisać warstwy persystencji. Ale w efekcie wcale ilość pracy nie spada, wręcz przeciwnie. Możemy dzięki temu klepać bardziej złożone systemy i rozwiązywać problemy których kiedyś nie dałoby się rozwiązać, ze względu na poziom ich złożoności.;"
"To w 100% prawda. Jestem automatem i w tym roku zastąpiłem juz 50 programistów. jestem tak dobry, że nawet siedzę za nich na forah. Na foraH, rozumiesz ? Nawet zrobiłem bład jak człowiek. Wy zawodne białkowe istoty nie macie sie co pchać do programowania. Ha ha ha 010010010010101101110110010010100101100110111111.....;"
"Janusz Filipiak już lata temu odkrył, że każdego programistę można zastąpić... skończoną liczbą studentów XD Mówiąc poważnie, to świat od zarania dziejów zmierza w kierunku automatyzacji. Jeżeli coś da się zrobić bez pracy ludzkich rąk, to lepiej zrobić to właśnie w taki sposób. W celu automatyzacji wymyślono między innymi młyn wiatrowy i wodny, akwedukt, prasę drukarską, silnik parowy, w końcu mikroprocesor. Pojawienie się mikroprocesora stworzyło możliwości zastąpienia pracy nie tylko ludzkich rąk, ale i umysłów. Pierwszy mikroprocesor 4-bitowy 4004 z 1971 roku wykonywał 60 tysięcy operacji na sekundę, liczbę nieosiągalną dla człowieka (porównuje świadome operacje, ponieważ ludzki mózg przewyższa znacznie nawet najszybsze procesory pod względem operacji, które wykonuje nieświadomie). Jeżeli kogoś przeraża automatyzacja, powinien zastanowić się nad przyłączeniem do jakiejś sekty i zamieszkać co najmniej w Bieszczadach.;"
"No tak, Ale nikt nie twierdzi, że docelowo ma wymieść wszystkich programistów. To tak jak w fabrykach, automatyzacja może i być i w 90% procesu, ale jednak są też zatrudnieni jacyś ludzie. I tak zawsze będzie. Ja rozumiem, że zagrożenie automatyzacją dla programistów też będzie szło tą drogą. Z potrzebnych 10, zostanie dwóch, a 8 klepaczy się zastąpi.;"
"niepotrzebna nawet automatyzacja, wystarczy, że będzie wystarczająco duży rynek ""gotowców"". Już teraz mnóstwo software'u jest gotowego(choćby Wordpress), jest coraz więcej gotowych usług on-line do użycia (software as a service), czy wreszcie produktów, które mogą zastąpić potrzebę wynajęcia programisty (np. można sobie sobie zrobić stronę na Wix). Ja się dziwię, czemu w ogóle jeszcze są potrzebni programiści w tak wielkich ilościach, bo w zasadzie niby wszystko jest już, przypuszczam, że można by zrobić cały produkt łącząc tylko gotowce. Ale z drugiej strony - ktoś te gotowce musi robić, więc nawet jeśli wszyscy będą korzystali z gotowców, to będą i tak potrzebni programiści do tego, żeby zrobić kolejnego gotowca, kolejną usługę on-line itp. No i tutaj widzę nadzieję na to, żeby zawód programisty przetrwał. Szczególnie, że robienie uniwersalnej usługi przeznaczonej do użycia przez masy jest o wiele trudniejsze niż zaklepanie coś na zlecenie dla jednej firmy. Np. wiele osób by umiało zaklepać szablon w HTML/CSS, ale jednak zrobienie od podstaw edytora WYSIWYG (jak np. Wix) już byłoby sporo trudniejsze. Więc dalej będą istnieć programiści, właśnie po to, żeby robili gotowe usługi do użycia i będą powstawać jak grzyby pod deszczu startupy, które będą miały na celu zautomatyzować/uprościć pracę.(już takie powstają, tylko, że duża część z nich to jakieś niewypały).;"
"Z tym Comarch będzie jeszcze tak, że sami będziecie się prosić, żeby tam pracować. Jak załamie się gospodarka światowa, przyjdzie kryzys to korporacje jak szybko przyszły do Polski, tak szybko uciekną. Pierwsze oznaki już widać. Paradoksalnie ci co pracują w korpo pierwsi odczują skutki kryzysu. W sensie, że pierwsi stracą pracę. Praca w korporacji uważana jest za pewną, stabilną. Prawda jest taka, że jest najmniej bezpieczna pod względem stabilność. Dodać trzeba, że rozwijana jest sztuczna inteligencja co sama będzie tworzyć crudy itd. Sztuczna inteligencja, automatyka, robotyka tworzona jest i rozwijana, żeby zastąpić ludzi. Eldorado się skończy w najmniej oczekiwanym momencie. Niektórzy się jeszcze zdziwią. I to ci  są bardzo pewni siebie.;"
"Najwyżej wrócimy (w przypadku niektórych: pójdziemy) na studia. Przecież Pan Profesor wyraźnie powiedział, że każdego programistę można zastąpić skończoną liczbą studentów, więc miejsc pracy można łatwo namnożyć :)  Dokładnie, w takim Sabre to już w ogóle wszyscy są na 100% przekonani, że nigdzie nie ma tak stabilnie, jak w korpo.  Ale wiesz, że podstawowe CRUDy można już teraz generować i bez sztucznej inteligencji? Co ma robić ta sztuczna inteligencja, tworzyć algorytm robienia inner joina? Zresztą to bardzo dobrze, klepanie CRUDa zwiększa zużycie kawy o połowę, bo trzeba jakoś nie zasnąć.  Eldorado się skończy, jak powstanie coś co zastąpi komputery i software w postaci znanej nam dzisiaj i trzeba się będzie przebranżawiać. W sumie to chętnie bym się nauczył korzystać np. z komputerów kwantowych, choć w tej chwili mój mały móżdżek jeszcze nie objął, co konkretnie mogę osiągnąć manipulując stanem kilku qubitów. Widziałem chyba nawet kiedyś jakieś przykłady, ale bez przełożenia na praktykę. Tak samo jak wraz z silnikiem spalinowym czy elektrycznym skończyło się eldorado dorożek i omnibusów, ale przy nowych zajęciach i tak trzeba było rąk do pracy.;"
"Poruszając się w potocznym znaczeniu słów ""Programista"" to pojęcie szerokie niemal jak ""informatyk"". Przecież dla rodziny jesteśmy informatykami a nie programistami czyli naprawiamy komputery umiemy zainstalować u cioci na tablecie Skype'a i zrobić Internet. Zawężając się jednak do podzbioru ""informatyków"" czyli samych programistów nadal pozostajemy w ogromnym zbiorze stanowisk, zakresów kompetencji czy zwyczajnie różnych charakterów i osobowości. Pośród tych wszystkich ""normalnych"" i ""dziwaków"" są programiści, których praca jest ważna, bardzo odpowiedzialna są wartościowi dla dużej grupy ludzi a czasem nawet dla całego społeczeństwa. Są też tacy, których istnienie uzasadnione jest jedynie zrealizowaniem nieznaczącego drobnego zlecenia, poza którym właściwie nie musieli by istnieć. Nawet gdyby zniknęli jak czarownik zamieniając się w parę to nikt by tego nie zauważył... Może osoba siedząca obok widząc to powiedziałaby Wow! Co z tego wynika a no nic -  są różni programiści i tyle. Sama inteligencja to nie jest magiczna moc pozwalająca robić rzeczy, których mniej inteligentni nie potrafią. Inteligencja nie jest synonimem mądrości, głupoty, doświadczenia ani posiadania wiedzy. Praktyka pokazuje, że podczas pracy programisty najważniejszą rolę odgrywają właśnie cechy t.j. (subiektywnie w kolejności od najważniejszej): wiedza, doświadczenie, mądrość ... Dodałbym jeszcze mało docenianą wśród umysłów ścisłych komunikatywność. Inteligencja to ostatnia rzecz, która jest nam potrzebna. Ta jednak bywa świetnym spoiwem między wymienionymi cechami jeśli posiadamy je już na wyższym niż przeciętny poziomie. To daje nam większe szanse na sukces, niestety osiągnięcie go nadal wymaga ogromnego nakładu pracy. Inteligencja idzie trochę w parze z intuicją i to jest moim zdaniem istota rzeczy. To taki łącznik między sposobem i skutkiem podejmowanych decyzji odrobinę rozróżniający osoby inteligentne od tych mniej inteligentnych. Ci pierwsi rzadziej się mylą a ich decyzje podejmowane na szybko lub w stresie[1] także w mniejszej ilości przypadków kończą się porażką. To przekłada się na lepszą skuteczność w działaniu i oszczędność czasu a to już bardzo dużo jeśli poprzeczkę stawiamy wysoko. Jeśli jednak nie planujemy kariery ""od zera do milionera"" to inteligencja może nam pomóc np. w tym, żeby w pracy mniej się męczyć albo wyrwać ładniejszego partnera/partnerkę (zawsze coś)... Generalnie cudów, laserów, matrixa i statków kosmicznych nie ma w żadnym przypadku:-) Nawet mało inteligentna osoba może programować. Będzie jej trudniej - prawdopodobnie będzie lubić zadania bardziej żmudne niż wymagające umiejętności dalekosiężnego projektowania i przewidywania zachowania systemu. Nadrobi to jednak skrupulatnością, czytelnością kodu być może będzie dobrze testować a to przyczyni się to tego, że program wychodzący spod jej ręki będzie dla użytkownika równie dobry jak ten napisany przez geniusza. Oczywiście jak ktoś jest leniwy, wyjątkowo tępy lub nie chce się uczyć to szans nie ma to jednak zasada w każdym zawodzie nie tylko programisty. @Spearhead napisał, że Ludzie z wysokim IQ zostają naukowcami lub milionerami, a nie programistami. ... Mogą ale nie muszą. Tak samo jak tępy, który też może zostać milionerem wykorzystując takie cechy jak komunikatywność, spostrzegawczość, pracowitość i upór w dążeniu do celu. Odnoszę zresztą wrażenie, że tak właśnie jest w większości przypadków. Bo do bogactwa prowadzi konsekwentność i pracowitość a nie inteligencja. Tych błyskotliwych inteligentnych co zrobili karierę znamy z amerykańskich filmów ale w rzeczywistości to są jednostki. Inteligencja może pomóc zostać najlepszym, może pomóc w zdobyciu wysokich zarobków niższym nakładem pracy niż u mniej inteligentnych ale nigdy nie zastąpi pozostałych niezbędnych do pracy w zawodzie cech i umiejętności. [1] - nie chcę tu wnikać w analizę odporności na stres więc załóżmy, że chodzi o osoby o podobnej odporności.;"
"Z tym się z Tobą zgadzam. Sztuczna inteligencja, automatyka, robotyka to wszystko jest rozwijane, żeby zastąpić ludzi techniką. Napisałeś, że kierowcy ciężarówek najpierw to odczują. Możesz rozwinąć temat ? Chodziło Ci o to, że tworzone są autonomiczne pojazdy ? Druga sprawa, że ciężarówki przerzuca się na kolej, żeby odciążyć drogi ?;"
"długo AI nie zastąpi programisty, poza tym człowiek jest tańszy w utrzymaniu :-) Coraz trudniej projektuje się procesory z uwagi na ograniczenia materiałów z jakich są robione, a takie AI przecież nie będzie chodzić na celeronie :-P w sumie to długa droga do stworzenia AI, na razie to tylko algorytmy ale i tak człowiek je wymyśla i implementuje :-);"
"@GutekSan: zestawienie ekowyborcze. Odejście od węgla to koniec Polskiej gospodarki - nie ma skutecznych metod, aby magazynowac energię słoneczną i z wiatraków, a gospodarka potrzebuje energii zawsze, a nie jak akurat świeci słońce. Jedyne co może nam zastąpić węgiel to atom; właśnie ile to mamy elektrowni atomowych?;"
"Nie jestem ani psychologiem ani socjologiem ale mam wrazenie, ze najwieksze niebezpieczeństwo w tych posunięciach jest to, że buduje sie w społeczeństwie przekaz, że to jest sprawiedliwe. Nikt sie nie skupia na tym czy te wszystkie nasze składki/podatki czy duze czy małe sa efektywnie wykorzystane. Armia urzędników, która nic nie produkuje i która można spokojnie zastąpić podpisem kwalifikowanym :) kosztuje sporo, pomysły rządu też. Posłuchajcie krąży po sieci wywiad z Romanem Kluską fajnie opisywał czym różni sie biznes teraz od tego kiedy on zakładał Optimusa. Teraz rząd chce nam ""dawać"", rataowac, pomagac, regulować, kontrolować itd. i tu jest pies pogrzebany. Umęczeni ludzie, ktorzy zawsze zarabiali blisko minimalnej krajowej albo wyjezdżali za granicę, albo klepali biedę. Nie czarujmy sie mało kto z tych osob zastanawial sie nad systemem dlaczego maja tak ciezko,  utarlo sie, ze tak musi byc bo kraj biedny bo to, bo tamto. Teraz rząd oferuje im jakies realne pieniadze, które realnie tylko redystrybuuje, ale że taka redystrybucja kosztuje to ktoś będzie musiał dołożyć wiecej. Juz byly pomysły testu przedsiebiorcy, aby wyciac ludzi z podatku liniowego 19% ale znalezli teraz sprytniejszy sposob. pare stowek uda sie im skubnac i jestem pewny, ze na tym sie nie skonczy :( Sam kiedys klepalem biede studia skonczylem w 2004 r. nie bylo latwo wszyscy na roku myslielismy, ze Pana Boga za nogi załapaliśmy az przyszlo prawdziwe zycie i pokazalo, że nie do konca tak bylo. dopiero w 2011r. udalo mi sie wrocic do branzy IT i powoli mozlonie zdobywalem doswiadczenie. Teraz tez ciagle sie musze rozwijac, ciagle pilnowac. Ale mam juz ogromny bagaz doswiadczen i jak to sie mowi expert to ten kto popelnil juz wszystkie mozliwe bledy :) ja jeszcze wszystkich nie odkrylem ale sporo juz ich mam za soba. Teraz widzę, ze dochodzenie do poziomu zarobkow IT wymaga wysilku i nie kazdemu sie udaje. Rzad dzieki nam dostaje sporo CIT, PIT, VAT ale i tak mu malo, a lud bedzie krzyczal ""daj daj"". Niestety ten rzad da bo nie daje ze swoich, a najgorsze co robi utrwala przekonanie, ze robi to sprawiedliwie.;"
"Tak, ale na innym etapie. Inteligencja służy do tego, by właściwie przetwarzać dane. A retro służy do tego by te dane uzyskać. Bez spojrzenia wstecz samą inteligencją nic nie wskórasz. A tak w ogóle to zapominacie o jednym: Inteligencja jest cechą rzadką i nie do końca przewidywalną, dlatego mądry biznes polega na tym by potrzebę inteligencji zastąpić procesami.;"
"Ogólnie to w tej firmie,  o której często piszę udało się w pewnym momencie prowadzić SCRUMa prawie by the book i nawet dużo patologii, takich jak pisałem udało się wyeliminować. I to był też moment, w którym zaczęliśmy tego SCRUma powoli olewać - najważniejsze to wyeliminowanie całego śmiecia - straty czasu na planowanie, retro (jaki nonsens), i daily stan dupy. Zrobiliśmy spotkania opcjonalne w większości (daily też). Z nazwy to tam został SCRUM, żeby nikt się nie czepiał.  Rozwalanie dużo czasu zajęło, ale SCRUM ma wbudowane opcje ułatwiające destrukcję (na szczęście). Np.: na każdym retro powtarzałem, że uważam, że retro jest stratą czasu.... - miałem nadzieję, że w końcu się ten postulat uda przepchnąć (rok ponad zajęło, ale się udało). Przy okazji wcale nie złośliwie bo, skoro ciągle narzekamy na to samo (!), to znaczy, że nie udaje nam się problemow rozwiązać i możemy z nimi żyć i po prostu oszczędzić sobie narzekania. (mam wrażenie, że norma w wiekszości zespołów). Przestaliśmy sie przejmować velocity. Nauczyliśmy się nie czekać na DEMO ... z demonstrowaniem. Lepiej pokzać coś zanim jest gotowe, puty jeszcze ludzie (potencjalnie użytkownicy) mają szanse coś zmienić. Ogólnie powstał jakis nowy proces, ale nie wiem czy jest sens opisywać, specyfika firmy jest taka, że dużo zespołów równoległych działało w tym samy  kodzie, albo  blisko niego i było dużo zależności. Zrobiliśmy sobie spotkania sync z innyi zespołami i tam chodziliśmy (jak ktoś miał potrzebę!). Np. jedno z takich spotkań/process  dokładnie zastąpiło retro - wpisywaliśmy po jednym/dwóch  największychy problemach z każdego zespołu (w zespole mieliśmy ścianke bólu gdzie każdy ad hoc mógł wpisać jak go coś wkurzyło) i jak się powtarzały (między zespołami) to szedł task do szefostwa - naprawcie nam firmę. A jak nie to się rozchodziliśmy (5 minut i po spotkaniu). Planingi się zmieniły tak, że po prostu programista z biznesem siadał (czasem na kilka godzin) przed spotkaniem i szacował z nimi jakies punkty na podstawie swojego doświadczenia. Potem na planowaniu mówił - jest takie zadanie i wg mnie tyle to zajmie bo to i to. Był czas, żeby zgłosić uwagi do tego planowania, czy np, o wszystkich problemach pamiętał, robiło to duża oszczędnośc czasu.  No i oczywiście koniec dramy z dyskusjami 3 czy 5. Każda wątpliwość przy niezbyt dużych różnicach to liczba większa i nie tracimy czasu na precyzyjne celowanie z szacunkami ( bo i po co). Udało mi się nawet ze dwa razy przemycić przy szacowaniu liczbę 4 i 10 jako estymatę (musiałem udawadniać, że takie liczby też istnieją... - ale jest zaskakująco prosty dowód tego). Wydaje mi się, że jeszcze ważniejsze od wypaczenia SCRUMa było wprowadzenie innych reguł, typu: nikt nie koduje taska sam dłużej niż dwa dni. Czyli jak ktoś przekisi  taska 2 dni to dostaje partnera do kodowania i następuje przekazanie taska, ewentualnie robią go dalej 2 osoby. Taki  bieda pair programming, ale realizował cel - o każdym większym tasku miały dogłębne pojęcie przynajmniej  2 osoby. Jeszcze było kilka innych myków, ale wszystko to związane ze specyfiką firmy i zadaniami (wiele zespołów, bardzo skomplikowana domena, rozwłóczona przez 120 serwisów, paranoiczne security  itd). Dlatego, wcale nie sprzedawałbym i nie polecał tego procesu gdzieś indziej. Najważniejsze wyszło nieźle - można było kodować. Prawie cały dzień. Jak przyszedłem do firmy to w zespole było 18 godzin spotkań na człowieka na tydzień.... Mieliśmy żarty o tym, że  już w następną  środę na przerwie pomiędzy 2 zebraniami uda nam się może odpalić Intlellij.  Były całe tygodnie gdzie odpalenie  IDE się nie udawało  - mega frustracja.;"
"W tej chwili mam ochotę powiedzieć: ""o, stary…"" :) W jaki temat wchodzimy. :)  Nie wiem, nie czytałem, coś mi się obiło o uszy. Szkoda trochę, ale cóż, zawsze są jakieś priorytety w wyborze lektur.  Polemizowałbym, że da się łapki zastąpić komentarzami, postami itd. Ale to wymaga pracy i raczej nie w kwestii ""ideologicznej"" (co ""lepsze"", co ""gorsze""), tylko emocjonalnej: przekonać wszystkich, że ma to tzw. sens. (Dla każdego coś innego może być sensowne…)  Zdefiniuj ""sztuczny"".;"
"Z moich obserwacji Hadoop jako stack (YARN + HDFS + Hive) to raczej jest dalej używany w większości w instytucjach finansowych (banki, ubezpieczenia, ...), ale bardziej z powodów prawnych niż technicznych. Tak przynajmniej wynika z dyskusji z ludźmi po meetupach. I jeśli Hadoop, to rzadko jako samo utrzymywalny stack, a częściej jako dystrybucja Cloudera Hortonworks. Ku precyzji, to co napiszę, to wynik mojej obserwacji rynku francuskiego, a przez ""obserwuję"" mam na myśli oferty o pracę, konferencje, blogi. Jeśli chodzi o szerzej rozumiane Big Data (chociaż wolę termin data engineering), to firmy skłaniają się w stronę cloudowych rozwiązań. Dlaczego?  koszty devops - trudno znaleźć devopsów, a tych dobrych jeszcze trudniej. Minimalizuje się więc koszty infrastruktury w projektach. scaling - to, że dzisiaj potrzebujesz 10 node'ów, żeby przetworzyć 1TB nie znaczy, że jutro jak będziesz miał 2TB, to łatwo dodasz sobie 10 kolejnych. W chmurze takie dylematy są o wiele mniej poważne - istnieją, bo nie możesz sobie w nieskończoność dodawać node'ów, tworzyć 2 tysięcy klastry itd, bo na wszystko prawie są limity, ale skalowalność jest o wiele bardziej elastyczna ludzie - mało kogo dzisiaj bawi praca w stylu ""kurcze, mam 10% miejsca na dysku, musimy dodać nową maszynę - piszę ticket do IT, IT kupuje serwer, a ja przez 5 dni biję się z myślami, jak grać z danymi, żeby ich nie stracić"" (karykatura, ale coś w tym jest)  Oczywiście, nie umniejszam znajomości Hadoop. Sam od tego zaczynałem i się cieszę, bo można znaleźć wiele odpowiedników w serwisach chmurowych, a część z nich jest nawet implementowana (np. EMR w AWS). Ale nie samym Hadoopem człowiek żyje i tak:  MapReduce - nie widziałem, żeby ktoś tego dzisiaj wymagał. Spark z OS, trochę mniej Flink, a z cloudowych to Dataflow i Databricks (serverlessowe rozwiązania) YARN - Kubernetes wydaje się go wygryzać do wysyłania jobów na cluster - nie mylić ze schedulingiem Oozie - Airflow jest o wiele bardziej elastyczny, przypomina coś w rodzaju Infrastructure As Code, nawet jeśli chodzi tylko o joby, które schedulujesz Hive - z moich obserwacji jeden z ostatnich bastionów Hadoopa, który jako tako jest na rynku wymagany HDFS - zastąpiony przez tańsze w utrzymaniu serwisy do przechowywania obiektów (S3, GCS) HBase - BigTable, DynamoDB, łatwo skalowalne, DynamoDB oferuje nawet możliwość streamingu zapisywanych danych streaming broker - jeśli mnie pamięć nie myli, nie istnieje w stacku Hadoopa  Reasumując, Hadoop jako narzędzie do pierwszej pracy - nie. Raczej radziłbym opanować serwisy data jednego z chmurowych dostawców (GCP wydaje się zyskiwać na popularnośći, ostatnio nawet Twitter na niego przeszedł (https://cloud.google.com/twitter/). A co do OS rozwiązań, to:  Kafka do streamingu Spark do przetwarzania danych Kubernetes do wykonywania programów (resurce manager) i później jakieś bazy NoSQL, co kto woli, ja zaczynałem od Cassandry (łatwiej zrozumieć DynamoDB), Elasticsearch (do dokumentów i wyszukiwarki). Pracowałem też z Neo4J, ale akurat ciężko się go skalowało nieśmiertelny SQL - ignorowałem go przez długi czas, ale po jednym projekcie typowo ETL-owym, bazującym na SQL, przekonałem się jakie możliwości oferuje Python i Scala jeśli piszez w Javie - subiektywne odczucie, ale te 2 języki dzisiaj są najczęściej przypisywane do przetwarzania danych  Jeśli jesteś ciekawy info o tych technologiach, to bloguję o nich, i o przetwarzaniu danych, na https;//www.waitingforcode.com . No i to tyle :);"
"Myślę, że kierowcy tirów również nie są w stanie wyobrazić sobie zastąpienie przez maszynę, a kiedyś się to stanie. Wyobraź sobie sytuację (w mniej lub bardziej odległej przyszłości), gdzie powstanie zupełnie nowy język specjalnie dla AI (taki assembler dla AI). Sytuację, w której analityk powie jakie dane chce przetwarzać i co chce z nich uzyskać i zobaczy wynik bez czytania kawałka kodu, bo zwyczajnie nie będzie w stanie go interpretować. Wiem, że tu już płynę w futurologię, ale w tej branży dekada może zmienić wszystko i nie czuj się tym zaskoczony.;"
"Podoba mi się jak referencjami można opisać przyszłość różnych sfer naszego życia. Tak swoją drogą to skłaniałbym się ku temu, że prędzej zastąpią kobietę niż mężczyznę. Prosta matematyka będzie taniej wyprodukować jedną komórkę, która na 99 % zostanie zapłodniona czy kilka ml spermy z milionami komórek, których prawdopodobieństwo zapłodnienia jest nawet mniejsze niż 1/n.;"
"Na pewno **nie **za kilka lat xD ale w odległej przyszłości - 5-30 lat może to być możliwe, niestety.  Taka duża rozpiętość, bo nie jest wiadome na jakim obecnie etapie jest Google/Microsoft. Coraz więcej wychodzi prognoz na ten temat, nie tylko na głupkowatych polskich portalach, ale również na nieco poważniejszych anglojęzycznych portalach, jakby coś wisiało w powietrzu... w każdym razie temat jest gorący. Jak na razie, tworzone są narzędzia, które znacznie ułatwiają/automatyzują pracę programisty, takie jak np. Developer Assistant (dla C#), które korzystają z rozmaitych algorytmów wyszukiwania rozwiązań z Git'a. Nawet po stworzeniu jakiegoś wielkiego narzędzia przez znane korpo to zawód programisty nie ""wyginie"", ale może znacznie zmniejszyć się zapotrzebowanie, jak i zarobki - tak, że będzie to nieopłacalne... tylko co wtedy stanie się ze wszystkimi programistami ? pewnie niektórzy załapią się na jakieś koło-informatyczne stanowiska pracy, a niektórzy wrócą na jakieś studia magisterskie. Natomiast studenci informatyki poczują się oszukani... ale równie dobrze może być tak, że nawet w przeciągu 50 lat praca programisty nie zostanie zautomatyzowana do takiego stopnia. Byłoby śmieszne gdyby programiści zostali szybciej wyparci przez maszynę niż kasjerzy... bo jak na ironie, wiele ludzi woli jak ktoś za nich kasuje ich zakupy - darmowa obsługa. Natomiast dla firm byłaby to ogromna oszczędność, gdyby programistów dałoby się zastąpić jakimś inteligentnym narzędziem, tak że z kilkudziesięciu/kilkuset koderów zostało by w danej firmie 2-5 programistów.;"
"Ale tutaj w artykule pisze jasno, że Google pracuje nad sztuczną inteligencją, która zastąpi klepaczy kodu, a nie programistów xD;"
"To źle? Mniej klepaczy to lepszy rozwój branży IT i raczej wątpię w teorię ""mniejszych zarobów"". Maszyny zastąpią programistów w ostatniej kolejności na tym świecie ;);"
"Kazdy kto mial chociaz odrobine kontaktu z ai wie ze to jest na takim poziomie ze male sa szanse na zastapienie programistow w bliskim czasie. Trzeba patrzec na to racjonalnie, spadek zarobkow bedzie spowodowany naplywem coraz wiekszej ilosci programistow(informatyka to najpopularniejszy teraz kierunek), oraz przenoszeniem outsourceingu na wschod gdzie pracuje sie za 1/3 tego co u nas a jakosc uslug jest taka sama. To ludzie rozwala ten zawod a nie jakies wydumane sztuczne i inteligencje.;"
"obejrzałem zajawkę   i wydaje mi się, że to narzędzie (podobnie jak np. Kite) to rozwiązywanie złego problemu, nawet jeśli w dobry sposób (tj. te narzędzia rozwiązują problem typu nie chce mi się samemu wyszukać w Google ogólnodostępnych informacji na temat przykładów użycia frameworków a powinny moim zdaniem skupiać się na rozwiązaniu problemów typu nie wiem jak połączyć ze sobą dwa moduły z firmowego frameworka, do którego jest zero dokumentacji, jego kod to syf, a kolega, który go pisał, juz tu nie pracuje. Bo w pierwszym przypadku (nie chce mi się wyszukać czegoś w internecie) to wydaje się, że jest to minimalna oszczędność czasu (bo ile zajmuje wyszukanie czegoś w internecie? Raczej nie wiele...), natomiast rozwiązanie problemu drugiego (jak sprawnie poruszać się w legacy kodzie) mogłoby być naprawdę killer ficzerem, jeśli ktoś coś takiego by zrobił. Wydaje mi się, że to narzędzie Microsoftu prędzej jest konkurencją dla wyszukiwarki Google'a (jeśli chodzi o szukanie dokumentacji, przykładów użycia frameworków itp.), a nie czymś, co zastąpi programistów (prędzej ich ogłupi, bo metoda pracy kopiuj-wklej będzie jeszcze łatwiejsza niż była dotychczas, skoro z poziomu IDE będzie można znaleźć kod do wklejenia).;"
"Jestem w stanie sobie wyobrazić, że powstanie jakieś rozwiązanie Enterprise, które zastąpi pisarzy crudów i formatek (zarówno front, jak i backendowych). Tyle tylko, że powstanie inna nisza, do której będzie się spokojnie można przesiąść. Co do AI to raczej bym się nie martwił, w tej chwili to po prostu kolejne fajne hasełko w stylu ""robimy Big Data/jesteśmy Agile/korzystamy z AI"" które trafiło do mediów. Pamiętam, jak w jednej dużej firmie wprowadzono chat-bota, który miał rozwiązywać ponad połowę zgłoszeń z pierwszej linii. Bardzo fajna prezentacja pokazywała, jak świetnie bot sobie radzi z odczytem nastroju ludzkiego (cztery możliwe parametry), jak świetnie się uczy i jak dobrze dobiera odpowiedzi. Wynik tej operacji jest raczej łatwy do przewidzenia, tzn. skończyło się totalną porażką, bot nic nie umie poza przekierowywaniem ludzi zgłaszających do ludzkiej pierwszej linii. Szef projektu twierdzi, że bot się jeszcze musi uczyć, całe korpo już zdążyło zapomnieć o sprawie.;"
Witam! Czy zawód programista jest jeszcze opłacalny?? Podobno mają zawód ten zastąpić roboty..;
"@Berylo: Powiem tak, nie wyobrażam sobie być programistą wiele lat, tak sie po prostu nie da, ponieważ wiem, że młodsze pokoleni zrobi to lepiej i Ci programiści co sa obecnie stną się mniej wydajni lub zastąpi nas sztuczna inteligencja. Kiedyś myslałem, że trzeba dążyć do pieniedzy jednak jak widzę jak ludzie i znajomi się zabijaja dla pieniedzy, tracą zdrowie, czas spedzony z rodziną itd to coraz bardziej jestem przekonany, że trzeba to równomiernie rozgraniczyć, mniej stresu, może mniejsze zarobki ale wydaje mi sie ze szcześliwsze życie z rodziną (którą zamierzam założyć). Jeżeli chodzi o to 100zł/MD to tyle to jestem w stanie wynegocjować w obecnej firmie, co do auta to posiaadm już fajne auto za około 90-100k i mam gdzie mieszkać w domu, w tym lub pryszłym roku planuje kupic mieszkanie zeby ulokowac pieniadze. Mam też innte małe biznesiki z których czerpie troche kasy ale to nie jest nic związane z IT tylko z tym co uwielbiam robić poza pracą. W tym tyg musze podjąc decyzje czy przejśc do nowej firmy i sie katować dojazdami, spotkaniami, statystykami, i mając nad głowa inne osoby w zamian za kase która będzie rosła czy zostać, wynegocjować trochę wyższą stawke a miec spokojną, dobrze płatną prace i żyć szczęślwie....;"
"Jeśli chcesz naprawdę zrozumieć jak działają sieci neuronowe to nauka matematyki Cię nie ominie. Bez tego nie zrozumiesz takich pojęć jak np. BIAS. Tak naprawdę rozumiejąc matematykę sieci neuronowych dojdziesz do wniosku, że to tak naprawdę żadna inteligencja. Serio, serio. Podczas ""uczenia się"" neuronu bardzo dużo zależy od zastosowania odpowiednich funkcji matematycznych. Inteligencja i prawdziwa nauka polega na tworzeniu się nowych połączeń pomiędzy neuronami w mózgu, a tego sztuczna inteligencja nie potrafi robić. Co do artykułów to nawet tutaj, na forum coś jest: Sztuczne sieci neuronowe i algorytmy genetyczne No i jest jeszcze to, z kodem: http://www.if.uz.zgora.pl/~mdudek/siecineuronowe.pdf Książki są w komentarzach do tego artykułu. W ogóle poszukaj sobie informacji o tym jak zbudować pojedynczy neuron i sterować jego nauką, przykładając odpowiednie funkcje matematyczne. Kod w tym drugim linku wydaje się odrobinę przekombinowany.;"
"Będzie jeszcze ciekawiej jak Biden nie przeżyje całej kadencji i zastąpi go Harris :D Zostaje popcorn i kanapa. Jedyny minus, że dolar będzie spadał, no ale jakoś przeboleję.;"
"Nigdzie nie napisałem, że kogokolwiek o cokolwiek winię. Poza tym chyba nie myślisz że majątek zgromadzony jakieś 100 lat temu w rękach białych tak sam z siebie się rozpłynął i że ma marginalny wpływ na obecną sytuację.  Domagasz się ode mnie naukowego potwierdzenia tez, których nie stawiam. Nigdzie nie stwierdziłem że każdy biały ma jakiś wymierny zysk. Stwierdzam tylko, że czarni nie mieli takich możliwości budowania majątku przez pokolenia jak biali.  Rety, ciągle dzielisz włos na czworo, domagasz się konkretnego określenia kto ile zarobił na niewolnictwie a kto nie. Nie da się tego dziś dokładnie określić, ani nawet określić dobrze co oznacza zarobić na niewolnictwie. Dałem ci przykład, jak te pieniądze krążyły, tego że ""brudne"" pieniądze mogły potem napędzać ""czyste"" interesy. Faktem jest tylko to, że nawet po zniesieniu niewolnictwa majątek pozostawał w rękach białych, historyczne wydarzenia, takie jak wojny światowe czy rozwój przemysłu dawał przewagę w pomnażaniu majątku tym, którzy już ten majątek posiadali. To jakby przy stole do pokera siedzieli czarni i biali, niby każdy dostawał losowe karty, ale czarni nie dostawali asów i króli, a do tego mieli wielokrotnie mniej żetonów niż biali. I teraz gdy biali wygrywają to zaprzeczasz ich uprzywilejowanej pozycji, bo przecież w poprzednim rozdaniu biały John dostał tylko 4 i 7.   https://scholarship.law.upenn.edu/cgi/viewcontent.cgi?article=2283&context=faculty_scholarship Tyle, że wiem, że nie po to domagasz się linków, żeby je przeczytać i zapoznać się z tematem, tylko po to że uważasz że brak twardych wyliczeń wykaże, że biali takich przywilejów nie mieli. Nie, nie wykaże. Efekt procesów historycznych trudno oszacować dokładnymi wyliczeniami i nie na tym analiza historyczna polega. Równie dobrze mogę domagać się od ciebie opisu procesów, które pozwoliłyby czarnym zbudować w wielopokoleniowy majątek w Stanach, albo zdobywać przez nich edukację na równi z białymi.  https://www.researchgate.net/publication/323627869_A_STUDY_ON_THE_GLASS_CEILING_EFFECT_ON_WOMEN_AT_WORKPLACE  To oznacza, że mogą być, a może ich już nie być. Nie wypowiadam się ile ich jest obecnie. 0 samochodów to też mniej niż ileś. Jeśli tak czepiasz się słówek, zastąp sobie ""Przywilejów jest coraz mniej"" zdaniem ""Przywilejów obserwuje się coraz mnie"".  Ale ja nie popełniłem żadnego błędu. Stwierdzam fakt, że przywilejów białych jest mniej niż było kiedyś. Niezależnie od tego czy biali mają wciąż przywileje czy nie, to zdanie jest prawdziwe. Polecam wrócić do lekcji logiki.;"
Pozostało nam tylko czekanie aż AI całkowicie nas zastąpi ;__; O żegnaj piękny zawodzie programisty!;
"A propos zastąpienia zawodu przez AI. Często jako argument dostaję link do: https://willrobotstakemyjob.com/15-1131-computer-programmers Szkoda, że ludzie mylą to z (jak już wyciągają takie głupie argumenty ;) ): https://willrobotstakemyjob.com/15-1132-software-developers-applications;"
"Za 30 lat umiejętności programowania na poziomie podstawowym staną się powszechne. Zresztą będzie to głownie integracja istniejących rozwiązań. Należy sie zatem spodziewać dalszego rozwarstwienia dochodów. Zarobki początkujących spadną prawdopodobnie do poziomu sprzątaczki. Jednocześnie wąska grupa informatyków zajmujących się bardzo zaawansowanymi projektami będzie miała ogromny wpływ na życie milionów, ich dochody wzrosną do poziomu prezesów banków a z czasem uzyskają dużą władzę. Prawdopodobnie ta grupa doprowadzi do tego że dostęp do zawodu zostanie znacznie ograniczony. Będzie to można łatwo uzasadnić zapewnieniem bezpieczenstwa publicznego po tym jak bląd w oprogramowaniu autonomicznych samochodów doprowadzi do serii katastrof. Bootcampy oczywiście znikną bo zastąpi je nauka w szkole. Poza tym ludzi nie będzie już zbyt pociągać kariera programisty. Aby awansować konieczne będzie ukończenie trudnych studiów, zdanie branżowych oraz państwowych egzaminów i pewnie znajomości - podobnie jak jest teraz z zawodami typu lekarz czy adwokat. Dla zdecydowanej  większości będzie to zbyt trudne. Zreszta sztuczna inteligencja zastąpi mnóstwo zawodów. Paradoksalnie zacznie sie właśnie od tych, które wymagają dużej encyklopedycznej wiedzy. Sztuczna inteligencja porówna w sekundę objawy u pacjenta z milionami innnych kart chorobowych i postawi diagnozę trafną na na 95 % gdy lekarze pewnie mają 50 % trafności. Z drugiej strony zawody gdzie wymagana jest sprawność manualna jak kucharz czy sprzątaczka tak szybko nie znikną. Bardzo cenioną grupą bedą specjaliści od cybersecurity bo terroryzm czy nawet wojna będzie polegała na atakach na systemy informatyczne. Poza tym widze jeszcze miejsce dla naukowców i artystów - ich profesji nie da sie tak łatwo zautomatyzować.;"
"optymista XD szkoły publiczne zawsze będą do tyłu, bo taka jest ich natura, tego w jaki sposób są zarządzane, w jaki sposób są tworzone programy i jakiej skali budżetem dysponują. Z g... bata nie ukręcisz. Weź poczytaj jakieś wątki, w których ktoś ma pracę domową do szkoły, a tam jakiś stary HTML sprzed kilkunastu lat, bo tak go uczą w szkole. Technologia będzie iść naprzód, świat będzie też iść naprzód i na pewno szkoły będą iść naprzód - tyle, że zawsze będą w tyle, zawsze będą tzw. ""laggards"" https://ondigitalmarketing.com/learn/odm/foundations/5-customer-segments-technology-adoption/ Oczywiście są szkoły i szkoły. W różnych krajach pewnie będzie różnie. Jeśli w przyszłości jakiś Google, Microsoft czy Facebook będzie zakładał swoje szkoły i wpompuje w to wiele kasy, to na pewno zadba o wiele wyższy poziom z IT niż w polskich publicznych szkołach (czy ogólnie w szkołach publicznych, w różnych krajach jest źle z tym ponoć). Kto wie, może Facebook kiedyś na całym świecie zrobi szkoły, które zastąpią te państwowe.;"
"hmmm... 30 lat... to prawie jak era w IT... pytanie co będzie za 5 lat... ja myślę, że AI nie zastąpi człowieka, to pewne... ale może go wspomóc w podejmowanu decyzji... a programowanie będzie bardziej modelowaniem procesów i objektów programistycznych niż pisaniem tysięcy linijek kodu... ale pożyjemy, zobaczymy... :);"
"Nie wiem skąd pomysł, że programowanie będzie w powszechne w podstawówkach? Chyba nie każdy do tego się nadaje. Poza tym szybciej się rozwijają usługi niż IT. Będzie potrzeba więcej kelnerek. Wg mnie dalsza ewolucja człowieka to dalsza informatyzacja. Ciągły rozwój sieci IT. Będą powstawać narzędzia które ułatwią ich tworzenie, frameworki, biblioteki, języki, whatever, by kodowanie było bardziej intuicyjne. Tylko po to, żeby oszczędzić zasoby, czas, których ciągle będzie brakować. Też można się spodziewać, że tani daleki wschód przejmie sporą częśc rynku, też w ramach oszczędności. Powstaną narzędzia które poprawią jakość ich pracy oraz dostęp do tanich zasobów ludzkich. P.S. AI nie zastąpi człowieka. Sami widzicie, że coraz większy nacisk się kładzie na frontend w webie. A czemu? Bo estetyka ma znaczenie, konkurencja tego wymaga. A tego się nie zautomatyzuje. AI jedynie pomoże zautomatyzować niektóre powtarzalne czynności i tyle, ewentualnie uprościć. Ludzkość przeszła od zer-jedynek do miejsca w którym jesteśmy.;"
"Chyba że manuale kompletnie znikną z użycia i zastąpi je StackOverflow. Już teraz jest tak że projekt typu Zeal jest jakimś ewenementem za który wstyd brać kasę (OSS), a jakość dokumentacji wiodących projektów systematycznie spada (Vue.js chwalony jest za to że ma...dokumentację!). Edit: jednak zrobili możliwość wsparcia tego projektu (Zeal): https://www.bountysource.com/teams/zealdocs;"
"nie wiem skąd taki wniosek - u mnie używamy mocków np. w przypadku, gdy interfejs ma wiele metod a potrzebna jest tylko jedna albo dwie, ale pod warunkiem, że nie ma tam żadnej skomplikowanej logiki. Praktycznie cała reszta została zastąpiona fejkowymi klasami.;"
"Tylko raczej trudno, aby wszyscy politycy byli tymi dobrymi, kompetentnymi, a nawet gdy już się jakiś taki, nie wiadomo skąd trafi... to bardzo prawdopodobne, że zostanie udupiony. Bo gdy już, po latach przedrze się na jakieś ważne stanowisko w partii, nagle może okazać się, że zgwałcił swoją pracownicę. Po 5 latach rozpraw okaże się, że są to zarzuty z d**y wyjęte, ale elektorat już o nim zapomni. A jeśli nie? To i tak nic nie będzie mógł zrobić. Zostanie posłem, będzie miał genialne pomysły(wyjdźmy z takiego założenia) i co wtedy? g**no bo opozycja nie przegłosuje ich tylko po to, aby nie przypisać partii rządzącej racji, co by nie mogła się tymi genialnymi pomysłami pochwalić w trakcie kampanii. Jeśli król trafi się dobry (a z historii wiemy, że nawet w epoce zacofania jakim było średniowiecze nawet przy najprymitywniejszej[teoretycznie] formie monarchii - dynastycznej złych królów to zbyt dużo [żadnego?] nie mieliśmy) i mądry to nie ma najmniejszego problemu, aby pod wpływem swych doradców (największych umysłów w kraju) kraj reformował. Tzn. były z tym problemy ale tylko w demokratycznej Rzeczypospolitej, co doprowadziło do jej upadku.  Jakbyś miał takiego króla, to było by to widać na pierwszy rzut oka, było by wiadomo kogo winić i zostałby zrzucony z tronu. A teraz? Masz odpowiedzialność zbiorową, sam piszesz ""politycy"", a z nich odpowiedzialność przechodzi na wyborców. Gdyby król sprawował władzę w ten sposób to w zamierzchłych czasach zostałby zabity, lub zrzucony z tronu. Dziś w XXIw. moglibyśmy opracować bardziej cywilizowane metody - np. wotum nieufności złożone przez posłów.  <rotfl> Jeśli chcesz przekroju demokracji w dziejach to proszę bardzo: Zaczęło się w Grecji - która upadła (ogólnikowo) z powodu wewnętrznych sporów... a te były spowodowane brakiem silnej władzy jednostki. I już wtedy jeden z największych Greckich umysłów powiedział: ""Demokracja to rządy osłów, prowadzonych przez hieny."" Jak to możliwe, że Grecja o najwspanialszym ustroju, nie miała szans z ""zacofaną"" Macedonią pod silnymi rządami Aleksandra Macedońskiego? Później byli Rzymianie... do czasu (no cóż to chyba największy z narodów jaki istniał), w pewnym momencie sami zamienili demokrację na Cesarstwo. Wczesne Cesarstwo Rzymskie i końcówka Republiki (kiedy rządził Julek) to najświetniejsze czasy tego narodu. Dlaczego upadło? Zawaliło się pod własną potęgą stworzoną przez Cesarzy (jasne, nie wszyscy byli dobrzy - ale to działo się daaaawno temu. Dziś jeśli Cesarz zachorowałby psychicznie lekarze mogli by to orzec). http://pl.wikipedia.org/wiki/Przyczyny_upadku_zachodniego_cesarstwa_rzymskiego Skaczemy dość sporo w czasie i mamy Polskę... przed Mieszkiem I panuje tu demokracja plemienna. AŻ trafia się gość z jajami, jednoczy wszystkie plemiona i zakłada państwo... ah, fuj ta monarchia! Gdyby była gorsza to chyba by się to Mieszkowi nie udało co? Jasne, możecie tłumaczyć - monarchia jest po prostu okrutniejsza, przez co armia jest sprawniejsza... ale to bzdura, armia bez wsparcia gospodarczego itd. sama wojny nie wygra. Przez kilkaset lat mamy w Polsce (słabą) monarchię... i Polska mimo wielu przeciwności idzie do przodu. Później Krzywousty chciał jakąś taką szczątkową demokrację podzielić (podzielił Polskę dla swych synów), ale za dobrze to się nie sprawdziło. Rzeczpospolita Obojga Narodów - nawet szkoda gadać. Potencjał państwa był wielki, a skończyło się rozbiorami. I to raczej nie z powodu silnej władzy króla. I co? W całej Europie ludzie śmieją się, gdy ktoś im mówi o demokracji... podchodzą do niej mniej więcej tak jak wy teraz do monarchii, używają argumentów z d**y wyjętych:  Demokracja? Przecież jej nigdzie nie ma! No, była w Polsce, ale co się tam stało? W Ameryce? Banda powstańców, więźniów, którzy zostali by zmiażdżeni gdyby nie pomoc Francji. 25 lat studiowałem na trzech uczelniach i wy tępi demokraci chcecie mi wmówić, że ten chłop analfabeta ma prawo do głosu takie jak ja? Ameryka - owszem, była demokracja - ale głosowało jakieś 10% ludności, nie było wolności, a między prezydentem a królem nie było dużej różnicy poza tym, że ten pierwszy był czasowy. I nie mówcie, że Ameryka doszła do potęgi dzięki demokracji - doszła do niej mimo. Dzięki niewolnictwu, wojnom i ludobójstwom. Dlaczego demokracja została w Ameryce wprowadzona? Bo nie mieli kandydata na króla, musieli się zjednoczyć (każdy stan był w praktyce osobnym państwem) i wybór jednego władcy spowodowałby waśnie między nimi.  I skąd ten tekst ""dlatego monarchie w europie upadały""? Upadły dopiero nie dawno i to w dość ciekawych okolicznościach, bo razem z demokracją był reklamowany komunizm. ""Nie ma socjalizmu bez demokracji. Podobnie jak nie ma demokracji bez socjalizmu."" Tak więc... dziecko, naprawdę... zanim weźmiesz się za krytykę innych poucz się historii... Jeśli chodzi o to jak królowie sprawowali władzę - są to głównie wypaczenia spowodowane ciemnotą i patologiami ich czasów. A i wtedy np nasz Władysław II Wygnaniec, został wygnany za zbyt brutalne rządy. Tfiu, sie rozpisałem, teraz nie wiem jak przejść do następnych argumentów historycznych. W związku z czym będę je punktował, będzie mi łatwiej.  Rewolucja Francuska jest często podawanym przykładem triumfu demokracji... propagandowo są ludziom wciskane różne kłamstwa na jej temat, ale nie chce mi się nawet o tym wspominać, lepiej oprę się na faktach niezaprzeczalnych - Kilka chwil po rewolucji francuskiej do władzy doszedł, już nie król, a cesarz. Napoleon Bonaparte, który w ciągu kolejnych kilku chwil podbił, lub podporządkował całą Europę. Możliwe jest coś takiego w demokracji? Że wojna jest be? Jasne, że jest ale w tamtych czasach był to główny sposób rozwiązywania konfliktów. Zresztą, co tam wojna mogę mówić o rewolucjach społecznych i gospodarczych. Odpowiedzcie sobie sami, czy w kraju demokratycznym możliwa są zmiany które uczyniły z Rosji i Japonii światowe potęgi? (Piotr Wielki i Mutsuhito) Nawet nie chce mi się tego argumentować, gdyż oczywistym jest, że NIE. Nie żyjecie nawet w demokracji, a w ochlokracji. Demokrację to z dzisiejszych państw ma np. Szwajcaria(i to też nie najlepszą). Monarchie upadły po pierwszej wojnie światowej i zostały natychmiast zastąpione dyktatorami* - dopiero gdy Europa została rozerwana pomiędzy ZSRR i USA stworzono w was taką mentalność i te systemy. Co ciekawe USA zachowało silną władzę prezydenta, a ZSRR zachowało dyktaturę.  Ok, znudziło mi się, wątpliwości pewnie jeszcze się pojawią (prosiłbym o w miarę merytoryczne argumenty) na koniec jeszcze tylko od razu skontrargumentuję najczęstsze argumenty przeciwko demokracji.  ""Bo wy wychodzicie z założenia, że król będzie dobry... a jak będzie zły? ""- Ja wychodzę z założenia, że gdybyśmy mieli posiadać monarchię dynastyczną (a są przecie jeszcze inne) to król od młodego byłby wychowywany przez 10 super niań i uczony przez najlepszych pedagogów świata - a jego ojciec musiałby obrać za małżonkę kogoś o wysokim IQ (np. jakąś noblistkę). W średniowieczu patrzyli na szlachectwo, co doprowadziło do genetycznych wypaczeń, dziś wiemy co nieco o DNA. I - jakim cudem dzieciak który miał genialnych rodziców, który od dziecka byłby uczony patriotyzmu, etyki, politologii, historii itp. mógłby być głupi/zły/okrutny? A nawet gdyby faktycznie był głupi/zły to można mu złożyć wotum nieufności. A nawet przeciętny Kowalski kierujący się dobrem państwa z podpowiedziami Rady Królewskiej, lepiej rządziłby tym krajem, niż partie polityczne z podpowiedziami elektoratu. ""Ludzie się buntują, to znaczy że król nie ma racji"" - spójrzcie sobie na dzisiejsze strajki we Francji. Z pozoru może się wydawać, że przywódca działa wbrew swoim owieczkom, budując dla nich płot, lecz faktycznie chce je ochronić przed wilkami. ""W historii pełno przypadków złych króli"" - no to skupmy się na Polsce - pomińmy okres rozbicia dzielnicowego i królów elekcyjnych. Który konkretnie był taki strasznie, strasznie zły? (A z elekcyjnych najlepszy był Batory, wybrany z d**y - po prostu nazłość) ""Tak jasne, może jeszcze mieszkajmy pod strzechami?"" - to prymitywne i proste skojarzenia. Gdy mówię o powrocie monarchii - to mam gdzieś czy nazwiecie przywódcę królem(który prymitywnie kojarzy się wam z koroną i berłem), czy też Anastazym. Nie o to chodzi. Chodzi o szybki organ decyzyjny nie kierujący się interesem własnej partii, a tylko i wyłącznie kraju. ""Król może się mylić"" - Jasne że może. Tylko gdy król się myli to prędzej czy później dochodzą do tego ludzie, jego doradcy, lub on sam. Nie sposób dotrzeć do tego, czy myli się partia - co pięć dziesięć lat jest nowa i wszystko co złe w kraju, mogą zrzucać jedna na drugą. Tak władca jeśli nie przez współczesnych błby oceniony przynajmniej przez historię. Chyba nie spodziewacie się, że wasze dzieci będą się uczyć na lekcjach historii o Jarosławie Kaczyńskim Wielkim? ""Król wprowadzi dyktaturę"" - akurat największe dyktatury były wybrane demokratycznie (Hitler), lub za zgodą większości (Stalin). ""Monarchie upadły bo były słabe"" - tak i bolszewicy wygrali bo byli silni, lepsi.  Wśród setek argumentów przeciwko demokracji (niektóre z nich składają się wyłącznie z nazwisk, ale i to wystarczy) podam jeden, chyba główny: To żadna władza kiedy ""prawica"" reformuje po lewicy, a lewica reformuje po ""prawicy"". Prawdziwe reformy trwają latami i dopiero po latach można zauważyć ich skutek - 5 lat na ocenienie, czy reforma emerytalna była słuszna (a zmiany i tak wprowadzają na koniec, nie na początek kadencji) to nic.;"
"Nie ma szans, żeby drag'n'dropy zastąpiły kod - to sa fajne rozwiązania dla osób zielonych w temacie, ale profesjonalista dużo szybciej zrobi wszystko za pomocą tekstu. Grafy, klocki i inne cuda nie sprawiają magicznie, że program staje się mniej skomplikowany. Zastanów się, czemu programiści nadal korzystają z terminala, zamiast klikać sobie w GUI? Może dlatego, że jest to potężniejsze narzędzie - dostajesz nieograniczoną ilość ""dodatkowych par rąk"", łatwo możesz operować na całym kodzie, refaktoryzować, podmieniać hurtowo elementy itd. Wbrew pozorom, programowania tekstowe jest po prostu wygodniejsze i wydajniejsze, programowanie graficzne leży w przypadku mocno customowych przypadków i przekształceń programu (i to się raczej nie zmieni, chyba, że pojawi się jakieś super AI, które zajmie się tymi problemami za programistę). Jedyny wyjątek stanowią wg mnie projekty typu http://www.luna-lang.org/ gdzie grafy mają odwzorowanie 1:1 w kodzie - to może mieć sens - pełen dostęp do kodu eliminuje ograniczenia edycji graficznej. PS Nie mówię tutaj o jakiś edytorach gridów itp (które są przdatne), tyko o całej skomplikowanej sieci interakcji.;"
"Strony proste które można stworzyć na wix są robione za max 500zł przez wordpressowca. Za tyle samo ci zrobi profesjonalista taką stronę na wix. Większość klientów którzy przychodzą do normalnej firmy pomimo, że chcą wizytówkę to chcą takich bajerów na niej że czasem przez miesiąc się robi bo a dodajmy tutaj takie przejść hmmm nie zamieńmy na inne, nie zastąpmy to sliderem, a niech teraz z tego przycisku wyskakują 2 gołe laski i tańczą na stole. Klient płaci za godzinę i na koniec za wizytówkę musi zabulić 10k. Sam tego nie zrobi bo nie umie, musi wynająć kogoś kto to zrobi za niego nawet na wix.;"
"Nigdy nie uczestniczyłem w projekcie który miał się skończyć. W programowaniu raczej soft jest ciągle utrzymywany / rozwijany. Gdy przestaje być rozwijany to jest uważany za porzucony i szybko staje się przestarzały i zastąpiony przez coś nowego. Sam omijam szerokim łukiem biblioteki/projekty które na githubie mają ostatni commit 3 lata temu, albo programy które mają ""copyright 2008-2013"" w stopce. Nawet gry mające po 10 lat nadal otrzymują aktualizacje jeśli ktoś w nie gra. Więc nie za bardzo pojmuję pytanie jaki projekt może się skończyć - chodzi o jakieś proste strony wizytówki dla kogoś?;"
"Jakbym miał wskazać język który na pewno będzie używany za 15 a nawet 30 lat to wskazałbym C bo trudno to czymś zastąpić (Rust, Go etc. na razie nie są zagrożeniem), jest podstawą do języków wysokopoziomowych. Ale rynek jest mały i najpewniej będzie też za 15 lat.;"
"Bardzo trudno powiedzieć co to będzie, bo pewnie generalnie dużo się zmieni w ciągu następnych 5 lat i dopiero okaże się w którą stronę to pójdzie. Myślę, że skrajną głupotą byłoby stawiać wszystko na jeden rozwój wypadków. Jeśli nie będzie większych perturbacji i wszystko pójdzie w stronę, na którą nakierowała świat pandemia to pewnie będzie sporo pracy w branży, cyfryzacja będzie postępować. Więcej infrastruktury do zarządzania przeniesienie dużej części procedur wszelkiej maści do sieci, dużo wyzwań w zakresie bezpieczeństwa. Przemysł cyberwojenny — już na dobrą sprawę, wojny przeniosły się w sferę informacyjną, strzelanie i niszczenie stało się wręcz dodatkiem, a nie daniem głównym. Co do AI, jestem raczej sceptyczny. W niektórych zastosowaniach się przyjmie, autonomiczne samochody pewnie będą jeździć, tak jak jest używane w analizie danych, pewnie będzie używane, ale przypuszczam, że koniec końców nie będzie tu rewolucji na skalę jaką wielu sobie wyobraża. Podstawowy problem polega na tym, że jak na razie trzeba sztuczną inteligencję przyuczać do określonych zadań co jest bardzo dużym ograniczeniem. To może wykosić plankton, ale poważnych specjalistów raczej prędko nie zastąpi. Moja obserwacja jest taka, że AI dobrze sobie radzi tam gdzie szlaki są ostro przetarte, jak nie są, produktywność sztucznej inteligencji jest żałosna, często to widzę na google translate, albo jak google nie potrafi wyłapać oczywistej dla człowieka literówki w mało popularnym wyrazie. To wszystko oczywiście przy założeniu, że gospodarka się nie posypie zupełnie, obawy ekologów okażą się bezpodstawne, a USA odda hegemonię bez większej draki. Jak gospodarka się rypnie to już moze już nie być dla kogo pisać programów. Przyszło nam żyć w ciekawych czasach i na moje, równie prawdopodobne zdają się zarówno katastroficzne jak i  świetliste scenariusze. Z drugiej strony, jeśli jesteś dobrym programistą, pewnie jesteś dość inteligentny, masz dość pokory i ogarniętą cyfrozę, w każdej sytuacji ułożysz sobie jakoś życie dopóki będziesz żyć. ;);"
"Wszystko zależy od tego gdzie się pracuje. W branży oprogramowania tak jak w dziewiarskiej, czy większości innych istnieją sweat shopy i nie ma co temu zaprzeczać. Nie wyobrażam sobie jednak ze te miejsca wypełnione są ludźmi z ambicjami. Tak samo jak nie wyobrażam sobie zeby hft devrlopera w banku inwestycyjnym zastapilo 100 hinduskich programistów.;"
"Jak kolejne zawody przestaną być potrzebne z racji automatyzacji, to ludzie ruszą masowo bycie programistą. Wtedy konkurencja będzie ogromna i sporo obecnych ""klepaczy"" potraci pracę, zastąpią ich inteligentni ludzie którzy normalnie byli by inżynierami innej branży.;"
"WYSIWYGi mające zastąpić frontendowców to kompletny idiotyzm - albo korzystamy z gotowców i w zasadzie nie trzeba frontendowca na stałe albo robimy coś oryginalnego i WYSIWYG niewiele pomoże, bo jego możliwości się szybko skończą. Podstawową różnicą między systemami informatycznymi, a np częściami samochodowymi jest to, że integracja dużego systemu informatycznego z małych klocków to droga przez mękę, natomiast składanie samochodu z części od różnych producentów to norma i standardowa procedura. Programowaniem ludzkość zajmuje się kilkadziesiąt lat i jakoś do tej pory nie opracowano zgrabnego sposobu budowania dużych systemów z małych klocków z minimalnym wysiłkiem przy integracji. Inna różnica to np to, że taka modyfikacja silnika w samochodzie zwykle nie musi pociągać za sobą modyfikacji innych elementów podczas gdy w systemie informatycznym nawet niewielkie zmiany funkcjonalności pociągają za sobą zmiany wielu komponentów. To też sprawia, że pracy dla programistów jest więcej. Rozwiązanie obu powyższych problemów nie zależy od mocy obliczeniowej (tej już jest mnóstwo za niewielkie pieniądze) ani od jakiejś mitycznej sztucznej inteligencji. Rozwiązanie jest po prostu bardzo trudne (albo i niemożliwe), a bez niego pracy dla programistów będzie ciągle bardzo dużo.;"
"A ja powrócę do głównego tematu. Czy AI zastąpi programistów? Tych myślących, raczej nie. Tych trzaskających WP: być może. Całkiem fajny wykład na ten temat udzielił Andrzej Krzywda:   temat poboczny: Hindusi w IT -> temat wałkowany od wielu lat, raczej nam to nie grozi. Aktualnie jest raczej trend przenoszenia produkcji z Chin / Indii do Polski niż odwrotnie.;"
"Informatycy mają tendencję od samego początku do automatyzowania swojej pracy, do tworzenia coraz większych abstrakcji. Kiedyś programowanie było bardzo trudne bo musiałeś zagłębiać się w aspekty techniczne - ogarniać co to są instrukcje oraz rejestry procesora,co to jest sterta, stos. Musiałeś też wykazywać się większymi umiejętnościami matematycznymi oraz algorytmicznymi. Teraz nie musisz tego wszystkiego ogarniać. Możesz posługiwać się bardzo abstrakcyjnymi językami jak python, a do problemów algorytmicznych  jak sortowanie używać gotowych bibliotek. Obecnie programowanie przypomina trochę stawianie stronek na WordPressie. Masz CMSa (framework) i instalujesz sobie jakieś rozszerzenia do niego (biblioteki) i łączysz je w całość mając gotową stronę i nie mając zielonego pojęcia jak to naprawdę wszystko działa. Różnica między CMS i frameworkiem jest taka, że framework jest tekstowy a typowy CMS jest wizualny. Mam wrażenie, że za jakiś czas pojawią się bardziej wizualne frameworki i języki programowania. Coś jak Scratch ale dużo lepsze. Programowanie stanie się powszechną umiejętnością. Z resztą tak powinno być. Obecna sytuacja jest trochę chora ponieważ to finansiści powinni tworzyć systemy finansowe a na przykład lekarze systemy medyczne. Ludzie którzy naprawdę rozumieją swoją dziedzinę (domenę). Duża ilość oprogramowania jest c**** przez to, że programiści to osoby które potrafią  tylko programować i kompletnie nie rozumieją systemów które tworzą. Uważam więc, że 80% współczesnych informatyków zostanie zautomatyzowana i zastąpiona. 20% który nigdy nie zostanie zautomatyzowane to ludzie tworzący narzędzia, frameworki, biblioteki, rozwiązujący niebanalne problemy (których jest mało ogólnie) albo zajmujący się innowacjami z pogranicza informatyki i elektroniki (robotyka). Już teraz widzimy ten problem semantyczny wkładania klepaczy kodu układających klocki i inżynierów do jednego worka 'programistów'. Generalnie rynek nie potrzebuje inżynierów a klepaczy kodu i rzeczywiście wierzę, że ogólnie czeka nas zapaść. Ogólnie sama umiejętność programowanie będzie tak powszechna jak umiejętność pisania i czytania. Nie będzie tak jak teraz, że wystarczy tylko to umieć ( w sensie programować) i będziesz zarabiał duże pieniądze.;"
"Podsumowując programiści boją się, że to AI ich zastąpi, to się raczej nie stanie, zastąp ich zwykły kowalski :) Samo 'programowanie' wróci do swoich korzeni to znaczy do algorytmiki, matematyki i cybernetyki. 'Programiści' będą tworzyć narzędzia dla zwykłych ludzi by ci sami automatyzowali swoją pracę i tworzyli systemy z których będą korzystać.;"
"Do zastąpienia programistów przez sztuczną inteligencje jeszcze daleka droga... Najpierw z rynku wyparci zostaną pracownicy fizyczni, później na odstrzał pójdą inne zawody. ale wzrośnie zapotrzebowanie na zawody - takie jak: elektroników, grafików (twórcze myślenie), inżynierów materiałowych, inż budownictwa, inż. zarządzanie produkcją itp. Programiści od web'a pewnie też zostaną wyparci (nawet dobrzy)... natomiast, nie wiadomo czy programiści od gier i aplikacji mają się czego obawiać... z pewnością zostaną dłużej na rynku niż web. Wniosek z tego taki, że trzeba trzymać się zawodu, który jest na topie... obecnie to programowanie, później nie wiadomo co będzie ""trendy"". Być może czeka nas przebranżowienie... no chyba że kogoś będą zadowalać niskie zarobki.;"
"O tak oczywiście masz rację Spine, że obecny system to niewolnictwo w 100%, ale jak na razie dla tych którzy chcą pracować jakaś tam praca się znajdzie aby zarabiać. Pomyśl co się stanie kiedy technologia będzie w stanie zastąpić 90% ludzkości...co wtedy będzie ?;"
"@serek jakie dane takie zapytanie inaczej się nie da, @jaryszek dwie uwagi do zapytania, możesz je uprościć (zakładając że puszczasz je w accessie) Jak nie masz punktu zaczepienia między tabelami, to ja bym wyliczał np. md5 dla rekordu i porównywał wyliczone wartości To oczywiście zależy od ilości danych, bo dla jakieś dużej wartości może to dobic Accessa. Jeżeli jest ich strasznie dużo to użyj funkcji nz i wtedy: ( t2.percentsnapshotspace = t1.percentsnapshotspace                      OR ( t2.percentsnapshotspace IS NULL                           AND t1.percentsnapshotspace IS NULL ) )   możesz zastąpić:  Nz(t2.percentsnapshotspace,""NULL"") = Nz(t1.percentsnapshotspace,""NULL"")  Dodatkowo zrobiłbym sztuczną kolumnę w podzapytanie, aby w where pytać tylko o jedna kolumnę SELECT  	DISTINCT *  FROM 	(SELECT DISTINCT 		MD5_string(nz(ordinal,""NULL"") & NZ(environmentid,""NULL"") & NZ(tierid,""NULL"") & NZ(physicaldiskmodelidfk,""NULL"") & NZ(volumenameidfk,""NULL"") & NZ(disknumber,""NULL"") & NZ(filesystemtype,""NULL"") & NZ(percentsnapshotspace,""NULL"") & NZ(sharemode,""NULL"") & NZ(subjectcomponent,""NULL"") & NZ(formatcommand,""NULL"") & NZ(description,""NULL"") & NZ(function,""NULL"") & NZ(caching,""NULL"") & NZ(writeacceleratorenabled,""NULL"")) AS MD5 		,* 	FROM 		tblvolumes) AS t2      LEFT JOIN (select DISTINCT 					""jestem"" as obecny 					,MD5_string(nz(ordinal,""NULL"") & NZ(environmentid,""NULL"") & NZ(tierid,""NULL"") & NZ(physicaldiskmodelidfk,""NULL"") & NZ(volumenameidfk,""NULL"") & NZ(disknumber,""NULL"") & NZ(filesystemtype,""NULL"") & NZ(percentsnapshotspace,""NULL"") & NZ(sharemode,""NULL"") & NZ(subjectcomponent,""NULL"") & NZ(formatcommand,""NULL"") & NZ(description,""NULL"") & NZ(function,""NULL"") & NZ(caching,""NULL"") & NZ(writeacceleratorenabled,""NULL"")) AS MD5 					, *  				from 	 					qryim_sourcevolumes) AS t1 ON T1.MD5 = T2.MD5 WHERE       t1.obecny is null  Funkcje nd5_test możesz mieć stąd: https://www.di-mgt.com.au/src/basMD5.bas.html;"
"Podstawowy problem jest taki, żeby ta praca programisty była na tyle stabilna żeby można było z powodzeniem później utrzymać rodzinę. I to jest wydaje mi się główny czynnik składowy, który to może zaważyć nad tym czy dany programista będzie miał szanse na założenie rodziny i stabilny związek. Oczywiście można szpanować że się zarabia te 10k na łapkę, pytanie czy to będzie stabilne i jak długo takie eldorado będzie trwało? Bajera to raczej tylko środek do osiągnięcia pewnego celu. Wiadomo że takie typowe informatyczne nerdy będą miały pod tymi względami przerąbane jeśli chodzi o wszelkie relacje, co nie znaczy że od razu powinni być spisani na straty. Gdzieś czytałem, że dla mężczyzny idealną partnerką będzie taka o cechach jego matki, dla kobiety będzie to ktoś o cechach jej ojca, taka jest przynajmniej teoria. Miało by to jakieś logiczne wytłumaczenie, partnerka zastąpi matkę, partner zastąpi ojca, oczywiście mówię o pewnym obszarze odpowiedzialności i funkcji. Nie wiem jak pod tym względem jest w praktyce. Zawód programisty ma to do siebie, że jest na tyle trudny, że żeby być tym dobrym to trzeba wiele lat nauki, poświęcenia i wyrzeczeń, możliwe że to ostatnie ma jakieś istotne znaczenie w tych sprawach, zwłaszcza jeśli chodzi o sytuacje, kiedy to ktoś taki, kto jest bardzo dobrym programistą nie radzi sobie w relacjach towarzyskich bo olał to poświęcając się nauce. Choć wydaje mi się że to wszystko ma źródło tak naprawdę w dzieciństwie a potem to wszystko się zacznie utrwalać przez lata i mamy oto efekty.;"
"Ponieważ ViewModel jest ograniczony pod względem tego, jak się go tworzy. Wolałbym zastapić zwykłą klasą, która nie ma narzuconych ograniczeń.  No to przecież napisałem, że są testy, które prawie niczego nie testują. Usunięcie tych interfejsów wymusiłoby napisanie prawidłowych testów. Głównie w warstwie prezentacji w moim przypadku. Przykładowo wolałbym pozbyć się interfejsu LoginUseCase, bo niczego nie wnosi. Wtedy wystarczy dostarczyć sztuczną implementację AuthService na potrzeby testów. Uporściłoby to też graf obietków. public interface LoginUseCase extends ObservableTransformer<LoginAction, LoginResult> { }  public final class LoginTransformer implements LoginUseCase {   private final AuthService authService;   private final TokenCache tokenCache;   private final Moshi moshi;    @Inject public LoginTransformer(AuthService authService, TokenCache tokenCache, Moshi moshi) {     this.authService = authService;     this.tokenCache = tokenCache;     this.moshi = moshi;   } }  @Binds abstract LoginUseCase bindLoginPickupUseCase(LoginTransformer transformer);   Zgadzam się z drugim stwierdzeniam, bo Dagger wymaga większej ilośc kodu na starcie pod fundamenty dostarczania zależności, ale to Koin wymaga więcej boilerplatu niezależnie od fazy aplikacji.;"
"Uśredniając to, co udało mi się przeczytać i usłyszeć: w dłuższej perspektywie czasowej będzie to technicznie możliwe, by za pomocą AI zastąpić do 90% czynności finansowo-księgowych, które polegają na relatywnie prostej, powtarzalnej pracy ze skończoną liczbą opcji decyzyjnych. Przenosząc to na grunt dużego miasta w Polsce: jakieś 3/4 stanowisk w godnie płacących korpo (BPO/SSC) to właśnie stanowiska Junior/Mid/Senior AP/AR Accountant w działach zobowiązań czy należności, których pracownicy sami przyznają się do tego, że wymaga się od nich raczej języków i dyplomów niż maestrii w księgowości. Tak więc jeśli Główny Księgowy ze znacznymi doświadczeniem i znaczną liczbą obowiązków zostanie uwolniony z konieczności zajmowania się w/w przyziemnymi i powtarzalnymi czynnościami, to będzie mógł skupić się na zadaniach managera i konsultanta z korzyścią dla siebie i wszystkich wokół, ale kiedy to samo spotka klepacza faktur, to jego los jest raczej oczywisty. Problem polega na tym, że w BPO/SSC na jednego wymiatacza na wysokim stołku przypada niezdrowo duża liczba klepaczy. Oczywiście temat jest dyskusyjny i do pewnego stopnia jest to czysta futurologia (żeby nie powiedzieć rumpologia), więc każdy może sobie tutaj rozrysowywać swoje scenariusze. Nie zmienia to faktu, że ogarnięci ludzie w branży nie widzą jej przyszłości w różowych barwach.;"
"Jeszcze jedno pytanie. Jak oceniacie sposoby nauki języków programowania (e-booki,videokursy,ksiązki). Osobiście mam kilka e-booków,videokursów na komputerze i jakoś nauka wygląda nijak. Nie wiem jak wygląda siedzenie z książką ale wydaje mi się trochę wydajniejsze. Bo chyba ciężko zastąpić książkę z 1,5k stron videokursem 8k a czynie ebooków na komputerze nawet tych co maja ponad 200 stron to katowanie oczu :);"
"Gościu jaki Comarch? Nikt normalny nie pójdzie po AGHu do firmy, w której nic się nie nauczy. Ludzie po AGHu pracują w Google-u, Intel-u, IBM a nawet Facebooku. Naczytałeś się jakichś głupot i powtarzasz. Ludzie po AGH to elita na rynku juniorskim. Nie mówię o jakichś stosowanych informatykach, które są na poziomie bootcampu. Statystyki mówią same za siebie - po AGHu 90% ludzi dostaje zatrudnienie nie płacąc ani złotówki. Po waszym śmiesznym kursie 25% osób dostaje praca jak ma farta i musi spłacić 16.000 kredytu. Większość uczelni to jest chłam, zgadzam się ale AGH to jest elita w Polsce i każdy kto tam nie studiował niech się nie wypowiada o poziomie studiów. Bo absolwenci AGH przewyższają każdego bootcampowicza pod każdym względem. Wy się uczucie na tym kursie wstawiania przycisków i kolejnego CRUDa według określonego schematu. Nas nie uczą konkretnej technologii, ale kładą ogromny nacisk na nasz rozwój intelektualny, umiejętność samodzielnego myślenia, rozwiązywania problemów. Nikt nam nie tłumaczy jak robić CRUDa bo to nie ma sensu, po AGHu wychodzą ludzie myślący, a trzymani za rączkę jak na kursie. To właśnie wy po kursie jedyne co możecie zrobić to klepać tego cruda czy tam szabloniki do wordpressa. A my absolwenci AGH rozwijamy sztuczną intelegencję, która takich klepaczy jak wy umiejących jedynie klepać kod w danej technologii, prowadzonych za rączkę na kursie, za parę lat zastąpi :);"
"Mam takie wrażenie, że niektórzy myślą, że ja po bootcampie online spodziewałem się robić algorytmy w dla Googla. Nie o to było moim celem. Klepie crud-y, ale zarabiam 800 zł więcej niż w poprzedniej pracy. Mogę zacząć pracę między 7-10, spokojnie dzieci do szkoły zawiozę. Nikt  nade mną z batem nie stoi i nie robi wrzutów, że plan nie zrobiony. Pracuje spokojniej. No i jakaś podwyżka po nowym roku będzie, odgórnie tak jest w firmie co rok. Nie muszę się prosić. I tak prawdę powiedziawszy jak będziesz sobie robił dla tego FB, czy innego Googla algorytmy, za 20K, czy 30K to na zdrowie mnie nic z tego tytułu nie ubędzie i gratuluję wyboru drogi życiowej w młodości. Pewnie kiedyś SI zastąpi takich klepaczy jak ja, ale na teraz jest super. I taki drobny niuans, nawet jak czujesz się lepszy i elitarny jak zwał tak zwał, to zachowaj to dla siebie. Gdyż z mojego wieloletniego doświadczenia w różnych pracach i firmach, wiem że aroganci (bez pleców) nie są mile widziany. Jakie umiejętności by nie mieli. To jest często praca zespołowa i z takim podejściem to ... No nikt nie chcą ludzie pracować z dupkiem. Nie daj Ci Boże, żebyś trafił na przełożonego z kompleksem małej uczelni z krańca świata i wygłosił taką mądrość. Jeżeli to będzie mały człowiek to Cię zniszczy i pójdziesz z łatką ""trudnego"" w świat. Zdziwisz się jakie małe potrafi być środowisko dużych korpo. Tak przy okazji znam programistę, który dawno temu nie dokończył jednej z prestiżowych uczelni, bo go normalnie nudziło i miała za niski (w jego odczuciu) poziom. Od kilkunastu lat pracuje w firmie na M, nie w Polsce, nie mam pojęcia ile zarabia. Człowiek ten jest jednostką wybitną i myślę, że przerasta o epokę 90% populacji z którą pracuje. Przy tym jest miłym, uczynnym i pomocnym człowiekiem. Nigdy nie da Ci odczuć, że uważa się za lepszego. Jak czegoś nie rozumiesz wytłumaczy jak małemu dziecku najbardziej zawiłe sprawy. Dla mnie on jest elitą.;"
"Dziękuję za wszystkie opinie. Z reklamami jest porażka, fakt - bo na wszystkich stronach zmieniłem z googla na adkontekst, a tam nie ma cienkich z linkami. W najbliższym czasie to naprawię. Będę starać się w miarę często dodawać artykuły. Dział obrazy zostanie zastąpiony ""Źródłami"". Miał służyć troszeczkę inaczej. Aktualnie (mam nadzieję że dzisiaj skończę) piszę artykuł, który pokazuje swojego rodzaju ewolucje HC[hill climbing]->SHC[settled hill climbing]->SA[simulated annealing] dla problemów dyskretnych. Jeszcze raz dziękuję za wszystkie opinie, na pewno w pozytywnym stopniu wpłyną na rozwój ""stronki"". Jakub Niwa;"
"Ok, ale nie każdy lubi się uczyć i co wtedy? Gorszy jest? Poza tym gdyby się wszyscy tak uczyli, to kto pracował by fizycznie? Mam wrażenie, że wiele osób tutaj czuje się lepsza od innych bo ma prace umysłową. Ja tam też uważam, że nie każdy musi być wielkim fanem wiecznego rozwijania się, pracowania, rozwijania się, pracowania itd. Każdy ma inne priorytety i o ile zgadzam się, że normlane jest to, zę ten kto ciężko pracuje i się rozwija zarabia więcej, ale to nie znaczy, że pracownik fizyczny ma żyć jak śmieć. Ja osobiście w przeciwieństwie do aurel uważam, że to własnie coś normalnego, że każdego pracującego powinno być stać na mieszkanie i samochód, bo to nie są żadne dobra luksusowe. Poza tym aurel, żebyś się na tych swoich dość radykalnych poglądach nie przejechała. Teraz jesteś młoda, masz ochote, siły i czas na uczenie sie, zwiedzanie świata. Ale pamiętaj, że Ty też sie zestarzejesz. Myślisz, że jak będziesz po 40 to nadal będziesz miała tyle sił? Pamiętaj, światopogląd może CI sie zmienić. Wiem, że za młodu można odłożyć pieniądze i potem zainwestować w jakiś choćby mały biznes, który z powodzeniem zastąpi emeryture, ale należy pamiętać, żę nie każdy ma predyspozycje do prowadzenia firmy, nie każdy ma pomył na biznes. Poza tym co by było, gdyby nagle wszyscy firmy pozakladali? Państwo potrzebuje każego rodzaju ludzi, i tych wykszałconych naukowców, ale i tych po zawodówce. To dzięki współpracy wielu ludzi technologia się rozwija. Jedni opracowywują jakieś pomyły, ale ktoś musi to też wykonać/zbudować.;"
"Piekło socjalizmu dopiero nadejdzie za mniej więcej 5 - 15 lat, a później będzie tylko gorzej.  Te wyliczenia z artykułu to tak naprawdę bajka w porównaniu z najbliższą przyszłością. Przyszłość w kategoriach 5 - 20 lat jest taka, że w wyniku automatyzacji, robotyzacji, rozwoju machine learningu kilkadziesiąt procent populacji stanie się trwale bezrobotna. Oczywiście silna sztuczna inteligencja to wciąż science fiction i nie ma żadnej teorii, która pozwoliłaby ją zrealizować, więc naukowcy, inżynierowie, programiści mogą spać spokojnie. Natomiast kierowcy zostaną zastąpieni przez self-driving car Google. Księgowi, pracownicy administracyjni, 30 tys osób z back office w Krakowie z firm typu Capgemini, State Street, UBS, HSBC zostaną zastąpieni przez software w rodzaju Amelii Ipsoftu, Watsona IBMu. Przykładowe linki: http://www.telegraph.co.uk/technology/news/11123336/Meet-Amelia-the-computer-thats-after-your-job.html http://www.ft.com/cms/s/56b9320e-7af4-11e4-8646-00144feabdc0,Authorised=false.html?_i_location=http%3A%2F%2Fwww.ft.com%2Fcms%2Fs%2F0%2F56b9320e-7af4-11e4-8646-00144feabdc0.html%3Fsiteedition%3Duk&siteedition=uk&_i_referer=#axzz3UNIHedHu http://www.huffingtonpost.co.uk/2014/10/03/amelia-artificial-intelligence-ipsoft_n_5920964.html  Ta część ludzi, która wciąż będzie miała pracę będzie musiała utrzymywać emerytów, rencistów i strzelmy 30% trwale bezrobotnych ludzi w wieku produkcyjnym. Dodajmy, że Polska ma bardzo mało własnych innowacyjnych firm, nie mówiąc o gigantach typu Google, IBM czy Ipsoft, więc od prawdziwych globalnych kapitalistów to kasy nie ściągniemy. Teraz wystarczy sobie posortować od największego jak opodatkowanie wygląda aktualnie w UE: http://en.wikipedia.org/wiki/List_of_countries_by_tax_rates Teraz jest socjalizm na takim poziomie, że krok w lewo jest już sowiecki komunizm, a jakie piekło socjalizmu będzie za 5-15 lat to trudno sobie wyobrazić...;"
"To możesz nie dawać tradycyjnego MIT a inną bardziej restrykcyjną licencję, która cię chroni w mocniejszy sposób. Albo w ogóle nie umieszczać nigdzie źródła, a samą aplikację z zamkniętym kodem gdzieś do pobrania, czy do korzystania, jeśli to aplikacja online (jak to dobra aplikacja, to jeszcze mógłbyś coś zarobić na niej).  Zależy jaka firma. Startupy bardziej będą szukać talentów, a korpo bardziej będą szukać osób przeciętnych, łatwych do zastąpienia w przyszłości. Może tak im wygodnie. Startupy pragną się rozwijać jak najszybciej, więc potrzeba im tęgich głów, a korpo już się rozwinęły i tylko potrzebują kogoś na ""taśmę fabryczną"" kto po prostu zrobi swoje obowiązki wg ustalonych wytycznych z góry. Tyle, że to gigantyczne uproszczenie - wielkie firmy mogą dalej zachowywać się jak startup (np. Facebook) a nawet małe firemki mogą działać zachowawczo niczym korpo (wtedy są to tzw. JanuszSofty, czyli malutkie firemki bez przyszłości, które nie rozwijają się w żaden sposób tylko ciułają i starają się utrzymywać na powierzchni, żeby nie zbankrutować i żeby prezes Janusz miał świeży dopływ gotówki każdego miesiąca). Anyway, co z tym można zrobić?  zmienić branżę (ale wątpie, żeby w innych branżach było lepiej) poszukać firmy, która faktycznie szuka talentów i docenia kreatywność założyć własny biznes   Bo rekrutacja w IT jest poje*ana ;) To wszyscy wiedzą. Tyle, że warto się czasem przemęczyć, bo:  bez przejścia procesu rekrutacyjnego zwykle się nie dostanie pracy bez pracy się nie ma kasy, a jest o co grać - płace programistów są kilkukrotnie większe niż w innych zawodach sama praca może być pouczająca z wieelu powodów:   można się nauczyć lepiej programować, uczyć od lepszych od siebie czasem (jak się ma szczęście) można się nauczyć lepiej współpracować z ludźmi, lepszej komunikacji itp. a to się przydaje. nabywa się umiejętności rozwiązywania wielu problemów, na które by się człowiek nie natknął nawet samemu poznaje sie jak firmy IT wyglądają od środka, i zobaczyć zarówno dobre rozwiązania jak i słabe (np. zobaczyć problemy, które dławią firmy i opóźniają projekty). Taka wiedza może się przydać potem przy zakładaniu własnej firmy kiedyś (żeby nie powtarzać cudzych błędów);"
@somekind wielkie dzięki za swoje spostrzeżenia i uwagi co do mojego kodu. Zastosowałem się do nich i kod wygląda teraz o wiele przyjaźniej. Oddzieliłem także metody używające WriteLine od logiki. Mam pytanie. Nie mam pojęcia jak mogę zastąpić inaczej odróżnianie gry vsPlayer od vsComputer... Bo teraz ciągle służy mi do tego ten if: if (player is HumanPlayer)  Efekt końcowy projektu wygląda następująco:   Kolko i krzyzyk ver. 1.2.zip (72 KB) - ściągnięć: 117;
"Wstęp Poradnik na przykładach w PHP i JavaScript działających na serwerze z obsługą .htaccess/mod-rewrite (prawie każdy to ma). W poniższym poradniku wyjaśnię w jaki sposób wstawić obrazek na stronę WWW. Celowo jednak pominę obrazy wektorowe bo to osobne zagadnienie zasługujące na osobny temat. Zostaje nam zetem grafika rastrowa - czyli formaty typu: jpeg, bmp, webp, png itp... Czyli sprawę załatwia proste IMG SRC:   <img src='moj-obrazek.jpg' alt='obrazek'>  Teoretycznie poradnik można w tym miejscu zakończyć. Niby tak i wydaje się to być banalne jednak w praktyce niekoniecznie ponieważ pod uwagę trzeba wziąć jeszcze:  optymalizację rozmiaru zdjęcia ( aby nie serwować zdjęć wprost ""z aparatu"" o rozmiarach rzędu 6000x4000); przygotowanie odpowiednich miniaturek dla wszelkiego rodzaju galerii; przygotowanie zdjęć dla różnych szerokości ekranów; umieszczenie zdjęcia w kontenerze trzymającym je w właściwym miejscu i obszarze strony; kadrowanie; zastosowanie mechanizmu lazy-load; cache'owanie miniaturek.  Trochę się tego nazbierało, choć to nie wszystko - na początek jednak wystarczy. O ile w sensownych narzędziach CMS tego typu procesy wspierane są automatycznie lub poprzez specjalne pluginy to robiąc stronę od podstaw trzeba wszystko ogarnąć samemu. Ogarnięcie wszystkiego na pozór wydaje się być trudne ale nie ma się co bać. Większość problemów możemy rozwiązać pisząc prostą bibliotekę zawierającą kilka funkcji odpowiedzialnych za:  wczytanie obrazka do pamięci PHP; skalowanie kadrowanie; konwersję formatów; zapisanie wyniku w pliku cache.  Omówmy jednak wszystko od początku... Przygotowanie zdjęcia Zdjęcie źródłowe - to podstawowy element, z którym będziemy pracować, powinno być wysokiej jakości i dużej rozdzielczości po to aby można było je zastosować zarówno w sliderze na całą szerokość ekranu jak i w małej zajawce. Zdjęcia źródłowego nigdy nie będziemy serwować wprost poprzez WWW. Zawsze będziemy przygotowywać zdjęcie odpowiednio dostosowane do warunków jakie stawia projektowana strona WWW. Dla formalności przypomnijmy jakie są podstawowe i ważne dla nas cechy zdjęcia:   rozmiar pliku ( wyrażany w bajtach, kilobajtach lub o zgrozo w megabajtach );  wysokość i szerokość wyrażana w pikselach;  proporcje wynikające ze stosunku wysokości do szerokości;  rodzaj kompresji - stratna lub bezstratna;  stopień kompresji (przekłada się na jakość);  Naszym celem podczas przygotowania odpowiednich miniatur do wstawienia na stronę będzie zawsze:  kadrowanie / obcięcie zdjęcia w taki sposób by dobrze wpasowywało się w projektowaną stronę https://pl.wikipedia.org/wiki/Kadrowaniewanie). maksymalne zmniejszenie rozmiaru pliku jednak przy zachowaniu wymaganej jakości i ostrości, zmniejszenie wysokości i szerokości do optymalnej dla przewidzianego obszaru, w którym zdjęcie będzie prezentowane.  Teoria brzmi super ale jak to zrobić w PHP, jak dokładnie powinna wyglądać biblioteka wspierająca, jak cache'ować? Na potrzeby poradnika wyciągnąłem ze swojego niemal 15 letniego framework'a trochę kodu. Głównie interesuje nas klasa przygotowująca zdjęcia, która na wejściu przyjmuje następujące informacje:  DEFINE ( ""CI_FORMAT"", ""webp"" ); DEFINE ( ""CI_IMG_CACHE_DIR"", ""assets-cache/"" ); DEFINE ( ""CI_PLACEHOLDER"", ""assets-src/img-placeholder.jpg"" ); DEFINE ( ""CI_PLACEHOLDER_FORMAT"", ""jpeg"" );  class CacheImage{      public $sourceUrl = '' ;           // Nazwa zdjęcia źródłowego lub adrres URL jeśli PHP wspiera CURL w funkcji file_get_contents.                                      //   public $width = 0 ;                // Parametry width oraz height określają jaki rozmiar obrazka otrzymamy po przeskalowaniu.   public $height = 0 ;               // Parametry powiązane są z polem $aspectRatio                                      // i w zależności od jego warości zachowują się różnie.                                      //   public $aspectRatio = true ;       // true - zachowuje proporcje i wpasowuje obraz w prostokąt                                      // zadany przez parametry width i height lub wylicza automatycznie                                      // gdy jedna z nich ma wartość = 0.                                      //                                      // false - skaluje obrazek do rozmiarów zadanych wprost przez                                       // parametry width i height bez zachowania proporcji - oba parametry muszą być > 0.                                      //                                      // 'cropping' - ze środka obrazu wycina fragment o rozmiarach zadanych przez parametry                                      // width i height przy założeniu że wycinany jest zawsze największy moążiwy obszar.                                      // Proporcje są zachowywane.                                      //   public $suggestedFileName = '' ;   // Sugerowana nazwa pliku cache/docelowego. Zostaną do niej doklejone informacje o parametrach                                      // związanych z przekształceniami obrazu źródłowego.                                      //   public $defaultQuality = 60 ;      // Poziom kompresji.                                      //   public $useHtacces = true ;        // true - przygotowuje tylko plik nagłówkowy obrazka.                                      // Fizyczne przekształcenia i jego odczyt następują dopieo po wywołaniu adresu pliku z przeglądarki.                                      // W operacji tej niezbędny jest plik .htaccess odpowiednio obsługujący tego typu zapytania do serwera.                                      // Ta opcja powinna być stosowana podczas przygotowywania obrazów na stronę WWW.                                      //                                      // false - obrazek przygotowywany jest w trakcie wykonywaniua metody get().                                      // Ta opcja powinna być stosowana jeśli chcemy mieć gotowe przeskalowane obrazy natychmiast.    function get()                     // Metoda zwraca nazwę przekształconego obrazka, kórą możemy użyć jako atrybut src w tagu <img>.                                      //   function setFormat( format )       // Metoda ustawia format docelowy obrazka. Możliwe wartości: 'webp', 'jpeg'.     Przykład użycia powyższej klasy: <?php   require_once ( 'CacheImageClass.php' );   $image = new CacheImage();   $image->sourceUrl = 'assets-src/img-src-1.jpg' ;   $image->suggestedFileName = 'suggested-output-file-name-1';   $image->width = 640;   $image->height = 480;   $image->aspectRatio = 'cropping' ;   $imageUrl = $image->get();      echo ""<img src='{$imageUrl}' alt='My first resized image'>"" ;  Efekt działania powyższego przykładu można zobaczyć pod adresem: https://xksi.pl/blog/guide-images-seo/example-minimum.php Przykład z użyciem różnych kombinacji parametrów wejściowych: https://xksi.pl/blog/guide-images-seo/example-resize.php Widać obrazki się skalują zatem mechanizm działa... Na samym początku wspomniałem, że potrzebny nam będzie serwer z obsługą mod-rewrite/.htaccess i jest to niezmiernie ważna rzecz bowiem samo przygotowanie i cache'owanie miniaturek za pomocą wyżej przedstawionej biblioteki już jest jakimś progresem ale to jeszcze za mało żeby powiedzieć, że jest dobrze. Nie rzuca się to w oczy w powyższych przykładach ale warto przyjrzeć się właściwości klasy:   public $useHtacces = true ;  // true - przygotowuje tylko plik nagłówkowy obrazka(...)  Nie ma problemu by użyć powyższej klasy zmieniając tą właściwość na false. Wówczas nie będzie nam potrzebny plik .htaccess. Skoro możemy działać bez niego to dlaczego tak sprawy nie zostawić? Chodzi o to, że skalowanie obrazków jest procesem, który dość mocno obciąża zasoby serwera t.j. CPU, RAM oraz I/O i sam w sobie zajmuje trochę czasu. Wyobraźmy sobie, że na stronie mamy 100 obrazków dla których źródłem są zdjęcia z aparatu cyfrowego. W takiej sytuacji przygotowanie 100 miniaturek może zająć nawet kilkadziesiąt sekund. Dlatego przygotowując te miniaturki nasz skrypt PHP nie może czekać aż wszystkie będą przygotowane ponieważ istnieje ryzyko, że klient zamiast podstrony z obrazkami zobaczy komunikat ""408 Request Timeout"" lub inny podobny... Co po chwili zastanowienia staje się całkowicie zrozumiałe. Aby uniknąć takiej sytuacji klasa funkcja CacheImage->get() w trybie CacheImage->useHtacces = true nie przygotowuje fizycznej miniaturki a jedynie zapisuje na dysku ""plik buforowy"", w którym umieszcza informacje o miejscu obrazka źródłowego oraz parametry przekształceń, które chcemy wykonać dla obrazka docelowego. Przykład: <?php   require_once ( 'CacheImageClass.php' );   $image = new CacheImage();   $image->sourceUrl = 'assets-src/img-src-1.jpg' ;             // lokalizacja obrazka źródłowego   $image->suggestedFileName = 'suggested-output-file-name-1';     $image->width = 640;                                         // parametry przekształcenia   $image->height = 480;                                        //   $image->aspectRatio = 'cropping' ;                           //   $imageUrl = $image->get();                                   // wywołanie funkcji get() powoduje jedynie                                                                 // zapisanie pliku z serializowaną informacją                                                                // w pliku o nazwie:                                                                //   assets-cache/suggested-output-file-name-1-640-480-1.webp_buff                                                                // zmienna $imageUrl ma wartość:                                                                //   assets-cache/suggested-output-file-name-1-640-480-1.webp                                     // -- na chwilę blokujemy : echo ""<img src='{$imageUrl}' alt='My first resized image'>"" ;  Uruchomienie powyższego kodu spowoduje jedynie utworzenie pliku o nazwie:  assets-cache/suggested-output-file-name-1-640-480-1.webp_buff i następującej zawartości: a:9:{s:5:""width"";i:640;s:6:""height"";i:480;s:11:""aspectRatio"";s:8:""cropping"";s:9:""sourceUrl"";s:24:""assets-src/img-src-1.jpg"";s:8:""cacheDir"";s:13:""assets-cache/"";s:14:""defaultQuality"";i:60;s:16:""defaultExtension"";s:5:"".webp"";s:17:""suggestedFileName"";s:28:""suggested-output-file-name-1"";s:11:""imageFormat"";s:4:""webp"";}  Po deserializacji: array (   'width' => 640,   'height' => 480,   'aspectRatio' => 'cropping',   'sourceUrl' => 'assets-src/img-src-1.jpg',   'cacheDir' => 'assets-cache/',   'defaultQuality' => 60,   'defaultExtension' => '.webp',   'suggestedFileName' => 'suggested-output-file-name-1',   'imageFormat' => 'webp', )  Przygotowanie fizycznej miniatury obrazka następuje dopiero po wywołaniu obrazka przez stronę www. W tym celu możemy odkomentować w skrypcie linię: echo ""<img src='{$imageUrl}' alt='My first resized image'>"" ;  lub wywołać zdjęcie bezpośrednio przez przeglądarkę wywołując adres: http://[twoj-host]/jak-wstawic-obrazek/assets-cache/suggested-output-file-name-1-640-480-1.webp Gdyby nie fakt, że w katalogu głównym mamy plik .htaccess to serwer zwróciłby kod 404 File not found ponieważ fizycznie na dysku nie ma pliku: assets-cache/suggested-output-file-name-1-640-480-1.webp Jednak reguły mod-rewrite, które umieściliśmy w pliku .htaccess ""przechwytują"" wywołaną nazwę i wywołują skrypt PHP CacheImageGet.php (kod poniżej) z odpowiednimi parametrami: RewriteEngine On  RewriteCond %{REQUEST_FILENAME} -f RewriteRule ^assets-cache/(.*).webp$ assets-cache/$1.webp [L]  RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^assets-cache/(.*).webp$ CacheImageGet.php?imgName=assets-cache/$1&imageFormat=webp [L]  Omówmy znaczenie poszczególnych fragmentów pliku .htaccess Włączenie modułu mod-rewrite: RewriteEngine On  Sprawdzenie czy na dysku istnieje plik ze zdjęciem i jeśli istnieje to go ""wywołujemy"". Może to wydawać się masłem maślanym ale tak nie jest. Na końcu wiersze przekierowującego plik na samego siebie mamy znak sterujący [L], który odpowiada za przerwanie dalszego przetwarzania pliku .htaccess. W przypadku gdy nas plik jest mały to tą regułę można pominoąć w przypadku gdy w dalszej jego części będą realizowane dodatkowe zadania, nie związane z obrazami warto przerwać proces. RewriteCond %{REQUEST_FILENAME} -f RewriteRule ^assets-cache/(.*).webp$ assets-cache/$1.webp [L]  Najistotniejszy fragment, który odpowiada za przesłanie odpowiednich parametrów do skryptu PHP tworzącego obrazek. RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^assets-cache/(.*).webp$ CacheImageGet.php?imgName=assets-cache/$1&imageFormat=webp [L]  Powyższe przekierowanie oznacza, że jeśli plik assets-cache/suggested-output-file-name-1-640-480-1.webp fizycznie nie istnieje na dysku to zostanie wywołany skrypt PHP z parametrami CacheImageGet.php?imgName=assets-cache/assets-cache/suggested-output-file-name-1-640-480-1.webp&imageFormat=webp A w skrypcie tym znajdziemy prawie to samo co w przykładzie z tą różnicą, że:  parametry tworzonego obrazu wczytujemy z pliku buforowego, którego nazwę przekazujemy w parametrze imgName  wyłączmy tryb $image->useHtacces = false żeby obrazek utworzyć natychmiast w trakcie wykonywania skryptu, plik zawiera jeszcze prostą obsługę sytuacji, w której plik bufora nie jest znaleziony.  <?php    require_once ( 'CacheImageClass.php' );    $name = filter_input ( INPUT_GET, 'imgName' );   $imageFormat = filter_input ( INPUT_GET, 'imageFormat' );    $bufferFileName = $name.'.'.$imageFormat.'_buff' ;  // <-- tu do nazwy doklejmy _buff      if ( file_exists ( $bufferFileName ) ) {         $buffer = file_get_contents ( $bufferFileName );     $buffer = unserialize ( $buffer );          $imageFormat = $buffer [ 'imageFormat' ];     $image = new CacheImage();     $image->setFormat( $imageFormat );     $image->width = $buffer['width'];     $image->height = $buffer['height'];     $image->sourceUrl = $buffer['sourceUrl'];     $image->suggestedFileName = $buffer['suggestedFileName'];     $image->aspectRatio = $buffer['aspectRatio'];     $image->cacheDir = $buffer['cacheDir'];     $image->useHtacces = false;     $imageUrl = $image->get();            unset ( $image );     unlink ( $name.'.'.$imageFormat.'_buff' );         } else {         http_response_code(404);     $imageFormat = CI_PLACEHOLDER_FORMAT ;     $imageUrl = CI_PLACEHOLDER ;       }    // prepare headers and output   if ( $imageFormat == 'jpeg' ) Header('Content-type: image/jpeg');   if ( $imageFormat == 'webp' ) Header('Content-type: image/webp');       $secondsToCache = 3600*24*180 ; // 180 days   $ts = gmdate(""D, d M Y H:i:s"", time() + $secondsToCache)."" GMT"";   header(""Expires: $ts"");   header(""Pragma: cache"");   header(""Cache-Control: max-age={$secondsToCache}"");   readfile ( $imageUrl );   exit();  Sposobów na zarządzanie obrazkami i ich miniaturkami jest wiele jednak przedstawiona powyżej ma następujące zalety:  W bazie stałych zasobów musimy przechowywać tylko jeden oryginał zdjęcia. Możemy go trzymać w bardzo dużej rozdzielczości by w przyszłości także go wykorzystać na większych ekranach. Miniatury zostaną utworzone jedynie dla tych obrazów, które faktycznie są oglądane za pośrednictwem strony WWW. W połączeniu z mechanizmem lazy-load mamy ogromne możliwości by zaoszczędzić miejsce niezbędne na cache.  Wada wg mnie jest tylko jedna... W przypadku gdy użytkownik wchodzi na stronę, dla której miniatury jeszcze nie zostały przygotowane to będzie musiał poczekać aż te zostaną przygotowane przez serwer. Jednak przy mądrze dobranym placehold'erze i z wykorzystaniem lazy-load nie będzie to dla niego zauważalne. Dotyczy to oczywiście tylko i wyłącznie pierwszego użytkownika, który odwiedza taką podstronę. Umieszczenie zdjęcia na stronie WWW. W części powyżej omówiliśmy jeden ze sposobów przygotowania zdjęcia oraz mechanizm optymalnego serwowania ich poprzez WWW. Dotyczy to jednak pojedynczego zdjęcia nie uwzględniając tego, że chcemy zrobić serwis WWW, który jest responsywny. Załóżmy, że chcemy zrobić serwis, który ma na głównej stronie zdjęcie, które będzie rozciągnięte na cały ekran. Szybko okaże się, że przy współczesnych monitorach musimy przygotować takie zdjęcie, które będzie ładnie wyglądało w rozdzielczości 4k... ale także będziemy je serwować na ekranie małego telefonu, którego szerokość wynosi 320px - różnica jest ponad 10-krotna. Całkowicie oczywiste jest, że dla wersji mobilnej nie możemy serwować zdjęcia 4k (choć nie raz takie wyczyny widziałem). Wygląda na to, że jeśli chcemy zrobić to dobrze to musimy przygotować kilka miniaturek odpowiednio dostosowanych do różnych rozdzielności. Na szczęście mamy już bibliotekę co przygotowuje miniaturki oraz dobrych ludzi, którzy dali w HTML możliwości reagowania na rozmiar obrazu, w którym wyświetlana jest nasza strona. Zacznijmy ""na pałę"" i zbudujmy prostą stronę z dużym zdjęciem i kilkoma boksami. <?php   $view = ""<html>     <head>       <title>How NOT to serve images - guide</title>       <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=5.0, minimal-ui, user-scalable=yes'>       <link rel='stylesheet' type='text/css' href='css/style.css'>       <link rel='stylesheet' type='text/css' href='css/example-resp-1.css'>     </head>     <body>       <h1>My responsive page</h1>       <img src='assets-src/img-src-2.jpg'>       <p style='padding:20px;'>         Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.        </p>       <div class='boxes'>         <div class='box'>           <img src='assets-src/img-src-4.jpg' alt='Product 1 promotion'>           <h2>Product 1</h2>         </div>         <div class='box'>           <img src='assets-src/img-src-5.jpg' alt='Product 2 promotion'>           <h2>Product 2</h2>         </div>         <div class='box'>           <img src='assets-src/img-src-6.jpg' alt='Product 3 promotion'>           <h2>Product 3</h2>         </div>         <div class='box'>           <img src='assets-src/img-src-7.jpg' alt='Product 4 promotion'>           <h2>Product 4</h2>         </div>         <div class='box'>           <img src='assets-src/img-src-8.jpg' alt='Product 5 promotion'>           <h2>Product 5</h2>         </div>         <div class='box'>           <img src='assets-src/img-src-9.jpg' alt='Product 6 promotion'>           <h2>Product 6</h2>         </div>       </div>       <p style='padding:20px;'>         Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.        </p>     </body>   </html>"";      echo $view;  Działanie powyższego kodu pod linkiem: https://xksi.pl/blog/guide-images-seo/example-resp-1.php Kod CSS dla powyższego HTML: https://xksi.pl/blog/guide-images-seo/css/example-resp-1.css Teoretycznie strona jest gotowa i zadziała zarówno na desktopie jak i na małym telefonie komórkowym. Warto jednak zwrócić uwagę, że serwowane zdjęcie assets-src/img-src-2.jpg ma rozdzielczość 4800 x 3201px a wielkość pliku to 7,8MB - ale jest ładne ostre klientowi będzie się podobało:-) Jakie problemy wystąpią z powyższym rozwiązaniem?  PageSpeed Insights ocenia naszą stronę na ledwo 80% a my przecież mamy tu tylko jedno zdjęcie w głównym widoku... a klient chce jeszcze slider (chyba oszalał)! Zdjęcia choć na desktopie pokazuje się poprawnie to przy innych rozdzielczościach proporcje nie są zachowane co razi w oczy. Na telefonie komórkowym na sieci 3G strona ładuje się nieprzyzwoicie powoli.    Jak to wszystko naprawić? Trzeba wykonać kilka kroków...  Złapać zdjęcie w kontener żeby móc ustawić pozycjonowanie w ramach tego kontenera. Przygotować miniatury odpowiednie dla różnych rozdzielczości.  Zatem z ""grubej rury"" robimy całość tak jak ma być. Dla poprawienia czytelności docelowego kodu tworzę funkcję pomocniczą, którą umieszczam w pliku CacheImage.php: <?php   require_once ( 'CacheImageClass.php' );   function getImages( $imagesConfig, $sourceUrl, $suggestedFileName ){         $out = array();     foreach ( $imagesConfig as $key => $imgCfg ){       $image = new CacheImage() ;       $image->width = $imgCfg['width'] ;       $image->height = $imgCfg['height'] ;       $image->aspectRatio = $imgCfg['aspectRatio'] ;       $image->sourceUrl = $sourceUrl ;       $image->suggestedFileName = ""{$suggestedFileName}_{$key}"" ;       $image->getCacheFileName() ;       $out [ $key ] = $image->get() ;           }          return $out ;   }  Funkcja getImages() nie robi nic nowego ani magicznego - zajmuje się przygotowaniem wielu miniaturek na podstawie tablicy parametrów przekazanych w parametrze. Tworzę także funkcję, która będzie zwracała HTML dla jednego boksu. Warto bo to kod, który się powtarza. <?php   require_once ( 'CacheImage.php' );     function getBox ( $title, $srcImage ){         $tmpImages = getImages (       [         'a' => [ 'width'=> 480, 'height'=>320,  'aspectRatio' => 'cropping' ],         'b' => [ 'width'=> 320, 'height'=>250,  'aspectRatio' => 'cropping' ],               ],                                                                   $srcImage,       'box-'.md5( $title.$srcImage )     );          $view = ""<div class='box'>       <picture>         <source media='(max-width:1040px)' srcset='{$tmpImages['a']}'>         <img src='{$tmpImages['b']}' alt='{$title}'>       </picture>       <h2>{$title}</h2>     </div>"";     return $view;   }    // Prepare 6 boxes   $boxes = """" ;   $boxes .= getBox ( 'Produkt 1', 'assets-src/img-src-4.jpg' );   $boxes .= getBox ( 'Produkt 2', 'assets-src/img-src-5.jpg' );   $boxes .= getBox ( 'Produkt 3', 'assets-src/img-src-6.jpg' );   $boxes .= getBox ( 'Produkt 4', 'assets-src/img-src-7.jpg' );   $boxes .= getBox ( 'Produkt 5', 'assets-src/img-src-8.jpg' );   $boxes .= getBox ( 'Produkt 6', 'assets-src/img-src-9.jpg' );    // Prepare image for slider   $images = getImages (     [       'a' => [ 'width'=> 320, 'height'=>600,  'aspectRatio' => 'cropping' ],       'b' => [ 'width'=> 480, 'height'=>640,  'aspectRatio' => 'cropping' ],       'c' => [ 'width'=> 640, 'height'=>800,  'aspectRatio' => 'cropping' ],       'd' => [ 'width'=>1024, 'height'=>768,  'aspectRatio' => 'cropping' ],       'e' => [ 'width'=>1903, 'height'=>1200, 'aspectRatio' => 'cropping' ],     ],                                                                 'assets-src/img-src-2.jpg',     'slider_main_1'   );      $view = ""<html lang='pl'>     <head lang=pl>         <title>How to serve images - guide</title>         <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=5.0, minimal-ui, user-scalable=yes'>         <link rel='stylesheet' type='text/css' href='css/style.css'>         <link rel='stylesheet' type='text/css' href='css/example-resp-2.css'>     </head>     <body>       <div class='main-slider'>                       <picture>           <source media='(max-width: 320px)' srcset='{$images['a']}'>           <source media='(max-width: 480px)' srcset='{$images['b']}'>           <source media='(max-width: 640px)' srcset='{$images['c']}'>           <source media='(max-width:1024px)' srcset='{$images['d']}'>                 <img src='{$images['e']}' alt='My responsive image.'>         </picture>                  <h1>My responsive page</h1>                </div>        <p style='padding:20px;'>         Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.        </p>              <div class='boxes'>         {$boxes}       </div>        <p style='padding:20px;'>         Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.          Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content. Some content.        </p>            </body>   </html>"";      echo $view;  Działanie powyższego kodu pod linkiem: https://xksi.pl/blog/guide-images-seo/example-resp-2.php Kod CSS dla powyższego HTML: https://xksi.pl/blog/guide-images-seo/css/example-resp-2.css Co się stało?  Obrazek IMG został zastąpiony tagiem PICTURE, który ma między innymi tą super właściwość, że w zależności od rozdzielczości ekranu dociągnie z serwera odpowiedni wskazany dla niej obrazek. IMG wraz z PICTURE zostały złapane w kontener <div class='main-slider'> co pozwana na takie osadzenie obrazka, że nie będą psute jego proporcje podczas skalowania. Obrazki mimo źródeł w JPG są serwowane jako WEBP. Wynik w pageSpeed Insight jest zadowalający.    Podsumowanie Kody źródłowe wykorzystane w powyższych przykładach dostępne są w repozytorium GIT: https://bitbucket.org/xksi/blog-images-php/src/master/ Warto zwrócić też uwagę na nagłówki HTTP odpowiadające za cache-control... ale to szerszy temat więc nie będę go tu zgłębiał. Jeśli się spodobało to opracuję kolejne tematy. W kolejnym kroku aż prosi się omówić lazy-load oraz przerobić wielkie główne zdjęcie na wielki slider wciąż nie tracąc punktacji 100/100/100 :-) Ciekawostki Na koniec dodam, że jeśli nie chcemy samodzielnie walczyć z wiatrakami to dostępne są w sieci różne Media API, które będą wspierać nas w takich obszarach jak:  Tworzenie optymalnych miniaturek. Automatyczne kadrowanie zdjęć z uwzględnieniem wyboru kluczowych miejsc ze zdjęcia np. poprzez wykrywanie twarzy albo istotnych obiektów. Zwykle są to algorytmy działające w oparciu o sztuczną inteligencję. Serwowanie zdjęć z chmury itd ...  Jednym z takich rozwiązań jest np.: https://cloudinary.com/ albo więcej można znaleźć np. pod adresem: https://www.g2.com/products/cloudinary/competitors/alternatives   screenshot-20220603123813.png (156 KB) - ściągnięć: 4 screenshot-20220603123818.png (453 KB) - ściągnięć: 3 screenshot-20220603123955.png (147 KB) - ściągnięć: 3 screenshot-20220603124000.png (282 KB) - ściągnięć: 3 screenshot-20220603124841.png (174 KB) - ściągnięć: 4 screenshot-20220603124848.png (436 KB) - ściągnięć: 3;"
"Jako student mogę dorzucić swoje 3 grosze. Podstawy programowania i baz danych poznasz, lepiej lub gorzej - zależy na jakiego prowadzącego trafisz, ale object-oriented programming i relacyjne bazy danych ogarniesz, jeśli chociaż trochę się przyłożysz. Jest też inżynieria oprogramowania - projektowanie systemu, diagramy UML(tak, to się przydaje), algorytmy i struktury danych oraz na niezłym poziomie matematyka(uczą jej ekonomiści, więc tutaj jest całkiem nieźle) - dyskretna, algebra liniowa, analiza matematyczna. Gorzej wygląda specjalizacja gry i aplikacje mobilne - tutaj technologie są przestarzałe, np. Flash czy Adobe Director(podobno już zastąpiony jakimś frameworkiem JS), a sporo jest rzeczy growych - Unity, grafika 3d, projektowanie interfejsów, tworzyliśmy własną czcionkę i księgę identyfikacji wizualnej - rzeczy generalnie niepotrzebne, jeśli chcesz programować aplikacje, a nie gry. Polecam za to bazy danych - z opinii znajomych są dużo bardziej konkretne i prowadzący są na lepszym poziomie, a przecież programiście ta wiedza będzie bardziej przydatna niż modelowanie 3d. Są irytujące i niepotrzebne przedmioty, część mogłaby być lepiej prowadzona, ale generalnie uczelnia jest luźna, jak masz trochę motywacji to sporo się nauczysz, i będziesz miał sporo czasu na rozwój we własnym zakresie. Z mojego roku większość osób, która faktycznie chciała zostać programistami i robiła coś w tym kierunku, znalazła staż/pracę już po 2 roku, choć znajdą się też tacy, którzy nie robią i nie potrafią nic, a jakoś zdają. Nie wiem jak jest z renomą uczelni - pewnie słabo, ale pracę jako programista znajdziesz i renomę wyrobisz sobie swoją - doświadczeniem i githubem.;"
"@mr_jaro: Pytanie było ""jak zrobić najłatwiej"" - najłatwiej skorzystać z gotowych/sprawdzonych rozwiązań. Nie było pytania w stylu: chcę to napisać sam od 0 na jakimś frameworku. Nie było kwestii nauki programowania od samych podstaw. Nie wiemy nawet jaką wiedzą dysponuje autor, na jakim poziomie ogarnia PHP, MySQL, inne rzeczy - była kwestia jak zrobić najłatwiej. Nie znamy rozmiaru apki, nie wiemy do czego ma docelowo służyć - czy to własny projekt do nauki czy jakiś docelowy do rozwoju. Czy będzie tam 10 userów czy 100 tys. Ok - widzę, że autor ma rejestrację, logowanie i stronę główną. Czyli, że zaczął kodować sam. Ale być może będzie skłonny skorzystać z innych opcji jednak, może nie jest świadomy, że to co robi można zastąpić czymś co już istnieje. Zaproponowałem więc rozwiązanie ""najłatwiej"" w zależności od umiejętności autora i jego preferencji nazwijmy to rozwoju zawodowego. A nie rozwiązanie najbardziej pasujące do programowania od podstaw. Wordpress nie jest taki zły jak go opisujesz - wiadomo, do dużych systemów nie jest zbyt elastyczny, nie był do tego tworzony. Ale to wina autora Twojego projektu, który być może błędnie założył, że WP udźwignie ogrom danych przetwarzanych na stronie. A może nie spodziewał się, że będzie zarządzał takimi ilościami danych. Albo poszedł po kosztach czy krótkim czasie realizacji. Dlaczego - nie umiem powiedzieć. WP jak ktoś dobrze zna i wie jak z niego korzystać to tak go skonfiguruje, że będzie hulał aż miło. Gdyby był taki straszny i nie dobry, ludzie nie używaliby go i nie rozwijali. Na proste strony, nawet lekko zaawansowane nie jest taki zły. Na podstawową naukę CMSa, w sam raz. Reasumując: nie musisz od raz jechać po wszystkich, że jesteśmy debilami bo proponujemy WP albo Drupala, a pisanie od 0 wszystkiego we Frameworku jest super. Jak masz wątpliwości co do mojej propozycji wystarczy normalnie jak człowiek napisać, uzasadnić i nie rzucać mięsem. Autor zadecyduje jak chciałby to zakodować - czy chce zrobić to na szybko wykorzystując gotowe systemy bo mu zależy na czasie czy woli sobie pokodować i wszystko od zera napisać sam. Chcemy pomóc autorowi, przestawić kilka opcji a nie jechać po sobie, bo nasze racje są najważniejsze. Przemyśl to.;"
"Praca nie przychodzi na tacy, tylko trzeba ją znaleźć. A akurat programista ma ten przywilej, że ma w czym wybierać w tym rolniczym kraju. Gdzie szukałeś? Poza serwisem 4programmers istnieją też inne - praca, pracuj, infopraca, nofluffjobs. Ja wyszukałem znacznie więcej niż 4 i zajęło mi to poniżej minuty. Do tego masz profil na LinkedIn? Tam średnio 2-3 rekruterów odzywa się każdego tygodnia. Do tego, jak gdzieś w ofercie nie ma słowa ""junior"", to świat się jeszcze nie kończy. Wymagany rok doświadczenia można spokojnie zastąpić jakimś własnym małym projekcikiem. Wg mnie jest to nawet cenniejsze, bo pokazuje to, że ktoś był na tyle cierpliwy, by się nauczyć, jak wszystko pospinać do kupy i ma podstawową wiedzę zarówno z backendu, jaki frontendu plus umie to konfigurować. A rok w badziewnej firmie to można zmarnować na poprawianie literówek w formularzach. Wymagane doświadczenie to tylko taki straszak na niepewnych siebie. Jak na rozmowie zobaczą, że masz pojęcie o programowaniu i rokujesz, to dostaniesz pracę na juniora z pocałowanie ręki. Ja chodziłem na oferty 5lat doświadczenia mając 2 i dostawałem to, na co aplikowałem, albo ewentualnie na stanowisko niżej, jeśli rekruter uznał, że czegoś mi brakowało. Poszukiwania pierwszej pracy akurat dobrze pamiętam. Miałem papier z polibudy plus pół roku własnej nauki webówki w Javie. Znałem dobrze standard języka Java plus podstawy frameworków Spring (Wiedziałem co to są beany, autobinding, dependency injection, mvc) i Hibernate (umiałem zrobić mapowanie 1:n). Do tego miałem podstawowe pojęcie o wybranych wzorcach projektowych, bazach danych i architekturze wielowarstwowej. Z taką wiedzą umiałem zrobić prostą apkę webową typu CRUD, podzielić kod na kontroler, serwisy i DAO, podpiąć do serwera MySQL i uruchomić na serwerze Tomcat. Polazłem na 4 rozmowy, i uwaga, na wszystkie dostałem pozytywna odpowiedź. Firma A zaproponowała B2B 40zł/h netto, firma B B2B 35zł/h netto, firma C 3500 brutto na umowę o pracę i firma D 6500brutto na umowę o pracę. Co ciekawe, do firmy D wepchałem się nieco na siłę - na wstępie powiedziano mi, że szukają osób doświadczonych, ale jak chcę spróbować, to zapraszają. Powyższe to historia z Wrocławia, ale Kraków to ta sama bajka wg mnie. Trzeba szukać, aż się znajdzie i nie przeżywać każdego słowa w ofercie pracy.;"
"Co to znaczy sensowną grę? Zdajesz sobie sprawę z tego że 30 lat temu sensowna gra to byl arkanoid? A 20 lat temu Wolf3d? A dziś jakimś darmowym fps makerem mógłbyś zrobić dużo lepszą grę w ciągu kilku godzin, może dni?  Masz chyba problemy z czytaniem... Gry wyklikać się da, ale nikt poważnie tego nie traktuje bo to co możesz wyklikać jest po prostu nieporównywalnie słabsze od tego co jest ""na rynku"". W efekcie po co ktos miałby marnować czas na klikanie w jakimś rpg makerze skoro to co mu wyjdzie będzie na poziomie gier które mają po 15-20 lat? Widzę że nie zrozumiałeś nic z mojego postu. Napisze więc bardziej dosadnie: komputery nie potrafią myśleć i nie potrafią ""wymyślać"" niczego. Komputery radzą sobie nieźle z wykonywaniem prostych, powtarzalnych, bardzo wąskich zadań. Zresztą komputery bardzo słabo radzą sobie z przetwarzaniem wiedzy i z reprezentacją wiedzy. Jeśli wstukasz do CADa jakąś konstrukcje to on potrafi policzyć jak będzie się ona zachowywać w różnych sytuacjach. Ale nie potrafi wskazać ci ""najlepszej"" konstrukcji dla zadanych parametrów, bo musiałby iterować po wszystkich możliwych konstrukcjach i każdą z osobna sprawdzać. Dzieje się tak z podobnych powodów z których komputery przez długi czas nie radziły sobie w szachach a potem w go - bo dla komputera wszystkie możliwości są równie prawdopodobne. Są bardzo wąskie dziedziny (np. rzeczone szachy) gdzie udało się jako-tako stworzyć reprezentacje wiedzy dla komputera (m.in. w postaci historycznych zagrywek), ale to są wyjątki. Nie ma ogólnej reprezentacji z której komputery potrafiłyby korzystać. W związku z tym komputery nie ""zastąpią"" ludzi, tak jak nowoczesne IDE i frameworki RAD nie zastąpiły programistów. Pozwolą jedynie na szybsze tworzenie bardziej zaawansowanych rzeczy. Jeśli chodzi o muzykę to przecież są takie narzędzia wspomagające jak http://pl.wikipedia.org/wiki/FL_Studio Ale tak jak mówiłem - one nie tworzą nic same z siebie, tylko pozwalają komuś skomponować piosenkę w dzień zamiast tygodnia ;) Tak samo jeśli chodzi o grafikę 3d, masz takiego cuda jak http://pl.wikipedia.org/wiki/Houdini_(program) Znów nic się ""samo nie tworzy"", ale możesz do jakiegoś modelu kilkoma kliknięciami dodać różne transformacje i efekty, dzięki czemu stworzysz animację w ciągu tygodnia a nie w ciągu miesiąca.;"
"Kilka prostych faktów. Mając 30 lat macie przed sobą jeszcze 35-40 lat pracy. Kilka ciekawych dat:  Pierwszy na świecie satelita telekomunikacyjny poleciał ~50 lat temu. Od tego czasu mamy takich setki i całą ogromną gałąź przemysłu z tym związanego. Komputery osobiste rozpoczęły swoją ekspansje ~30 lat temu. Równie dobrze za 30 lat może ich nie być i mogą być zastąpione przez cos zupełnie nowego. Raptem 20 lat temu powstało i zaczęło zdobywać popularność WWW, a dziś większość firm nie wyobraża sobie ""nie być w internecie"". Jeszcze 10 lat temu telefon komórkowy służył tylko do dzwonienia albo smsowania, jeszcze 15 lat temu mało kto w ogóle taki telefon posiadał. Dziś mają je kilkuletnie dzieci a na nich tysiące aplikacji.  Rozwój technologii następuje szybko i jest trudny do przewidzenia. Większość ludzi musi się zadaptować z czasem. Dzis technologia X jest na topie a jutro nikt nie będzie juz o niej pamiętał. Perspektywa 30 czy 40 lat to jest bardzo, bardzo dużo! A wy sie martwicie że ktoś zaczął programować kilka lat przed wami ;] @Darck bzdura. W polsce jest dużo absolwentów informatyki, ale ""specjalistów"" jest bardzo bardzo mało. Zresztą deficyt programistów widać w każdym miejscu na świecie, także tam gdzie nikt nie outsourcuje bo sie nie opłaca, jak niemcy czy usa. Wynika to z tego że to jest branża gdzie nie ma twardego limitu na podaż pracowników. To nie jest taśmociąg przy którym może pracować X osób i każda dodatkowa osoba nie będzie miała miejsca. 10 lat temu nie istniały smartfony a dziś rynek mobile jest gigantycznym rynkiem. Informatyzacja generuje miejsca pracy a nie je zabiera...;"
"Tak też ludzie myśleli 40 lat temu jak wymyślono sieci neuronowe. I minęło te 40 lat a sieci neuronowe nie dość że wcale nie rozwinęły się tak jak planowano, to jeszcze w wielu miejscach zostały zastąpione przez inne, czytelniejsze rozwiązania (sieci bayesa, drzewa decyzyjne, reguły asocjacyjne i wiele innych). Niestety ale komputery nadal doskonale radzą sobie z szybkim wykonywaniem prostych, powtarzalnych operacji i w zadaniach ściśle ""specjalizowanych"" ale zupełnie nie radzą sobie w zadaniach ogólnych, abstrakcyjnych i wymagających ""kojarzenia"". Zamiast wymyślać koło na nowo wpisz w google ""reprezentacja wiedzy"" i czytaj.;"
"goto, longjmp - zwykle zbędne, ale raz na ruski rok niezastąpione. najczęściej jest tak, że jeżeli potrzebne to znaczy, że kod nieprzemyślany.;"
"A masz jakieś większe pojęcie o programowaniu ? Bo napisałeś w następujący sposób...  Kurs ? Papierek praktycznie nic Ci nie da w przypadku programowania. O niebo lepsze są studia. Nie ze względu na papierki, ale na kontakt z ludźmi o podobnych zainteresowaniach. Tych ludzi nie będzie dużo, bo wiadomo czym zajmuje się ~90% studentów, ale zawsze się znajdą koledzy/koleżanki do współpracy w kole, etc. I tak najważniejsza jest samodzielna nauka.  To słabo szukałeś, ale nie trać na to czasu. Jeśli chcesz ""kurs"", to poszukaj jakichś darmowych. Choć to i tak nie zastąpi dobrej literatury.  Taaa... Visual C++ to nie język.  Nie ma takich kursów. Kolejny kwiatek - ""symfonia c++"", to nie język, tylko książka. Podsumowując - jak chcesz ""kursów"", to lepiej idź na studia informatyczne i w międzyczasie możesz szukać jakichś zleceń. Jeśli nie, to inwestuj w książki i się z nich ucz, programuj, bierz udział w dyskusjach na forach programistycznych, czytaj blogi specjalistyczne, etc. Życzę powodzenia :);"
"Jako że mój post zaginął w feworze dyskusji o zarobkach 2500 mając pare lat doświadczenia, wkleję go ponownie, ponieważ chciałbym poznać zdanie innych osób na ten temat: Dużo osób mówi o szantażu (czy też nie szantażu, nieważne jak to nazwiemy), żeby wymagać/oczekiwać podwyżki i dać do zrozumienia (powiedzieć wprost), że ma się lepszą ofertę z innej firmy. A nie zdarza się tak, że manager/czyKtoTamRządzi zgodzi się na podwyżkę tylko dlatego by nie stracić osoby w środku projektu i nie będzie od razu szukał nowej osoby by zastąpić pracownika, który zarabia za dużo w porównaniu do reszty (i szantażuje firmę / błyskawicznie odejdzie jak dostanie dobrą ofertę z jakiegoś banku, nie to co inni ""przyzwyczajeni"" do miejsca pracy)? No chyba że ta ""oferta porównawcza"", którą dostaliśmy od innej firmy, jest ""co najwyżej dobra"", wtedy dużo nie stracimy, gdy dostaniemy wypowiedzenie po 2-4 miesiącach. Problem pojawiłby się, gdybyśmy dostali ofertę z firmy, która bardzo nam dopowiada. Wtedy chyba lepiej po prostu się zwolnić, niż ryzykować bycie zwolnionym po paru miesiącach i ""przepadek"" dobrej oferty (jeżeli faktycznie jest wyjątkowa na rynek / na skill osoby). Ktoś w ogóle został zatrzymany przez firmę w takiej sytuacji podwyżką i zwolniony gdy skończył ""swoją część"" systemu / zrefaktorował system / przekazał w jakiś sposób wiedzę (a raczej wystarczającą jej część) etc? Oczywiście nie mówię o Seniorach z głęboką wiedzą o systemie (którą zawsze można (a nawet powinno się) jakoś transferować) czy o Leadach, którzy faktycznie mogą nie zostać wyrzuceni przez firmę, nawet gdy są sporo overpaid w porównaniu do rynku. Najbezpieczniej wydaje się po prostu porównać wynagrodzenia jakie dostalibyśmy w innych firmach i iść po podwyżkę bez szantażu ale z zaznaczeniem, że inna firma proponuje dużo wyższe wynagrodzenie i czujemy się niedoceniani przez firmę i w ogóle nam smutno z tego powodu (nie znaczy to, że już się pakujesz, ale że masz rozterki i może lepiej Ci dać podwyżkę, żeby nie mieć potem problemu) :P. Jeżeli firma się nie zgodzi (albo podwyżka jest mniejsza niż chcemy), przyjmujemy ofertę innej firmy i nie przyjmujemy kontrpropozycji (jaka by ona nie była).;"
"Decydującymi czynnikami są: inteligencja - 50%, pracowitość - 25 % i wiedza - 25%. W niektórych wypadkach inteligencję można zastąpić doświadczeniem. Jeśli absolwenci kierunków innych niż informatyczne sami nauczyli się programować, to świadczy o ich inteligencji i pracowitości. Podobnie sprawa ma się z zadaniami domowymi. Masz do wyboru dwie osoby, więc chłopaki spoza infy pasują jak ulał. Poza tym sam piszesz, że wydają się lepsi. Poleć im lektury uzupełniające braki i wszyscy będziecie szczęśliwi.;"
"heh, dzieki za linki, wlasnie po napisaniu tego postu znalazlem je w internecie :) na pewno sie przydadza, szczegolnie gdy bede obmyslal sztuczna inteligencje komputera. ale na razie stworze 1 czesc gry - tryb gracz vs gracz. chwilke temu akurat rozpisalem sobie wszystkie mozliwosci w ktorych moze byc obok siebie 5 kolek czy krzyzykow. martwi mnie ilosc if-ow, ktore bede musial zastosowac w metodzie, do ktorej bedzie odnosila sie reszta programu... czy mozna to jakos zastapic jeśli zbiore jakies pomysly na temat projektu, tzn, gdy utworze jakies AI, to zloze to jako propozycje tematu zaliczeniowego na koniec roku. wydaje mi sie ze to dobry pomysl. a Wy co sadzicie?;"
"Szybki, wystarczyło potwierdzić wypowiedź Deti... Szanowny kolega w dalszym ciągu nie rozumie podstaw :( a co gorsza nie potrafi precyzować pytań :/. Powiem szczerze, że trochę się gubię czytając jego odpowiedzi... Najgorsze jest to, że kolega nie potrafi lub nie chce czytać ze zrozumieniem :( natomiast najbardziej boli, że wszystko chce dostać na tacy - praktycznie bez własnego zaangażowania... Nie jestem matematykiem (ani informatykiem) ale jeśli chodzi o Twoją wypowiedź to niezabardzo mi się podoba wypowiedź odnośnie czystej matematyki (lub po prostu źle ją zrozumiałem)... Sieci neuronowe nigdy nie zastąpią konwencjonalnej matematyki i polegną w najprostrzych algorytmach (tam gdzie liczy się dokładność obliczeń). Nie wiem jakie Ty robiłeś badania ale zaletą sieci jest to, że potrafiają uogólniać pewne procesy a co najważniejsze ich wyniki często są bardzo bliskie rozwiązaniu. Jednak bardzo rzadko będzie to 100% dokładność! Dla przykładu Tadeusiewicz podaje prosty przykład z którym sieć sobie nie poradzi: ""Ale jesli podac sieci serie liczb całkowitych i zazadac, zeby siec odgadła, czy nastepna liczba jest liczba pierwsza to ona sobie z tym nie poradzi. Chocby uczyc siec na okragło to ona nigdy nie na nauczy sie rozwiazywac tego typu problemów"". Tak samo jest z najprostrzym dodawaniem czy mnożeniem - wyniki sieci mogą być bardzo bliskie wyniku ale praktycznie nigdy nie będzie to 100% dokładność (chyba, że dla pojedyńczych równań). Jeśli chodzi o naukę sieci to było już chyba 5 razy mówione, że wstępny wybór jest losowy natomiast później uczy się sieć iteracjami - przez minimalizację funkcji błędu!!! I teraz chciałbym zacytować to co Ty Szybki zacytowałeś tylko w innym kontekście: jak wszystkie wagi dobierane są na wstępie losowo, TO JAKIM CUDEM neurony ""będą dawały takie same wartości na wyjściach""?!? ZACZNIJ CZYTAĆ CZŁOWIEKU ZE ZROZUMIENIEM!!! i zajżyj w końcu do książki a nie wszystkie informacje ściągasz z netu - byle szybciej... Looknij na obrazek jakie procesy zachodzą w sieci a może w końcu dojdzie do Ciebie co tam w środku się dzieje... Szybki pytałeś się, czy on potrafi rozwiązywac równania rózniczkowe i wie co to minimum lokalne - od początku mu proponuję żęby policzył pochodną to może dowie się w SPACJA końcu czym jest te tajemnicze ""(ti-yi)"" o które się pyta ale jak on chce wszystko na tacy to niech sobie jeszcze trochę poczeka... Analizując powyższe - nie, on nie umie rozwiązywać równań różniczkowych! Męczą mnie tacy ludzie, którzy potrafią tylko brać, ale od siebie nic nie wnoszą!!! Natomiast jeśli chodzi o ""gotowy wzór"" na wagi to bym tu polemizował (tak na boku ofc). W sumie wagi w sieci typu RBF można obliczyć rozwiązując układ równań tylko tam problem jest z doborem parametrów i centrów (odpowiedników wag w neuronach) ale... tu też nie jest tak łatwo! Pozdrawiam! Oczywiście chodziło mi o ten cytat:  A jeśli chodzi o bias (polaryzację) to służy ona do tego, że jak by wszystkie neurony dały wartość = 0, to żeby sieć mimo wszystko coś ""wypluła"" (w modelach ekonometrycznych tłumaczy się to mniej więcej tak, że jak wszystkie zmienne (w uproszczeniu odpowiedniki neuronów) dadzą wartość 0 to wynik = właśnie ten  bias (beta)) Dla przykładu gdy staramy się odgadnąć jaki wzrost będzie miał dany osobnik w zależności od zmiennych objaśniających, to gdy wszystkie zmienne przyjmą zero to należy się spodziewać, że ta osoba będzie wzrostu równym temu parametrowi wolnemu (biasowi/becie);"
"Pogrubiony kluczowy fragment. W USA jedną z przyczyn stopniowego grzęźnięcia liberalnego systemu ubezpieczeń zdrowotnych (poza brakiem miliarda regulacji prawnych, które jednak byłyby wbrew liberalnej wolności) był fakt, że po prostu ubezpieczało się zbyt mało ludzi. Jaka miałaby być gwarancja, że tu będzie ich więcej? Oczywiście żadna. Żeby ubezpieczycielowi się opłacało - trzeba było podbijać ceny. Ale drożej = stać jeszcze mniej. I błędne koło się zamyka. W samochodach sytuacja jest inna, bo inna jest świadomość ludzi, wypadki są częste, ubezpieczenie mieć trzeba. Na zdrowie - nie trzeba.  To był tylko przykład jak bardzo oderwane od rzeczywistości hasła rzuca. Reforma armii, czy sądownictwa, wspomniane przeze mnie są w jego postulatach, wypisane na jego stronie i są kompletnie nierealne do przeprowadzenia z poziomu prezydenta.  Nie wiem jaki związek ma powstanie Empire State Building z liberalizmem - jakbyś historii nieco znał, to byś wiedział, że jeszcze zanim go wybudowano, w 1929 roku USA popadło w katastrofalny kryzys (Produkcja w USA zmalała o 50%; w 1932 bezrobocie osiągnęło 25%; co czwarty farmer stracił ziemię na skutek zadłużenia. - wiki). Jeśli liberalizm był taki wspaniały, to czemu padł? Ludzie mieli się stawać mądrzejsi, a co wyszło - 25% bezrobocia. No to faktycznie mądrość ich ogarnęła. Żeby było śmieszniej, to akurat właśnie po tzw. New Deal przypada rozkwit śmiałych projektów w USA, jak przykładowo most Golden Gate. Akurat budownictwo ma się nijak do ustroju. W przyczynach kryzysu, poza tym, o czym już pisałem, upatruję jeszcze jedną rzecz - chciwość. Ludzie mądrzy stawali się ""mądrzejsi"", stawali się kombinatorami. Ich bogaceniu nie było granic. Niestety jeśli pieniądze są gromadzone i nie krążą, to gospodarka pada. Ale to tylko jedna z wielu przyczyn.  Gdyby tych nierobów i biedaków było mało, to by nie było problemu. Przecież nie mieliby wtedy siły, żeby się przebić. Liberalizm w swojej wspaniałości powinien przecież sprawiać, że ludzie stają się mądrzejsi, dążą do bycia mądrymi, bo to się opłaca, więc nie powinno być żadnych kryzysów, protestów, ani niczego - czyż nie? Liberalizm powinien trwać wiecznie jako ustruj doskonały zgodnie z tym co piszecie. Ale jednak tak nie było - bo się okazało, że system się nie sprawdził, zakrztusił się sam sobą. Tylko jak widać ludzie nie wyciągają żadnych wniosków z historii.  Jak wyżej - przecież głupich być nie powinno? Skąd się wzięli? Czyżby liberalizm czegoś nie przewidział? Przecież mieli zmądrzeć... Ale powiem tak: zapewne to kiedyś nastąpi, bo żaden system nie jest idealny i ten też wcześniej, czy później padnie - to oczywiste. Może zastąpi go liberalizm, ale tak jak poprzednio upadnie on sam - bo w liberaliźmie obywatele stopniowo sami sobie krzywdę robią.  Szkoda, że umiejętność czytania ze zrozumieniem stopniowo wymiera. Gdybyś przeczytał uważnie moją wypowiedź zauważyłbyś, że założyłem sytuację w której dochodzi do oszustwa. Świat nie jest taki piękny, że możesz się umówić lub nie - jest trzeci przypadek. Taki brak myślenia abstrakcyjnego i analizowania różnych scenariuszy jest jedną z przyczyn sypania się liberalizmu będącego w użyciu.  Co miałeś z historii w szkole? Albo może jeszcze do tego etapu nie doszliście? Kojarzysz Bolesława Krzywoustego, jego testament, który spowodował rozbicie dzielnicowe Polski? Wszytko jest w monarchii ""super"" (nie licząc możliwości honorowania przywilejami określonych grup w zamian za pieniądze - przywileje szlacheckie - także słabość - monarchia jest de facto korupcjogenna), póki król jest silny. Ale jak nie jest lub podejmie jedną głupią decyzję, to jest w stanie uwalić cały kraj. Były też przykłady jak polscy królowie stawali się pionkami, uciekali, okresy bezkrólewia... Liberałowie mają cudowną zdolność do wybiórczego pamiętania historii. Komunizm pamiętają świetnie, ale ile razy zawodził system monarchii - to już nie. Teraz przynajmniej prezydent sam państwa nie rozwali - jeden człowiek nie jest w stanie jedną decyzją zniszczyć kraju. A już ten tekst na koniec z inteligencją króla to kwintesencja bezmyślności. Skąd to wiesz, że on inteligentny będzie?! Ilu głupich w historii Polski było?! Tylko żeby to wiedzieć to jeszcze historię Polski trzeba znać.  Cała demagogia opiera się na ""myślę"", ""wydaje mi się"" - mało przekonywujące - to raz. Dwa - 1 000 $? I tak za dużo. Ile osób byłoby na to stać? A teraz NFZ przyszyje.  Dowcip miesiąca. Jako wytwórca produktu/usługi z pewnością będziesz wysoce zainteresowany chwalić się jego wadami :-D  Czyli? Ciekawe teorie, bo jakoś jak idę do sklepu kupić mleko, to ja ustalam zasady, że potrzebuję mleko, a państwo na to leje gęstym sikiem :-D Mogę sobie równie dobrze zamiast mleka kupić piwo - państwo ma to nadal w równie głębokim poważaniu, co najwyżej nie będę miał mleka.;"
"1.Mam TLabel zapełnione dość dużą ilością tekstu chce napisac cos co zastąpi daną fraze na coś innego np jesli program znajdzie ciąg znaków tytul to niech pobierze ciąg znakow az do tytulend i skasuje z całego ciąu znakow wszystko od tytul do tytulend włącznie 2.To czy podczas trwania programu mogę dodać bądź skopiować zawarty w nim ""obiekt"" (komponent delphi) jako drugi niezalezny od pierwszego komponent? dajmy na to ze mam Label1 i podczas programu i chce aby program utworzyl na formie dajmy na to Label'e z numerami od 2-100 i kazdemu przypisal co innego do parametru Caption? Jeśli się do to w jaki sposob;"
"Uczenie wlasnie <ort>oprzeć</ort> na obrazach... Tzn dac do pamieci kilka krzesel (obrazkow z krzeslami) i ort! ort! tych obrazkow doporowadzic do stanu gdzie bot bedzie wstanie wylowic krzeslo z tla. Potem w pamieci zostalo by stworzone wirtualne krzeslo i sprawdzenie jakie podstawowe prawia ort! dzialaja. (tzn dzieki 4 noga moze stac ort! sie, da sie je przesuwac itd...). Potem wyniki zostana zapisane (taka symulacja troche obciaza wiec by ort! tego robic caly czas ale ort! z wczesniejszych wynikow jezeli znowu bedzie chodzic o ort!). Ok to jak graficznie jest wstanie rozpoznwac kszesla to juz polowa sukcesu jak ktos wypowie krzeslo to bedzie wiedziec jaki ma ksztalt i jak ort!. Wazna ort! by bylo by ort! podstawowe ort! czlowieka (obrazowo) np jak ort! ort! czlowiek jak siedzacy na... [krzesle]. I teraz np bot zobaczyl ort! (<ort>mógłby</ort> samemu ort! internet) z czlowiekiem na ort!. Mialby dane o krzesle i o czlowieku(minimum danych tzn gdzie czlowiekowi sie co zgina i ort! ort! co sluzy). Teraz <ort>mógłby</ort> powiazac krzeslo z cialem czlowieka i np z odpoczynkiem. I ort! powiazac slowa ort! obrazami. Czyli ktos pwoeidzial ort! na krzesle. Wywowal by sie<ort> obras</ort> siadania i krzesla ort! (dodatkowo obraz clzowieka siedzacego na ort!).<ort> Niewdajac </ort>sie w ort! opierajac sie na podstawach <ort>anatomi </ort>czlowieka bot <ort>opracowal by </ort>co bylo pomiedzy 2 obrazami (stojacy clzowiek ort! ort! i siedzacy ort!). Taka metoda dzialania bot by nawet skapowaal zdanie Gdy ort! na krzesle ort! sie i wszystko <ort>wywrucilem;]</ort> Calosc najlepiej zrobic w sieciach neuronowych ale po kilku<ort> prubach</ort> obcizajacych starszelknie system mozna by czesc sieci neuronowej zastapic odzielnym ukladem elektronicznym. Dzieki temu moglo by to w miare pl;yuwnie chodzic w zalozeniu 1 komp 1 bot;]]]]] Ale zamotalem;]] Ale mam nadzieje ze zrozumieliscie ort! mi chodzilo;]ort! //Czy ty jestes debilem?? - lofix;"
"IMHO, pewnie zobaczyl 10, poniewaz kompilator ma prawo sobie zmienne w ramce funkcji poukladac dokladnie dowolnie.. jego kompilator mogl umiescic ""int i"" na koncu  Nie wiem czemu, ale sadzac po ciaglych sformulowaniach typu ""błędne"" oraz sugerowaniu (nie wiem, czy akurat mi, czy ogolnie czytelnikom forum?) poczytania standardu, mam coraz wieksze wrazenie ze sie nie rozumiemy, albo probujesz na sile sie do czegos przyczepic poprzez sztuczna restrykcyjnosc co do nazwenictwa i logicznej budowy wypowiedzi.. Napisalem tak jak napisalem, poniewaz zakladam ze czytajacy ZNA roznice miedzy inicjalizacja a przypisanie i widzac ""bum=ble"" wie, ze zaleznie od kontekstu, mozna to rozumiec dwojako. Tym ktorym nie widza roznicy, napisalem gwiazdke, poniewaz zakladalem ze zaraz ktos przyleci i zacznie marudzic ze ""to nie jest inicjalizacja"".. Sadzilem ze opis w gwiazdce rozwieje watpliwosci, co moze byc inicjalizacja, a co nia by byc nie moglo.. Jesli czepiamy sie szczegolow, to nie jest prawidlowy kod C/C++ poniewaz nie jest zamkniety w zadnej funkcji. Jezeli czepiamy sie szczegolow - nigdzie nie napisalem ze w tym wycinku kodu, X jest zmienna typu INT, ani nawet nie napisalem ze jest to cala linijka.. cala linka mogla brzmiec ""moj_ulubiony_intByCtorConvertible_typ_danych<od_bum, ble, ivector<bam>> x = 5;"", to, tylko ucialem 80% linijki dla pogladowosci zapisu.. Jesli czepiamy sie szczegolow, to ja na przyklad moge teraz sie dla kontry zaczac upierac ze ""inicjalizacja"" explicite powinna miec postac konstrukcji i wygladac na przyklad tak: int x(5); miast int x = 5, poniewaz wtedy wszystko jest 100% jasne nawet dla poczatkujacego, a w tym typowym przypadku numer dwa, to jedynie ""inteligentny"" kompilator ""po prostu"" wie, ze to jest teraz pierwsze przypisanie i je ""optymalizuje"":) ( <-- zdanie poprzedzajace jest napisane rownie mało formalnie jak wszystko poprzednie i piszac je, zakladam ze rozmawiam z osoba ktora C++ zna na poziomie wystarczajaco dobrym, zeby zauwazyc ze ma ono forme zdawkowa:) ). Czepiajac sie w ten sposob szczegolow dalej, przy kodzie brzmiacym: int x; // A blahblah-nie-uzywajace-x blahblah-nie-uzywajace-x x = 5;  // B blahblah-uzywajace-x cout << x  kompilator przy wlaczonych optymalizacjach, przy pewnych spelnionych warunkach (np. ze blahblah-nie-uzywa-x faktycznie NIE uzywa X), ma prawo przestawic sobie wiersze kodu B blizej A, ba, moze zlepic sobie linie A i B tworzac ""inicjalizacje"" zamiast przypisania. Itp itd. Dlatego w opisie skrotowym szczegoly kompletnie olałem i umieściłem gwiazdkę, wyjaśniającą różnicę między inicjalizacją-składniową a inicjalizacją-logiczną. Jeżeli nie wyrozróżniasz tych dwóch jako odrebne terminy i upierasz się, że tylko ta inicjalizacja-składniowa ma byc nazwana ""inicjalizacją"" -- to w ten sposób możemy dyskutować bardzo długo, ponieważ ""zamek"" może być zarówno w spodniach jak i w górach na niedostępnej skale i na próżno tłumaczyć że on może być co najwyżej ceglany a nie wszywany na szybko fastrygą. Jeżeli zas w przypadku A) z kodu tuż powyżej przyłapiesz się na nazywaniu ""niezainicjalizowanej-zmiennej"", to równie dobrze pewnienazwiesz/możesznazwać przypadek B -- inicjalizacją tejże zmiennej. Popatrz teraz ponownie dokladnie na te linijkę B i zastanow sie, dlaczego piszac hen-dawno-temu-w-tamtym-poscie podobna temu linijke, kompletnie swiadomie olałem pisanie jakiegos potworka w stylu "".... x = 5"" czy ""??? x = 5"" czy ""int x = 5"" czy ""Typ x = 5"" itip, i czemu przy tym podałem gwiazdkę z objasnieniem init-log vs. init-syntax.. @cos pominalem - tak, ale drobny szczegolik - lista inicjalizacyjna w .ctor'ach okresla inicjalizacje oderwana od miejsca definicji pol obiektu klasy, gdyz w definicjach klas defacto nie mozna inicjalizowac definiowanych pol inline'owo, za wyjatkiem statycznych stalych typu calkowitoliczbowego, więc to co napisałeś w nawiasie prawdą nie jest (nawet jeśli założyć ze pojęcie ""inicjalizacja"" odnosi sie tylko do inicjalizacji-składniowej), jeżeli zwracać uwagę na wszystkie możliwe konstrukcje składniowe, a nie tylko definiowanie zmiennych lokalnych funkcji/metod. (<-- to napisalem w miare formalnie, mam nadzieje ze widac roznice w stylu i szczegolowosci:) ) mam nadzieję że rozwiałem już Twoje wątpliwości co do mojego IQ i znajomości C++, w tym jego standardu, ponieważ szczerze mówiąc, nie widzę żadnego celu ani zysku z tej dyskusji.. Jeżeli upierasz się że tam-kufaa-jest-bląd, spokojnie - mogę przed tamtym identyfikatorem zmiennej na przykład dostawić trójkropek żeby nie udawało całej linijki, mogę zdublować tamten kod razy N wyjaśniając na miejscu wszystkie mozliwe cztery-czy-więcej sposoby inicjalizacji, albo zdawkowo zastapic ten kod zamykającąwszelkiedyskusjeiniejasnosci inicjalizacją ""w stylu konstrukcyjnym""... - ale szczerze mimo ze mnie wtedy korcilo, nie uzylem akurat jej, zeby potem ludzie nie dziwili sie ze maja kolizje z lokalnymi (re)definicjami funkcji jak im sie nazwa zmiennej z nazwą typu skrzyzuje..;"
"co do lekarzy/pielęgniarek już to pisałem - czemu prywatne przychodnie nie strajkują?? Co do strajkujących to mam taką teorię (to moja prywatna opinia), że strajkują wyłącznie ludzie leniwi. Leniwi w dwóch znaczeniach - leniwi w młodości, kiedy trzeba było się uczyć aby mieć jakiś zawód lub leniwi teraz - wolą mieć ciepłą posadkę, na której będą robić tylko to czego się wyuczyli za młodu i nic więcej. [OT]Ja jestem z zawodu programistą i tego mnie nauczono. Ale chcąc zarabiać większą kasę muszę umieć sobie radzić z windowsem/linuxem, wiedzieć gdzie wsadzić paluchy do MSSQLa/oracla/postgresa/DB2 żeby coś naprawić a nie spierniczyć, muszę umieć używać wiertarki/młotka/śrubokręta jak trzeba gdzieś kabel sieciowy przepuścić u klienta, umieć skonfigurować WiFi itd. Oczywiście główną moją domeną jest programowanie ale pracodawca wie, że jeśli pojadę do klienta bo jest jakaś awaria (np. program coś psuje - zdarza się) to jeśli wyjdzie coś innego po drodze to sobie sam poradzę, ew z telefoniczną pomocą współpracownika(ów) i nie musi jechać sztab osób do jednego problemu. To jest wynagradzane.[/OT] jeszcze jedna sprawa odnośnie sytuacji służby zdrowia. Nikt nie zaprzeczy, że służba zdrowia (publiczna) jest chora i to chora cała. Podwyżki i tak nic nie zmienią - trzeba by przeprowadzić całkowitą jej reformę, wywalić wszystkich ""prezesów dorobkiewiczów"" i zastąpić ich menagerami z przawdziwego zdarzenia, i zweryfikować cały pion zarządzający. Gwarantuje, że pieniądze od razu by się znalazły, szpitale przestały by zaciągać gigantyczne długi, poprawiła by się jakoś opieki. W końcu zdarzają się w Polsce perełki wśród szpitali, które nie mają długów i są gospodarne ale to zależy tylko i wyłącznie od kadry kierowniczej. Co do pomysłów rządu to ciężko w kilku słowach. O nagłaśnianych pomysłach już powiedziano dużo - mogę dodać tylko, że sprawy jak teletubisie, religia w szkołach, cała sprawa z lustracją (co wydaje się być głównym celem tego rządu), zmiana listy podręczników, mniejszości seksualne i podobne są dla mnie, mrówki śmieszne i głupie. Powiem nawet, że jestem przeciwny im wszystkim. Bo czy moje dziecko będzie w przyszłości homo czy hetero na pewno nie będzie zależało od teletubisiów, religia jest sprawą osobistą każdego człowieka i rządowi nic do tego!, po ch** mi wiedzieć czy p. xxx był donosicielem czy tylko raz mu się zdarzyło - niech pieniądze wydawane na lustracje przeznaczą np. dla strajkujących - jakby się dowiedzieli ile dostaną to by ze szczęści się popłakali, jakoś lista podręczników była OK przez tyle lat i teraz nagle jest be, tak samo moje preferencje seksualne to moja sprawa i rządowi nic do tego. Niech się on weźmie za ważne sprawy - drogi, poddatek liniowy, ""tanie państwo"". Czy ktoś z Was wie jak zakręcony jest nasz system podatkowy?? Ile się trzeba napocić, żeby wystartować z własną firmą i żeby fiskus (czy inne cholerstwo) się nie dowaliło i nie skasowało interesu...  Tu się z Tobą w 100% zgadzam - jestem umysłem ścisłym i  na samo hasło ""co autor miał na myśli"" dostawałem wysypki. Szczerze to lektur przeczytałem tylko kilka. j. polski jako taki był ok w podstawuwce - tam głównie była gramatyka, coś logicznego i łatwego do ogarnięcia. W średniej natomiast tylko ""co autor miał na myśli""... Dodam tylko, że przez kilkanaście ostatnich lat zapełniłem 6 czy 7 kart bibliotecznych, co daje jakieś 2 -3 książki na miesiąc - mało, dużo nie mnie to oceniać. Jednak książki, które czytam mają się nijak do lektur.  Tu natomiast jedyne co mi się nasuwa to to, że jesteś żałosny. To są normalni ludzie!! Co, któryś Cię zgwałcił, że taki zawzięty jesteś?? samochód Ci ukradł i jesteś pewien, że był pedałem a może któraś lezbijka Ci laskę odbiła? Osobiście będąc katolikiem czuję się obrażony tym, że śmiesz się katolikiem nazywać. Jak znam życie to Twój katolicyzm objawia się tym, że w każdą niedzielę jesteś w kościele i koniec. Bycie katolikiem nie olega tylko na chodzeniu do kościoła!! To pewien sposób życia, postrzegania innych i stosunku do nich.;"
"Od początku używam AI do pomocy w pisania kodu. Pomagam sobie copilotem, chat gpt oraz gemini. Jednak jakbym podliczył sume zysków oraz start przy używaniu AI to wychodze na naprawde lekki plus, chociaż myśle że to może być moje życzeniowe myślenie. Najbardziej pomaga mi copilot z VSC w pisaniu interfejsów, enumów, shit kodu. Tam gdzie naprawde copilot pomaga to pisanie prostych crudów do mongo db w js oraz boostrapowanie unit testów nad którymi też trzeba później sporo się napracować żeby do czegoś się nadawały. Jeżeli wychodze na plus, to myśle że na 8h kodowania (kilka h w pracy + wlasne projekty) wychodze może 30 min do przodu.I szczerze mam nadzieje że nie wychodze na minus. I teraz pytanie, do was. Czy są realne przykłady na rynku, że AI zastąpiło programistów? Dużo się mówi o zwolenianich w IT z powodu AI i baardzooo mi ciężko w to uwierzyć. Naprawde staram się jak moge z tym AI, jestem zdeterminowany żeby finalnie być z niego zadowolony, ale płace za to dużą cierpliwością. Bo często, a nawet bardzo często, próba pomocy sobie przez AI, kończy się na stracie czasu, i dopiero to nadrabiam przy tych interfejsach, enumach, mongo itp Mam wrażenie, że to dziennikarze, którzy nie mają pojęcią o AI w programowaniu tak piszą artykuły, a zwolnienia są przez to że w czasie covidu firmy nabudowały zespołów IT, które po pandemii przestały być potrzebne, z racji jej konca oraz z racji konkurencji na rynku IT. Bo np. taki netflix czy MS, jeżeli miały nadzieje na duże zyski podczas pandemii i nakrekrutowały jak głupie, to konkurencyjne firmy zrobiły dokładnie to samo. Czy może ja źle używam tego AI? ps. Pisze bardzo bardzo bardzo dużo kodu, głównie zaawansowane aplikacji biznesowe. Tak tygodniowo koduje po 50h minimum.;"
"Według tego co piszą mainstreamowe portale AI zastąpią programistów,  ludzie są zwalniani itp. CEO NVIDIA powiedział że za 5 lat nie będzie programistów. Chociaż to zagranie marketingowe pod sprzedaż procesorow. Do tego zaprezentowano Devin czyli AI software developera No i tego co ja bym oczekiwał, to tego że AI będzie pisać za mnie kod. Próbuje próbuje i ciągle sam muszę robić  I ciągle się zastanawiam, czy istnieje chociaż, jeden programista który stracił pracę przez AI.;"
"Zależy kogo rozumiemy przez programistę. Jeśli klepacza szablonowego kodu (robotnika), to jak najbardziej, bo do bycia nadzorowanym wyrobnikiem AI może będzie się nadawało. Jeśli miałoby zastąpić kogoś rozwiązującego realne problemy z danej dziedziny lub tworzącego nowe rozwiązania (pomysły), to wątpię. Generatywna AI nie jest kreatywna. A jeśli koduję powiedzmy 1/4 czasu pracy, a resztę spędzam na spotkaniach, ustaleniach, kawie i obijaniu się, to nie widzę tu zastosowań dla AI :D;"
"Ok to jako, że jestem autorem to podsumuje temat. Na całym świecie nie ma żadnego realne przykładu zastąpienia programisty AI. Mimo to, że dziennikarze ciągle piszą o zwolenianich przez to powstało AI to nie jest to prawda. Na dzien 7 kwietania 2024 AI rozwineło branże i tylko stworzyło wiecej miejsc pracy :) I na obecny moment AI jest tylko wspomagaczem a nie realnym zamiennikiem :);"
"To chyba jak wszędzie. Gównianego HRa AI wygryzie. Dobrego HRa nie zastąpi. Zamykam wątek, temat z czarnej listy;"
"Hej zastanawiam się nad wyborem kierunku studiów i myślałem o programowaniu ale z tego co czytam do 10 lat  AI  zastąpi programistę i nie wiem czy warto. Moje pytanie jest poważne bo jeden z najlepszych programistów na świecie John Carmack założył startup i twierdzi, że w 10 lat stworzy AGI które zastąpi osoby pracujące przy komputerze https://www.insiderintelligence.com/content/startup-keen-technologies-raises-20m-advance-controversial-agi;"
"Dlatego ja idę krok do przodu. Czekam, aż różne AI zastąpią programistów i wtedy ja stworzę AI, które zastąpi tamte AI.;"
"Obstawiam, że to będzie wtorek. AI nie jest takie głupie, aby zastąpić wszystkich programistów w czwartek albo piątek, żeby nie gasić pożarów w weekend, środa to mały piątek, więc też odpada, poniedziałek jest na meetingi i leczenie kaca - zostaje wtorek.;"
"Programiści sami się zastąpią co najwyżej. Przecież ktoś to AI musi stworzyć. I tak jest od dekad. Programiści nieustannie tworzą technologie, które ich zastępują. Począwszy od kompilatorów poprzez biblioteki i frameworki aż po aplikacje, w których można sobie wyklikać aplikację. A teraz jeszcze AI. Czyli raczej oczekiwałbym ewolucji, a nie rewolucji. I raczej wzmocnienia pozycji programisty, a nie osłabienia. Chociaż trzeba przyznać, że programiści jako grupa zawodowa byli zatrudniali w nadmiernych ilościach, więc teraz trzeba to wyrównać i są zwolnienia. Popyt na programistów został sztucznie napompowany. A co za tym idzie miliony ludzi zaczęło iść na programistę i prędzej konkurencja na rynku programistów da o sobie znak, niż programista zostanie zastąpiony.;"
"A tak serio to nie jest do końca prawda że ""AI zastąpi programistów"". Bliżej prawdy jest ""Ludzie którzy bardzo dobrze używają AI, zastąpią programistów"".;"
Jeszcze z 5-6 lat wtedy AI stworzy taki AI który zastąpi aktualny i programistów;
"Ja stawiam, że jest szansa że AI, w pierwszej kolejności,  zastąpi koderów klepiących kod, ale programiści którzy potrafią pogadać z klientem, zebrać dobrze wymagania i zaprojektować co ma być zrobione, będą przez dłuższy czas bezpieczni, ale będzie się od nich wymagało umiejętności analityka biznesowego/testera/PM a kodera w ostatniej kolejności - taki one-man orchiestra. No a najważniejszą umiejętnością będzie dogadanie się z AI w zakresie przekazania co ma kodować i jak testować.;"
"AI nigdy nie zastąpi czynnika ludzkiego. Kod tak, wiele rzeczy będzie można wygenerować. umiejętności komunikacji, zarządzania, rozmów, szerokopojętych skilli miękkich nie.;"
"Ktoś mi odpisał żeby iść na informatykę i programistę. Rozumie, że informatyk to ktoś taki bardziej co wymyśla ulepsza algorytmy, no ale nawet tutaj AI będzie lepsze. Nie dawno czytałem że AI ulepszyło algorytm mnożenia macierzy więc kluczowy dla swojego działania. Więc nie tylko klepaczy zastąpi ale tych od myślenia algorytmicznego również. https://venturebeat.com/ai/deepmind-unveils-first-ai-to-discover-faster-matrix-multiplication-algorithms/;"
"@DarkoZZZ: ale zauważ, że to co obecnie oferuje GPT jest po prostu miażdżące. Ok, bywają błędy, ale ogólnie to jest to zajebiste narzędzie. Były newsy ze tamten czat zdał egzamin lekarski czy skutecznie zastąpił prawnika. A tu chyba taka pierwsza taka usługa dostępna publicznie. Nie wiem, co jest w jakichś laboratoriach NASA, poza tym usługa będzie ewoluować. Czy serio myslisz, że za kilka lat AI nie będzie w większości przypadków skutecznie zastąpić analityka/PM podczas rozmów z klientem i przy ustalaniu wymagań?;"
A kto zastąpi skram majstra?;
"znajomy znajomego szuka sprzątaczek na full time, jest 50 wakatów. 30 lat temu roboty mialy zastapic sprzątaczki ale cos nie pyklo i dalej trzeba zamiatac na osiedlu, zapraszam wszystkich zastapionych przez AI do kontaktu;"
"No właśnie - ciężej zastąpić sprzątaczkę, niż księgowego :);"
"To są dziwne pomysły, że AI zastąpi programistów, ale oprogramowanie będzie dalej wyglądało podobnie jak dzisiaj i użytkownicy będą klykali w kąkutry. ;) Przecież dla systemów w firmach używanych przez ich pracowników to AI zastąpi systemy razem z pracownikami. Co do systemów używanych przez klientów firm, których jednak zastąpić nie można do końca, bo ktoś musi płacić, to czy nie wolelibyście jako klient też mieć asystenta AI, któremu każecie głosowo poszukać produktu lub usługi o jakichś własnościach i ładnie zaprezentować do wyboru i przedyskutować wady i zalety? No właśnie, czyli prawdopodobnie to sprowadza się do tego samego - oprogramowanie ""biznesowe"", jakie znamy dzisiaj, nie będzie miało racji bytu, bo AI będą się dogadywać między sobą po swojemu. To wszystko oczywiście przy założeniu, że to AI będzie coś do końca rozumiało, a nie tylko ""papugowało"" mniej lub bardziej powierzchownie.;"
"Cześć! Kilka miesięcy temu zainteresowałem się programowaniem i innymi nowymi technologiami. Miało to związek ze stanowiskiem, jakie objąłem w firmie, a mianowicie zostałem specjalistą ds. narzędzi CAT i nowoczesnych technologii w jednym z biur tłumaczeń. Na stanowisko to zostałem wybrany przez szefa ze względu na mój „analityczny umysł”. Po czasie zacząłem powoli uczyć się Pythona, choć nadal próbuję czasami też innych języków (na ten moment wszystko jest takie ciekawe :)).  Następnie podjąłem decyzję, aby nie tylko poświęcać swój wolny czas na programowanie, ale żeby stało się to również moją pracą. Jako, że jestem już po magisterce (filologia rosyjska), zdecydowałem się na studia podyplomowe na następującym kierunku - https://www.merito.pl/chorzow/studia-i-szkolenia/studia-podyplomowe/kierunki/programista-python-developer Zapisałem się i mam już informację o przyjęciu na studia, które rozpocznę w październiku tego roku. Szkołom programowania oraz innym oferowanym kursom raczej nie ufam. Programowanie stało się moim nowym hobby i to gównie na nim spędzam swój wolny czas. Odniosłem też swój pierwszy niewielki sukces - napisałem prosty skrypt w Pythonie służący do obliczania stawki za postedycję tłumaczenia maszynowego zgodnie ze wzorem, który wykorzystywany jest przez innych pracowników w mojej firmie każdego dnia. Szef zapłacił mi nawet za ten skrypt, ponieważ napisałem go w swoim czasie wolnym i nie prosił mnie o to, a jednak pozwolił na automatyzację pracy. Postanowiłem jednak odezwać się na waszym forum, ponieważ mimo wszystko mam czasami obawy, czy uda mi się w ogóle dostać do IT. Jedną z moich obaw jest fakt, że na praktyki, staże oraz stanowiska juniorskie jest po kilkadziesiąt/kilkaset chętnych osób. Kolejna kwestia to rozwój sztucznej inteligencji. Dużo mówi się, że zastąpi lub odbierze ona niektóre obowiązki programistom. Staram się podchodzić do tego typu newsów z przymrużeniem oka, ponieważ rozumiem, że portale z informacjami właśnie w ten sposób działają, czyli stosują krzykliwe nagłówki i inne clickbaity. Wśród artykułów w internecie przewija się również ostatnio temat zwolnień w branży IT. Na dodatek moja mama przesyła mi tego typu artykuły, ponieważ jak twierdzi „chce, żebym był doinformowany”... Na chwilę obecną nie mam za bardzo z kim porozmawiać z mojego grona znajomych na powyższe tematy, dlatego jestem ciekaw waszych opinii, aby móc również poszerzyć swoje własne spojrzenie. Dzięki!;"
"Oczywiście, że się zmieni. Tylko są różne zmiany. To, co pisałeś o REST'ach, endpointach i studentach można porównać do tego, że facet stojący w fabryce na taśmie nie musi dokręcać ręcznie śrub, bo dostał wkrętarkę. A rewolucja związana z GPT to jest wywalenie z fabryki 30 monterów przytaśmowych i zastąpienie ich robotami oraz 2 osobami, które te roboty będą nadzorować.;"
"Frontendowca to pal licho, ten zawód sam się automatyzuje, wystarczy poczekać 5 lat i sami frontendowcy się zautomatyzują. Już we frontendzie wiele rzeczy robi się łatwiej niż 5 czy 10 lat temu.  Do tego nie potrzeba AI, tylko potrzebne jest zaangażowanie programistów w projekty open source, które te problemy automatyzują. Swoją drogą to react query nie miał być taką libką, która rozwiązuje problemy z fetchowaniem i robi retry itp. https://react-query-v3.tanstack.com/ ? W każdym razie... wydaje mi się, że frontend to rozwiązany problem, bardziej ciekawe jest, czy AI będzie w stanie zastąpić UX designera i zaprojektować całą stronę zgodnie z jakąś tam logiką projektową, dbając o dostępność, wygodę itp. Wtedy nawet budżetówka mogłaby mieć dobre strony, jeśli AI by je zaprojektowało i wdrożyło.;"
"Mnie zaczyna powoli męczyć ta apokaliptyczna wizja, że chatGPT jest taki cudowny, że zaraz zastąpi programistów a ja nawet nie jestem programistą XD;"
"To, że GPT co najmniej dłuższy czas nie zastąpi programistów to pewne. To, co ewentualnie może nastąpić, to spadek liczby programistów, ze względu na ich drastyczny wzrost wydajności, teoretycznie. Tylko czy nawet w takim przypadku takie rozumowanie ma sens? Przy teoretycznym założeniu, że 1 doświadczony programista z GPT jest w stanie pracować jak setka programistów bez GPT, potencjalny Klient nie będzie oczekiwał takiego samego tempa rozwoju swojego oprogramowania co teraz, tylko będzie korzystał z ze wzrostu wydajności rozbudowując system o masę ficzerów, na które nie było go dotychczas stać (jako że musiałby płacić za 100 dodatkowych programistów). Co więcej, patrzycie na to z pozycji szklanki do połowy pustej - bendom zwalniać. A szklanka do połowy pelna jest taka, że brawo panie senior deweloperze, z chatem GPT staje się Pan firmą stuosobową. Można myśleć o własnych biznesach, lub wdrażaniu oprogramowania tam, gdzie nie było ku temu ekonomicznej możliwości (prywatne osoby). Tak jak 40 lat temu kolor na ekranie to był szał, tak jak 20 lat temu szałem była w ogóle własną strona WWW, tak za lat 10 osobom prywatnym będzie się udostępniać w rozsądnej cenie szybki sklep WWW, pozostawiony na Cloudzie, z automatyzacja CI/CD, oraz podpiętym AI, wciskającym odwiedzającemu, że te garczki pasują mu do wystroju domu. Zamiast gównianego Wordpressa trzymającego sie na trytytkach, zapranego pluginami. A duze korpo będą sprzedawać gadające roboty. Oczywiście teoretyzuję, hiperbolizuję itd., ale mam nadzieję, że przekaz i kierunek jest jasny.;"
"Odpowiedź jest prosta. Ludzie pracują na etacie i robią projekty jakie wymaga pracodawca.Nie ja to kto inny zrobi. Nawet jeśli GPT zastąpi crudowców, to i tak taki człowiek co to tworzył nie musi się bać o pracę.;"
"pamiętam jak kilka lat temu menedżer mówił, że w rozmowach zespołów biznesowych co jakiś czas ktoś wynurzał się z pomysłem zastąpienia całego naszego systemu skoroszytem excelowym (a przecież mieliśmy i dalej mamy mikroserwisy, raporty z zewnątrz, kolejki do świata zewnętrznego i inne szmery bajery), prawdopodobnie przesyłanym mejlem. taki skoroszyt excelowy nie miałby downtime'u, nie potrzebowałby prod supportu, nie trzeba by było czekać na nowe bajery itp czysty zysk :D;"
"jakość wielu systemów jest kiepska z różnych względów, a mamtowdupizm seniorów to tylko jeden z powodów. powodami dla których systemy są kiepskie są np:  regulacje, które spowalniają pracę i dlatego kombinuje się tak, żeby jak najkrócej wozić się z tymi regulacjami (tzn. dopchać coś kolanem zamiast spełniać porządnie regulacje) biurokracja przy (wydawałoby się) prostych rzeczach, np. dodaniu nowych zależności do projektu, wykorzystania kolejnego narzędzia programistycznego czy postawieniu nowej maszyny wirtualnej (robiącej cokolwiek co nam potrzeba, a więc np. uruchamiająca testy, testowe wersji aplikacji, wewnętrzne narzędzia, itp itd), więc nieraz stosuje się kulawe zamienniki, które nie wymagają wożenia się z biurokratycznymi procedurami słabe maszyny deweloperskie, słaba infrastruktura (powolne środowiska uruchomieniowe, duże lagi przy połączeniach do serwerowni, itd), co powoduje, że rzeczy, które najbardziej przez to spowalniane są najbardziej zaniedbywane przestarzała i przez to niezrozumiała i myląca dokumentacja, przestarzałe i przez to niezrozumiałe i mylące nazewnictwo w starych elementach systemu, rozbieżności w terminologii stosowanej przez biznes, programistów oraz zewnętrzne systemy czy formaty danych, które obrabiamy i tak dalej - jest mnóstwo problemów niezwiązanych z jakością programistów  jeśli chodzi o koszty i opłacalność to nie mam pojęcia, ale wiem, że budżetowanie w wielkim korpo jest nieraz absurdalne. ponadto biznes ogólnie nie rozumie pojęcia jakości i niezawodności oprogramowania (w tym testów) i infrastruktury i dlatego biznes ciśnie na dowożenie nowych ficzerów, nawet kosztem słabej implementacji. w telegraficznym skrócie: biznes chce tego co ""wystarczająco dobrze"" działa na chwilę obecną, a o tym co będzie później pomyśli się później.  te wymagania wyglądają jak trolling albo naiwne wyobrażenia. podstawowym problemem, który widać jest to, że egzamin nie daje żadnej gwarancji, że programista będzie produkował dobrej jakości kod. wysiadywanie 20 lat w gównoprojekcie także nie daje żadnej gwarancji, że ktoś się w tym czasie rozwijał. jeden człowiek może w 5 lat przeskoczyć w górę o kilka poziomów profesjonalizmu, a inny przez 20 lat będzie klepał to samo w systemie legacy, np. jakimś mega przestarzałym systemie bankowym w cobolu.  jakość systemu jako całości jest ważna, a nie jakość programistów. oczywiście jedno jest z drugim powiązane, ale jeśli np. ktoś robi audyt (bezpieczeństwa, jakości, zgodności, etc) to nie robi audytu programistów, a audyt wyprodukowanego systemu.  https://pl.linkedin.com/in/wseliga podałem ten występ, bo z jednej strony jest dość memiczny, ale z drugiej strony zawiera i tak sporo prawdy. typowe certyfikaty są niewiele warte w komercyjnej pracy. jeżeli jestem w roli rekrutera to nie interesuje mnie ile kto ma certyfikatów, a jak sobie radził z faktycznymi nietrywialnymi problemami, które napotkał w swojej komercyjnej pracy jako programista.  nie wiem jak jest w nasa, ale cern ma oferty dla juniorów: https://careers.cern/alljobs?title=&tid=96&tid_1=103 np junior python developer https://www.smartrecruiters.com/CERN/743999951668666-junior-python-developer-sy-bi-sw-2023-38-grae-  skoro w cernie jest masa roboty dla juniorów to czemu w banku (czy dowolnym innym korpo) nie miałoby być? kwestia rozsądnego zarządzania. co do tych krytycznych systemów instytucji finansowych, o których się często wspomina to sprawa jest taka, że rzadko kiedy faktycznie jest jakiś pojedynczy krytyczny system, który mógłby położyć (zrujować) jakąś korporację. w bankach systemy tworzą system naczyń połączonych, które się wzajemnie ograniczają, kontrolują, uzupełniaja, pokrywają (w sensie jeśli któryś system padnie to można go zastąpić tymczasowo innymi z pewną stratą efektywności pracy, ale z zachowaniem ciągłości zapewniania usług). bazy danych i inne rzeczy mają backupy, więc nawet jak ktoś zrobi 'drop database' na produkcji to i tak to się da odkręcić. chyba jedynym systemem finansowym, który mi przychodzi do głowy i który mógłby zrujnować jakieś korpo mógłby być nieograniczony niczym bot giełdowy do hft (high frequency trading). tam w ciągu sekund można przewalić setki miliardów dolarów. ale i tak wydaje mi się, że tutaj też można wprowadzić wiele poziomów zabezpieczeń, by zapobiec takim sytuacjom.;"
"Temat tak bzdurny, że głowa boli. Pracować można nie tylko dla pieniędzy. Rację ma więc ten, który jest szczęśliwy z robienia tego co robi. Większość programistów (zakładając, że większość to mężczyźni) potrzebuje w głównej mierze uznania. Leży to u podstaw naszej psychiki i zwykle większość ludzi nie mamy na to wpływu. Będziemy szukać tego uznania wszędzie gdzie się da i wszystkimi sposobami. Wysokość wynagrodzenia czasem może zastąpić uznanie ale zwykle tak nie jest. Dla jednego praca będzie miejscem gdzie się spełnia a dla drugiego jedynie miejscem, w którym zarabia kasę na nowy rower albo nowy telefon. Nawet z perspektywy pracodawcy miejsce w firmie znajdzie się dla jednych i drugich. Dlatego ocenianie ludzi przez zaproponowane schematy to idiotyzm.;"
Zaden. Pierwszego zastąpi AI a drugi wypali się zawodowo;
"@ŁF: a najlepsze jest że jak się zapytałem GPT to mi proponował custom implementacje dekorując Dictonary<TK,TV>. Tak w ramach ""czy AI nas zastąpi?"";"
"Ale co się przejmujecie?! Przecież w ciągu 5 lat zniknie zawód programisty, zastąpi nas AI. Brak B2B to pikuś.;"
"Dosłownie wystarczy to wkleić w GPT, bing ma chat GPT w wersji 4 za darmo.  Może AI jeszcze nie może zastąpić programistów ale na pewno może zastąpić nauczyciela na tym poziomie   screenshot-20231211214147.png (263 KB) - ściągnięć: 5;"
"Dziękuję za pomoc. Nie wpadłem, żeby zapytać o pomoc AI. Jest w kodzie jeden błąd jest c: TControl a ma być c : TComponent; Widać jeszcze AI nie zastąpi chwilowo człowieka ;);"
"Ale zdajecie sobie sprawę, że na chatgpt się temat nie kończy. Prędzej czy później powstaną wyspecjalizowane modele, które będą potrafiły tworzyć oprogramowanie. Nie wiem czy to kwestia 5 czy 25 lat, ale to się wydarzy  zapewne będzie to ewolucja, ale na pewno znacząco zmieni wygląd branży. Jedyne pytanie jakie jest otwarte to czy w przewidywalnej przyszłości programista będzie kontrolował AI jak operator koparkę czy będzie zupełnie zbędny bo zastąpi go analityk. Moim zdaniem osoby, które tylko klepią taski zostaną zmarginalizowane.;"
"Sprawa według mnie jest dosyć prosta. Aktualne AI w postaci GPT v4 i produktów analogicznych to świetny generator pracy dla programistów, ze względu na API, które udostępnia - daje to aktualnym aplikacjom nowe możliwości, a więc nowe zadania integracji z tym API, obróbki danych itd. W kontekście pracy programisty mamy Copliot, który przyspiesza generowanie bolierplate i pisanie prostego kodu, plus zintegrowany chat, z którym można pogadać o swoim kodzie, ale trzeba bardzo mocno filtrować to, co pisze, ponawiać pytania, inaczej je formułować. A mówimy o programiście, który zna temat, kiedy wiedza klienta jest zerową. Aby AI zastąpiło programistów musiałyby nastąpić dwie rzeczy RÓWNOLEGE - nastepny, gigantyczny przełom typu AGI, który naprawdę nie jest tylko ogromnym agregatem danych, ale ma również kreatywność, logiczne myślenie itd., oraz gigantyczny wzrost mocy obliczeniowej dostępnej w światowej infrastrukturze IT, aby uciągnąć zastąpienie prace setek milionów osób mocą obliczeniową AGI. Do tego jest naprawdę daleko. Pomijam opór spoleczny, przecież już teraz wieeeele zawodów i aspektów można by w pełni zautomatyzować, ograniczyć itd, choćby biurokrację, ale politycy tego nie robią, bo obawiają się reakcji elektoratu. Od móc do chcieć jest daleko, ale dla uproszczenia ten wątek pomijam. AI dla aktualnego IT jest szansą, nie killerem.;"
"Właśnie robię zlecenie próbując nie pisać ani kawałka kodu tylko wszystko generować z ChatGPT 3.5. I jestem pozytywnie zaskoczony. Raz że potrafi to wygenerować boilerplate, dwa że ma ten kod sens (ale architektury brak). Problem jest taki że na razie nie udało mi się wygenerować całej apki której potrzebuję. Tzn. i tak muszę to skleić z kilku wyników oddzielnych generowań. Plus - trzeba wiedzieć o co pytać (tak mi się wydaje, jeszcze nie próbowałem pytać ChatGPT o co pytać ChatGPT ). Także owszem może to zastąpić tych którzy powyższego nie potrafią ale koniec końców człowiek i tak jest potrzebny (jak na razie).;"
"Mi się wydaje że pierwsza opcja daje większe możliwości jakbyś chciał się rozwinąć w technicznych kierunkach bo patrząc na stack to masz programowanie(Python), clouda(GCP),  coś z dev ops (Terraform, Kubernetes). Natomiast data analyst wydaje się bardziej wrażliwe na AI szczególnie taka prosta analiza danych już jest zastąpiona ale AI to będzie i tak jako wsparcie cały czas traktowane. Natomiast ta rola może dać Ci się rozwinąć bardziej w kierunku biznesowym i kompetencji miękkich które będą w cenie. Tylko to wszystko zależy od  tego z kim będziesz pracować i co się od Ciebie będzie wymagać. W startupie wynik Twojej pracy może bezpośrednio wpływać na rozwój produktu, podejmowanie strategicznych decyzji. W innym miejscu coś tam przeanalizujesz a się może okazać ze nikomu to nie jest potrzebne.;"
"@waran88: z ciekawości zapytałem chataGPT, która działka jest łatwiejsza do zastapienia przez AI i wyrzucił mi taka odpowiedz.   Oczywiście nie biorę tego za pewnik, ale ciężko mi zweryfikować informacje jako ze nie posiadam wystarczającej wiedzy a internet to wiadomo, każdy artykuł mowi co innego.;"
"Cały czas podajecie przykłady: ""patrzecie ten chat GPT/gemini/copilot to totalny syf! Toż to generuje kod, który nawet się nie skompiluje, no nigdy nas nie zastąpi hehe"" I wiecie co? Przecież ja się z wami zgadzam, że obecnie to całe AI to niewiele potrafi i bardzo rzadko wypluje coś sensownego Aczkolwiek zapominacie o jednym - kwestia nie tyczy się tego, że obecnie AI jest kiepskie, główny problem to rozwój wykładniczy Powtarzam, widoczny gołym okiem rozwój wykładniczy Jeszcze rok temu można było wrzucać proste kawałki pytań do promptu, nie pamiętało historii między zapytaniami, dzisiaj AI pamięta całą historię konwersacji, może nawiązywać do poprzednich promptów i może sobie zaciągnąć 100k linii kodu... Jeżeli w najbliższych latach nie trafią na jakiś poważny problem, blokadę, przeszkodę do dalszego rozwoju to jest bardziej niż pewne, że to kwestia kilku/kilkunastu lat że AI nas zastąpi. I jasne - łatwiej jest zastąpić tą przysłowiową HR-ówkę czy klepacza excela, ale jednak to w programistów komercyjnych, klepaczów webowych są wymierzone wszystkie działa. Dlaczego? Może dlatego, że mimo wszystko z biznesowego punktu widzenia - klient końcowy nie chce rozmawiać z ""chat-botami"", tak samo nie chce rekrutera ""chat-bota"", tylko realny kontakt z drugą osobą. Natomiast programista to taka osoba, z którą zwykły użytkownik aplikacji nie ma żadnego kontaktu, nawet nie wie o naszym istnieniu. No i jeszcze kwestia kosztów, programiści (może nie w Polsce, ale np ci w stanach) zarabiają gigantyczne pieniądze, które są kosztem dla biznesu. Stąd pomysł na zastąpienie programistów w pierwszej kolejności Obecnie szacuje się, że modele AI to takie ""trzy-letnie dziecko"" mające wiedzę milionów osób z całego świata, za kilka lat dojdą do momentu gdy będzie to ""10-letnie dziecko"" mające wiedzę milionów osób z całego świata, a za kolejne kilkanaście lat będzie miało poziom inteligencji 20-30 letniej dorosłej osoby + wiedza kilkuset milionów ludzi z całego świata Lepiej się módlcie, żeby nie stworzyli komercyjnych komputerów kwantowych... Tylko zastój mocy obliczeniowej i zbliżanie się do granicy możliwości (technologia 3nm) daje nam te kilka/kilkanaście lat luzu...;"
"@CoderOne A Wy dalej traktujecie LLM'y jako osobny byt z niebywałą świadomością albo jakiś przęłom... Ten koncept istnieje co najmniej od lat 60. To jest narzędzie bazujące na danych i nic więcej. Z tym rozwojem też się trochę zagalopowałeś. GPT uczy się również na własnych promptach, które bywają błędne, zatem jest to w pewnym sensie samo napędzająca się spirala. Na prawdę minie jeszcze sporo czasu zanim to narzędzie będzie w stanie zastąpić programistę/ów/cały zespół w przypadku pełnoprawnego projektu (o ile w ogóle). Osobiście uważam, że nie szybciej niż za 10/15 lat. Jedyne co się zmieni to standardy. Umiejętność korzystania z gpt będzie branżowym standardem i zastąpi SO.;"
"@axelbest: napisał:  Tylko te najtańsze wykonane w technologii z lat 70`tych. Bo te współczesne już takich błędów nie robią. Mam na biurku jakiś pierwszy lepszy ze sklepu. Model CITIZEN SR-135N i tego błędu nie robi. Minęło 50 lat kolego! AI będzie lepiej pisać programy niż 80% użytkowników tego forum już za kilka lat. Kto twierdzi inaczej ten chyba nie bawił się na poważnie narzędziami AI.  Nikt nic nie będzie musiał kontrolować. Lata pracy z ludźmi pokazują, że Ci są dużo bardziej omylni, leniwi, niedokładni niż AI nawet na dzisiejszym poziomie. Nawet GPT potrafi wypluć dużo ładniejszy i pewniejszy kod niż większość juniorów a nawet  obracających się figur geometrycznych (i nie chodzi tylko o sześcian). Tu masz kilka przykładów kodu realizującego zapytanie do zwykłego GPT a nie jakiegoś wyspecjalizowanego narzędzia:  Napisz obracającego się sześcianu z kolorowymi ścianami. Kod napisz w JavaScript używając Canvas.  https://jsfiddle.net/etnLcap0  A teraz niech to będzie dwunastościan pitagorejski: https://jsfiddle.net/Lgcjr8uw/   Punkt drugi wymagał kilku dodatkowych komend ale efektu końcowego i wyplutego kodu sam bym się nie powstydził. Zatem bagatelizowanie AI w programowaniu to dzisiaj już przejaw zwykłej ludzkiej głupoty. Napisałem mały Framework w PHP na własne potrzeby. Od dwóch miesięcy eksperymentując tworzę dokumentacje na potrzeby GPT Chat. Tak by, wklejać ją w prompt. Jest to wyzwanie bo wielkość prompt jest dziś mocno ograniczona. Ograniczyłe się więc do kilku bibliotek: Config,  Database, IOUtils + ERD dwóch tabel. Finalnie w jednym z eksperymentów GPT zwrócił działający kod (póki co nie było bardzo łatwo bo trzeba było go korygować), który pliki CSV po odpowiedniej obróbce danych importuje do bazy danych. Szczerze mówiąc tłumaczenie mu, co ma robić zajęło niewiele więcej czasu niż tłumaczenie statystycznemu programiście a przewagi są następujące:  mogę to robić w środku nocy, wiem, że narzędzie się będzie rozwiajać, kiedyś połknie całą dokumentację mojego framework, pewnie będzie dało się zapodać wejścia do katalogów na dysku i sam będzie mógł przeglądać pliki,  Jasne, że GPT nie zastąpi dziś jeszcze analityka, który rozmowę z klientem przełoży na działający kod na wskazanym serwerze ale to już jest w zasięgu ręki, a tęgie głowy ostro kminią jak zastąpić przemądrzałego programistę, który za godzinę woła minimum 80zł netto na rzecz automatu, z którym możesz gadać i przekazywć mu wytyczne cały dzień a on skasuje Cię za to10$. To jest ekonomia - z tym się nie wygra. Do tego przekonanie o posiadaniu nadprzyrodzonej wiedzy i doskonałości (przez dużą grupę programistów - oczywiście nie wszystkich) + lenistwo, które doprowadziło do tego, że w większości firm zadania są delegowane w postaci ticketów w języku angielskim aż prosi się o to, że aby te tickety realizowało AI. Za kilka lat product-manager nawet nie będzie wiedział czy zleca zadania AI czy fizycznej osobie. Zadanie ""będzie się robiło"" - tak samo jak dzisiaj się robi tylko automatycznie. Niestety dla zdecydowanej większości programistów wyrok już zapadł i pozostaje im już dziś zastanawiać się jak dużo kasy  mogą jeszcze wydusić z obecnej roboty by odłożyć na swoją przyszłość. Potrzebni będą jedynie Ci, którzy zarządzają i tworzą zadania - nieco się wyspecjalizują, kupią nowe narzędzia, powstaną Frameworki wyspecjalizowane do pracy z AI (już powstają). Nikomu nie będzie potrzebne żadne IDE ani nudny programista, który zajmuje miejsce przed monitorem i zużywa prąd żeby świeciło mu 3 x 32 cale ekranu. Tak jak dziś nawet w Intelu i AMD nie do końca wiedzą jak działa ich procesor na najniższym poziomie czyli litografii - bo to nie ma znaczenia. Ważne jest że działa a powszechnie wiadomo, że od lat już tym końcowym etapem projektowania zajmuje się właśnie AI, algorytmy ewolucyjne itp. Również managera w Twojej firmie, guzik będzie interesowało, że kod nie jest ""piękny"" jak ten Twój. Ten z idealnymi wcięciami i z zachowaniem reguł pisania ""zajfajnego kodu"" z wszystkich 5-ciu książek, które czytałeś z wypiekami na twarzy. Także jeśli nie nastąpi jakaś katastrofa poza technologiczna typu totalny światowy Armagedon to jestem pewien, że już dziś ponad połowa siedzących na tym forum za 5 albo 10 lat będzie pracować w innym zawodzie. Tak samo jak masy ""niezastąpionych wówczas księgowych"" w USA w latach 60-tych, których wyparły komputery. Nie wieszczę, że wszyscy zostaną bez pracy ale zawód programisty jaki dziś znamy w najpowszechniejszej postaci można uznać za wymarły już teraz.;"
"Zgadzam się z @4w0rX4t4X nie ma już odwrotu, jedyne co nam pozostaje to zarobić i zainwestować ile się da zanim przyjdzie czas na naszą branże. Nie wierzę że chatGPT w tej dekadzie całkowicie zastąpi ludzi, ale może namieszać w ten sposób że jedna osoba będzie w stanie w 1 dzień zrobić robotę zespołu przez tydzień. Na pocieszenie dodam że poleci też wiele innych zawodów:  Tłumacze, graficy, copywriterzy. Wszelkiego rodzaju doradcy. Wszelkiego rodzaju analitycy. Aktorzy i aktorki.  Co ciekawe zawody in real life jak fryzjer czy budowlaniec nadal powinny się trzymać (to jest dekadę dłużej aż AI wymyśli jak i ich wyautomatyzować). PS. W czasie gdy TY dysktujesz na 4p, Hindusi już masowo korzystają z chatGPT! Już krótce hindusGPT może mieć jak mawiają amerykanie upper hand nad outsource'ingiem do Polski i wtedy się zacznie. Wszystkie JPMorgany i inne molochy zaczną znów outsource'ować do tanich pragramistów uzbrojonych w GPT...;"
"@Rajmon, @ledi12 - zapominacie o tym, że w tej chwili takiego LLMa stawiam w domu na kompie z 2 dobrymi kartami graficznymi i mogę eksperymentować z tematem ile mi się podoba - co zresztą zaczynam robić, bo właśnie wczoraj z dwoma współpracowników podjęliśmy decyzję o zakupie kart i zapisaniu się na kursy AI dla programistów, żeby nie grzebać się w tematyce po omacku. Ale kij z nami - bo my już mamy swoje lata i jedynie nie chcemy wypaść z rynku. Jednak takie karty zakupiło kilkadziesiąt milionów programistów na całym świecie i każdy zacznie coś eksperymentować i dłubać. Jedni zaczną łączyć swoje LLMY w sieci, a inni pogrążą się w optymalizacji. Jeszcze inni po prostu zaczną wykorzystywać je w biznesie na małą skalę - tak jak ja. Dziś mam konkretny pomysł i projekt, który realizuję. Projekt ten bez AI na dzisiejszym poziomie był niezmiernie trudny do wykonania - od wielu lat nas to truło i nie wiedzieliśmy jak się za to zabrać. Szacowaliśmy, że koszt wykonania to 300 000zł - 600 000zł / minimum rok pracy dla 2 - 3 osób nie licząc czasu na wdrożenie zespołu w branżę. Dziś dzięki AI, pojawiła się możliwość wykonania tego oprogramowania, dającego ten sam efekt końcowy, a nawet lepszy w terminie do początku maja tego roku. I zrobimy to! Wniosek chyba jest prosty. Po pierwsze wspomnianych 2 - 3 programistów już nie nigdy dostanie tej pracy (i wielu podobnych). Po drugie chęć automatyzacji i wykorzystania nawet nieco ułomnego ale bardzo posłusznego pracownika jest silniejsza niż chęć wdrażania w temat kolejnego człowieka. Dziś nasz zespół to żadne orły AI - nawet nie początkujący amatorzy, a mimo to nawet z tak małym poziomem wiedzy o AI potrafimy skutecznie wykorzystać tą technologię do rozwiązywania konkretnych problemów. Teraz wracając do tych milionów programistów co także się za to zabrało. Są pośród nich tacy co będą szukać nowych możliwości dla sławy, dla pieniędzy, a inni jeszcze z innych pobudek. Część  nowych odkryć będzie przypadkowa, część będzie kontynuacją zadań i idei, które już od lat były rozwijane ale to ich urzeczywistnienia brakowało właśnie AI, nawet jeszcze nieco kulawego. Pewne jest jedno. Ci ""domorośli eksperymentatorzy"" już niebawem na tych starych modelach + LLM zaczną uruchamiać i robić takie rzeczy, o jakich twórcą AI się nawet nie śniło. A tak przy okazji ""podobno"" nowe centrum badawcze openAI jest 10 razy większe od dotychczasowego. Jak można się domyślić będą tam nowe serwery z nowymi wyspecjalizowanymi do AI akceleratorami i układami. Jasne że dziś mamy w AI spore ograniczenia na ""wejściu"" ale może uda się je obejść zrównolegleniem wielu LLM. Nie wiem, nie znam się na tyle. Ale nie tylko @Rajmon i @ledi12 mają świadomość tych ograniczeń ale także cała masa ludzi, którzy dziś zrobią bardzo dużo aby te ograniczenia przeskoczyć. To, że AI dziś robi błąd w równaniu to żaden problem. Po prostu nie do tego będzie wykorzystywany. Zresztą nawet na tym forum miliony razy ""wybitni programiści"" pisali, że matma w programowaniu nie jest potrzebna :-)  Nie wiem co inni uważają, ale ja uważam, że pracownik nawet z IQ 80 ale 100 razy tańszy - zepchnie tego żywego na margines. Tak jak dziś - jeden starej daty full-stack z IQ 150+ zastępowany jest kilkuosobowym zespołem o średnim IQ 125 - tak samo niebawem ten kilkuosobowy zespół zostanie zastąpiony siecią współpracujących LLM o IQ 80 i to też będzie działać.;"
Bardzo fajna konkluzja. Jednocześnie prawdopodobnie jest dobrą przesłanką do wskazania gdzie leży granica pomiędzy tymi co zostaną a tymi co zostaną zastąpieni i odpowiedzią na pytanie z tematu.;
"Nie pisałem w C++ Builder całe wieki. Pytając AI wyszły głupoty, ale po wklejeniu dokumentacji wyprodukował coś bardziej rozsądnego: https://chat.openai.com/c/872164b1-5cf4-4ab5-8885-32ec9b3fb96a AI jest fajne, ale nie można mu ufać (daje złe rozwiązania, jak nie ma się odpowiedniego skilla to powoduje więcej kłopotów niż pożytku), tu masz wersję poprawioną przez mnie, powinno być ok: int CALLBACK CompareTreeNodes(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort) {     TTreeNode* Node1 = reinterpret_cast<TTreeNode*>(lParam1);     TTreeNode* Node2 = reinterpret_cast<TTreeNode*>(lParam2);      bool isDir1 = Node1->HasChildren();     bool isDir2 = Node2->HasChildren();      if (isDir1 == isDir2) {         return AnsiCompareText(Node1->Text, Node2->Text);     }     return isDir1 - isDir2; }  Swoja drogą API do sortowania nie projektowała osoba z dużym doświadczeniem w C++Builder, więc to strasznie wygląda.  Edit:   A teraz widzę, że jest mały bug, w tym co zaproponowała AI (i co poprawiłem) :/. Ego trzeba pogrzebać w dokumentacji i zastąpić HasChildren czymś prawidłowym. Czy ktoś inny widzi ten bug :P ?;"
Jakim cudem AI ma zastąpić pracowników? Przecież to co wypluje AI trzeba umieć wdrożyć i połączyć z czymś innym żeby to działało. Imo nigdy AI nie zastąpi człowieka. AI to tylko pomocny tool;
"Troche clickbaitowy ten tytul :P. Moim zdaniem jestes podrecznikowym przykladem wypalenia zawodowego. Brak checi zmiany pracodawcy/zawodu ze wzgledu na utrate statusu materialnego to bardzo popularny motyw tzw zlote kajdanki. Po pierwsze warto udac sie do psychologa. Po drugie niepotrzebnie sie nakrecasz tym AI, wszystkie te chaty czy copiloty nie zastapia nas jeszcze przez (minimum) kilkanascie lat. W momencie kiedy AI bedzie w stanie przejmowac robote programistow rownie dobrze bedzie moglo zastapic jakies 90% pozostalych zawodow, wiec nie ma co sie przejmowac na wyrost :P.;"
"Kiedy przestaniecie tak panikować na punkcie tego AI? Mam wrażenie, że najbardziej AI boją się bezproduktywne w pracy osoby które mogłyby zostać zastąpione przez byle juniora (albo wytresowana małpe) a boją się, że AI to przyśpieszy. Naprawdę, osoby których praca to coś więcej niż wycentrowanie raz dziennie diva powinny być raczej spokojne o swoje zatrudnienie.;"
"Uważam, że w najbliższym czasie podstawowe zadania mogą zostać zautomatyzowane. Po prostu trzeba będzie zdobyć dużo większe umiejętności w krótszym czasie i pozostaną tylko dobrzy programiści, natomiast osoby, które nie mają jakiś większych umiejętności zostaną zastąpione przez AI. Moim zdaniem trzeba przygotować się na to iż może powstać większa konkurencja na rynku IT. A jeśli powstanie to musisz nadrobić pewną wiedzę tak aby być dalej w grze. I raczej nie będzie tutaj chodziło o nauczenie się kolejnego frameworka tylko umiejętność rozwiązywania złożonych problemów i zaprogramowania tego w dowolnym języku czy też duża większa wiedza techniczna. Na pewno nie będzie łatwiej bo obecnie to są początki ale można sobie wyobrazić taką sytuację, że na rynku pozostaną tylko dobrzy programiści. I te osoby również mogą zadawać coraz trudniejsze pytania GPT i czasami go pouczać przez co sam algorytm będzie zdobywał coraz wiekszą świadomość jak to zaznaczył Andrzej Dragan.;"
"Ten poziom AI przyszedł wcześniej niż zakładałem (ale oczywiście moje wyliczenia były strzałem z d**y, bo się absolutnie na tym nie znam i nie znałem) i będzie podejrzewam tak samo jak z internetem. Internet dał nam ogrom możliwości, dosłownie otworzył nas na cały świat, ale w zamian zostaliśmy zniszczeni. Brzmi to edgy, ale internet rozpierdzielił społeczeństwo w drobny mak. Nie będę się rozwodził szerzej tutaj bo byłby offtop. Uważam jednak, że z AI będzie to samo. Popchnie nas niesamowicie do przodu, inteligentne jednostki z tego skorzystają i będą błogosławić to narzędzie. Nic oczywiście za darmo nie przyjdzie i społeczeństwo zdegenruje się pewnie jeszcze bardziej i zaczną się większe problemy. Czy wszystkich zastąpi AI w robocie? Pewnie jeszcze nie, ale zacznie to powoli się dziać. Ja nigdy nie planowałem programować do końca życia także jestem absolutnie gotowy zmienić branżę jak okażę się za słaby by konkiurować z AI i z programistami lepszymi od siebie. Problem jest taki, że gdzie ci wszyscy ludzie się potem podzieją, bo fizoli też zacznie być nadmiar. Z prozaicznych plusów i minusów - jak AI zacznie nam praktycznie tak łatwo tworzyć gry i filmy jak tworzy teraz Midjourney obrazki to znowu będzie zalew syfu i szukanie perełek będzie JESZCZE trudniejsze. Mi Midjourney urwał suty, ale rozwój poszedł w kierunku nie takim co osobiście bym korzystał i znudziło mi się. Ludzie jednak niezmiernie tworzą te fotorealistyczne ""artworki"" i już w 95% przypadków i tak możesz stwierdzić, że było to zrobione przez AI bo albo ten sam styl cieniowania albo pomysł tak odjechany, że człowiek by tego raczej nie zrobił. Ubolewam, że prawdziwi artyści w końcu wyginą zalani syfem generowanym przez AI przez ludzi bez talentu i bez pomysłu. No ale chociaż będę mógł wygenerować więcej pornoli z aktorkami co już dawno są na emeryturze i w gatunkach w których jeszcze nic nie nakręciły, yay;"
"IBM zatrzymuje rekrutację na stanowiskach które mogą zostać zastąpione AI, potencjalnie do zwolnienia pójdzie 7800. Sporo mają tam tych HRów i influencerów z dziedziny ""How looks my day in IBM"" https://www.reuters.com/technology/ibm-pause-hiring-plans-replace-7800-jobs-with-ai-bloomberg-news-2023-05-01;"
"Z okazji rekolekcji adwentowych i ogólnie zbliżających świąt Bożego Narodzenia proponuję pogłębienie duchowości ich przeżywania poprzez zapoznanie się z jednym z najbardziej niezauważonych filmów religijnych traktujących o problemie zła i odkupienia - czyli Pitch Black. Dzieło Davida Twohy'ego z roku 2000 znakomicie wpisuje się w ówcześnie panujący klimat milleniaryzmu a dodatkowy ateizm autora pozwala bezpieczenie założyć że będzie on co najmniej oryginalny w swoim podejściu. I jest. Abstrakt dla leniwych (bez spojlerów) Pitch Black to solidne hard s-f z znikomą ilością fantastyki. Doświadczony reżyser, oszczędna scenografia, znikoma liczba lokacji (trzy), niewiele CGI, zespół aktorski dający radę + Vin Diesel który stara się grać i nawet mu to wychodzi. Solidne kino choć niezbyt oryginalne. Więc gdzie tkwi haczyk? Pitch Black to jeden z tych filmów które posiadają scenariusz. Scenariusz z kluczem albo raczej dwoma warstwami interpretacji. Jedną świecką i wierną zasadom s-f + drugą religijną. Ta druga to luźna adaptacja Księgi Hioba gdzie bohater główny zostaje zastąpiony bohaterem zbiorowym a zamiast Boga rozmawiającego z Jobem mamy osobowego szatana pod postacią Riddicka który wchodzi w podobne interakcje z bohaterami i ciągle wystawia ich na próbę. Pełna analiza (MASOWE SPOJLERY) Do analizy korzystam z wersji reżyserskiej Pitch Black (zawiera kilka scen wyciętych dość znaczących dla drugiej warstwy) + opcjonalnie z Mrocznej Furii która choć jako animacja stoi kilka klas niżej od pierwowzoru to ładnie domyka klamrą pewien wątek z oryginału + niektóre sceny. Poza jedną wzmianką nie będzie tu nic z Kronik Riddicka bo wg. mnie nie jest on kanonicznie powiązany i jest w zasadzie odrębnym scenariuszem który po prostu został wybrany przez Twohy'ego z powodu tego że wytwórnia rzuciła mu mnóstwo hajsu a on miał scenariusz gdzie ten hajs był wymagany. I tak powstał choka... znaczy się Kroniki. Do rzeczy. Po pierwsze tytuł - czyli ciemno jak w d***. Swiatłość reprezentuje domenę Boga, świętości i prawdy, ciemność jest tego przeciwieństwem, cała historia w filmie dzieje się w świecie w którym Bóg jest daleki i nieobecny a szatan czyha na każde potknięcie bohaterów by doprowadzić ich do zguby + działa aktywnie. Bóg tutaj też nie jest chrześcijańskim miłosiernym dziadkiem tylko Bogiem z Księgi Hioba (starotestamentowym) którego głównym atrybutem jest sprawiedliwość a osąd jest surowy i nieodwołalny - jest on w filmie reprezentowany przez siły natury (głównie bestie). Ma też swoją miłosierną stronę ale w filmie jest to tylko subtelnie zaznaczone. Lokacja też nieprzypadkowa, pustynna planeta zapełniona przez dzikie bestie. Brzmi znajomo? No tak - Mk 1, 12-13 Postacie  Szatan czyli Richard B. Riddick - główny bohater całego filmu, mocno inspirowany przedstawieniem w Księdze Hioba. Rola życia dla Vin Diesela :) Nie jest to postać epatująca złem. Raczej solidny pracownik sumiennie wykonujący powierzoną mu rolę i czerpiący satysfakcję z sukcesów. Ma też pewne dodatkowe interesujące cechy   nigdy nie kłamie pytany wprost (z drugiej strony nigdy nie mówi całej prawdy a i prawdę potrafi obrócić w swoją korzyść)  nigdy nie odbiera życia osobom poddanym próbie - jest to bezpośrednie nawiązanie do Hioba Hi 1, 12 jak również zaznaczenie faktu że jego rolą nie jest egzekucja sprawiedliwości - to atrybut Boga ma też swoją emocjonalną stronę, kiedy rozpoczyna kuszenie to zazwyczaj od jakiejś sarkastycznej uwagi na temat charakteru postaci 1 lub sytuacji, reaguje też wściekłością gdy jego plan zawodzi albo gdy zostaje związany  jest podatny na praktyki magiczne/okultyzm. Tzn. można wchodzić z nim w układy ew. wiązać go nimi. Jest to najlepiej widoczne w relacjach pomiędzy Riddickiem a Johnsem, jest to też jeden z powodów dla którego Riddick określa tego ostatniego jako niebieskookiego diabła   Psychopatyczna rodzinka2:   Johns - ""mag"", najciekawsza postać z uwagi na to że jest to jedyny gość w całej ferajnie który od początku do końca rozumie kim/czym jest Riddick (to morderca). Przez połowę filmu jego wręcz obsesyjny cel polega na związaniu Riddicka czy to za pomocą łańcuchów czy też za pomocą paktowania z nim tylko po to żeby uchronić resztę grupy przed niebezpieczeństwem. Ten człowiek nie polega na Bogu tylko na sobie i swojej wiedzy. To ostatecznie przypieczętowuje jego upadek. Archetyp: inspirowany prawdopodobnie Achazem.  Carolyne Fry - pilot statku, kobieta która na samym początku chętnie wysadziłaby cały statek jeśli od tego zależałoby jej przetrwanie :) Powstrzymana przez Owensa, zrobiona później przez resztę ocaleńców kapitanem próbuje jakoś odkupić swoje winy/wykazać się. Stanowi chyba smaczny kąsek dla Riddicka który na samym początku ją sobie oznacza.  Imam - muzułmanin, na pielgrzymce (Hajj) z podopiecznymi. Jedyny człowiek w 100% pokładający ufność w Bogu od samego początku i poważnie traktujący przestrzeganie nakazów swojej religii. Optymista z początku, z czasem jego wiara zostaje poddana coraz większej próbie. Archetyp: bez wątpienia biblijny Hiob  Paris Ogilvy - przedsiębiorca, handlarz, zamożny człowiek, epikurejczyk ew. umiarkowany hedonista. Zawsze myśli najpierw o sobie, dość tchórzliwy. Możliwe że inspirowany bogatym młodzieńcem   Zeke - jedyny człowiek deklarujący się jako ateista w całym filmie. Dziwnym zbiegiem okoliczności jest również pierwszym zabitym przez bestie ;)  Shazza - najsłabiej zarysowana postać, ciężko o niej cokolwiek powiedzieć poza tym że to prawdopodobnie jej akcja (oddanie pasa ze światłami z podziękowaniem) zwalnia Riddicka z paktu zawartego wcześniej z Johnsem  Jack - dzieciak na kosmicznym gigancie. Super interesująca postać z dwóch względów: po pierwsze jest na granicy wieku odpowiedzialności3, co teoretycznie wyłącza ją z kręgu zainteresowania Riddicka a po drugie nie posiada żadnych opiekunów którzy braliby odpowiedzialność za nią oraz za jej ukształtowanie. Przejawia też dziwną fascynację złem pod postacią Riddicka. Jej wątek wykracza poza historię w Pitch Black i zostaje domknięty w Mrocznej Furii. Archetyp: Ewa  Powyższa lista zamyka krąg zainteresowania Riddicka, są jeszcze miniony Imama ale prawdopodobnie wszyscy są poniżej wieku odpowiedzialności poza tym mają opiekuna. Tak czy siak są oni tylko narzędziem w planach Riddicka a nie celem i poza tym są dla niego powietrzem. Fabuła W całym filmie Twohy intensywnie (jak się obejrzy kilka razy pod rząd to nawet za intensywnie) używa klamr kompozycyjnych szczególnie jeśli chodzi o sceny kuszenia/upadku poszczególnych postaci. Inne są z kolei nawiązaniem do fragmentów Biblii. Warto też zwrócić uwagę na pewne reguły gry: celem Riddicka nie jest śmierć/życie ocaleńców bo decydowanie o tym nie leży w jego kompetencjach. Jego zadaniem jest doprowadzenie do upadku człowieka w oczach Boga4. W świecie Pitch Black przedwczesna śmierć może być darem miłosierdzia - kończy bowiem czas próby.5 Interesujące sceny/klucze w kolejności chronologicznej.   Początek/katastrofa - rozgrywa się w zasadzie pomiędzy Fry a Owensem. Ustawia ona pewną regułę mechanicznej sprawiedliwości w oczach Boga - mianowicie można poświęcić się za kogoś. Fry zawodzi ale zachowuje życie (na czas próby). Owens wychodzi moralnie zwycięsko ale ginie - być może jego śmierć jest ceną za życie Fry. To jest dodatkowo wzmocnione klamrą przy śmierci Owensa kiedy ten przypomina jej o dokładnie chwili6   Prezentacja psychopatycznej rodzinki - niedługo po katastrofie, kilka fragmentów wartych uwagi - komentarz Johnsa po rzucie okiem na busolę/kompas (Interesting)7, Imam z minionami dokonujący rytualnej ablucji, Johns prezentujący Fry postać Riddicka - Is he really that dangerous? - Only around humans   Ucieczka Riddicka - po raz pierwszy Riddick zyskuje wolność swobodnego działania, Johns wyjaśnia ekipie metody działania Riddicka, szczególnie mocny jest fragment kiedy Paris pyta się co będzie gdy Riddick znajdzie ich pierwszy Johns: There'll be no shots - i w pewnym sensie ma rację  Siedem kamieni aby powstrzymać diabła8 - część tej sceny została wycięta w wersji kinowej, dialog Imama z Fry wyjaśniający sens pielgrzymki i że oni wszyscy są teraz częścią pielgrzymki. Ten dialog jest najbardziej bezpośrednim nawiązaniem do drugiej warstwy narracji w całym filmie, możliwe że dlatego też wyleciał z post produkcji.  Grzebanie zmarłych - znakomity portret charakteru Parisa + jego komentarz na temat Zeke'a grzebiącego zmarłych będącym oczywistym nawiązaniem do Pisma. W tej scenie po raz pierwszy pojawia się lekko niezdrowa fascynacja Jack postacią Riddicka  Spowiedź Fry - Fry relacjonuje Johnsowi rzeczywisty przebieg katastrofy statku i rolę Owensa w ocaleniu pasażerów. Jest to pierwsza scena w której pojawia się swobodnie działający Riddick. W tej samej scenie ją też sobie naznacza (odcięcie kosmyka włosów)  Zabójstwo ocalonego - pierwsza scena w której padają strzały i leje się krew9. Całą scenę z oddali wygodnie obserwuje Riddick. Niestety dla Zeke'a przekroczenie piątego przykazania w powiązaniu z z deklarowanym ateizmem nie kończy się najlepiej ;) Niedługo później otrzymuje on swoją odpłatę z rąk Boga (Riddick oczywiście jak ma w zwyczaju obserwuje całe zajście z bliska)  Pierwsza rozmowa z szatanem - ciekawa konwersacja trzech osób - Fry, Riddicka i Jack. Pomijając sarkastyczny wstęp Riddicka pada tam badzo dużo ciekawych kwestii na temat postrzegania szatana przez siebie, roli Boga, strachu oraz tego co jest potrzebne do bycia świadomym różnic między dobrem a złem (czyli możliwości bycia poddanym próbie). Po kolei:   All you people all so scared of me (...) But it ain't me you gotta worry about now Riddick wprost zwraca uwagę że jego rola opiera się na strachu i że czerpie z tego satysfakcję. Jednocześnie nie wprost sugeruje że człowiek nie powinien się bać jego lecz Boga  Show me your eyes Riddick - oczy to obraz duszy, oczy to świadomość odróżniania dobra od zła. Ta prośba i to co po niej następuje jest w zasadzie pierwszą próbą kuszenia Fry. To co Fry zauważa w oczach Riddicka (które odbijają światło) to jej własne demony. Miodnie odegrane Tu wpada Jack, w zasadzie jej obecność w tej scenie jest zupełnie zbyteczna chyba że jej dialog ma ukryte znaczenie. I tak jest w istocie. W pierwszym pytaniu prosi Riddicka o instrukcję stania się świadomym dobra i zła. Riddick po raz pierwszy traktuje ją poważnie (taksuje ją oczami) i sugeruje najszybsze rozwiązanie You gotta kill a few people. Po odpowiedzi Okay I can do it momentalnie traci zainteresowanie i wraca do Fry ponieważ odpowiedź Jack jest jasną deklaracją niezrozumienia, czyli przyznania że jest się dalej pod protekcją Boga. Riddick kontynuuje wypowiedź kierując ją już do Fry10. Jack próbuje ponownie zawalczyć o uwagę poprawnie interpretując cel oczu ale zostaje natychmiast ucięta przez Fry. W tym momencie Riddick testuje Jack pod kątem tego czy potrafi działać samodzielnie. Podporządkowanie się Jack poleceniu Fry potwierdza status nieświadomości co komentuje ostatecznie Riddick - Cute kid  Kuszenia Fry ciąg dalszy, Riddick przyznaje że jest mordercą ale zgodnie z prawdą odmawia odpowiedzialności za Zeke'a. Całość kończy się ciekawym Look deeper     W głąb króliczej nory - pierwsza część to ciekawa dyskusja pomiędzy Johnsem a Fry. Johns próbuje prawidłowo odwieść Fry od bezsensownej misji bo doskonale rozpoznaje schemat działania Riddicka. Wyjaśnia Fry że Riddick manipuluje jej poczuciem strachu/odpowiedzialności za grzechy przeszłości. Fry pozostaje głucha. W tej scenie Jack znowu próbuje się wyrwać na niezależność ale zostaje zgaszona zarówno przez Johnsa jak i Fry. Ciekawsza jest druga część w której Fry próbuje się ratować z podziemi, na filmie Riddick hałasuje łańcuchami by jej wołanie o pomoc nie zostało usłyszane. A to sugeruje że dla Riddicka jej śmierć w tym momencie byłaby sukcesem.  Druga rozmowa z szatanem - pakt - tym razem w delegację udaje się Johns. On nie bawi się w dyskusje, od razu przechodzi do interesów. Ogólnie Riddick nie jest zainteresowany do czasu aż Johns przyznaje się do zmęczenia ciągłą walką z nim. To poważny błąd i Riddick od razu dostrzega szansę, rozpoczynając kuszenie - prowokuje Johnsa do morderstwa11 (Johns nie jest w prawie by decydować o życiu i śmierci). Kuszenie kończy się porażką i pierwszym krótkotrwałym wybuchem wściekłości F*ck you u Riddicka. Odbierając opaskę od Johnsa Riddick potwierdza zawarcie paktu.  Karawana - Riddick związany paktem robi za muła roboczego, Shazza wyraża podziw dla osiągnięcia Johnsa Click your fingers, and he's one of us now?, to czas jego triumfu. Ale nie wszystko jest piękne. Scena spotkania między Parisem a Riddickiem jest klamrą do sceny jego śmierci (możliwe że jest to nawet to samo miejsce)  Spotkanie pod magazynem rdzeni Jack próbuje ponownie zwrócić na siebie uwagę Riddicka (upodabniając się nawet z wyglądu) + wciąga w to jednego z minionów Imama. Tylko Riddick ma już inny plan, los podopiecznego Imama zostaje przesądzony12 (jego życie/śmierć jest obojętne) a Jack pośrednio przyczynia się do jego śmierci co stanowi preludium do jej własnej decyzji że potrafi zabić.  Uwolnienie szatana - scena w wersji reżyserskiej następująca po badaniu szybu w magazynie rdzeni. Shazza przekazuje Riddickowi pas ze światłami jako przeprosiny za bycie w błędzie. Po początkowym odrzuceniu Riddick przyjmuje dar. Cała scena może by była bez znaczenia gdyby nie fakt że niedługo po niej Riddick zaczyna się zachowywać kompletnie niezależnie nie słuchając już poleceń nikogo13. Kilka minut później uczestnicy stają się świadomi nadchodzącego zaćmienia co Riddick komentuje You're not afraid of dark, are you?   Budowanie podziałów - Riddick ponownie wraca do Fry tym razem już bez łańcuchów i ograniczeń14. Jego celem jest nastawienie Fry przeciwko Johnsowi. Mimo początkowej porażki (We're not gonna turn on each other, no matter how hard you try) co powoduje pewien atak agresji, druga próba uderza w bardziej czuły punkt (śmierć Owensa) + ujawnia słabość Johnsa do morfiny. Następująca po tym rozmowa Fry z Johnsem udowadnia że kuszenie zakończyło się pełnym sukcesem. Nadchodzi ciemność  Powrót do wraku - jedyny interesujący fragment to znów Jack próbująca zaimponować Riddickowi. Ten bez oznak większego zainteresowania daje jej ręką znak by uważała na górę (wjeżdżają pod szkielet). To jest kolejna klamra gdyż jest to to samo miejsce w wąwozie gdzie Jack zostanie zaatakowana z góry przez bestie.  Noc sądu - zaczyna się zaćmienie, bestie rozpoczynają żer. Ciekawe że Imam określa ich widok z przerażeniem imieniem Boga (Allah) a Riddick z zachwytem - Beatiful. Nie jest to oczywiście przypadkowe. Chwilę później ginie Shazza, co Riddick przyjmuje z zadowoleniem. Scenę kończy majestatyczny wylot bestii15 co Riddick komentuje stoicko Like I said, it ain't me you gotta worry about   Bunkier - tak jak stwierdził Riddick do Fry w ""Budowaniu poodziałów"", psychopatyczna rodzinka zaczyna się rozpadać. Jack dostaje dziecięcych objawów PTSD, Johns racjonalizuje (`You remember the boneyard?), Paris dostaje pierwszego ataku paniki, Imam traci kolejnego z minionów16   Narada wojenna - coraz mocniej zarysowuje się podział między Fry a Johnsem. Defacto jest to klamra sytuacji ""W głąb króliczej nory"", gdzie ponownie Fry optuje za samobójczą misją. Johns by ratować co się da próbuje grać jeszcze kartą Jack ale Fry stawia już wszystkie swoje karty na Riddicka przeciwko Johnsowi. To początek upadku Johnsa - głos bestii zza ścian wyraźnie to zaznacza, on od tego momentu powoli zaczyna tracić wszelkie skrupuły. Jedyną pozytywną postacią pozostaje Imam (pomimo utraty dwóch podopiecznych)  Droga do piekła - Riddick zostaje przewodnikiem ale nie ustaje w zasiewaniu podziałów. Nieprzypadkowo wspomina o krwi i ranach w sąsiedztwie Jack - to jest gra obliczona na wzbudzenie poczucia winy jak również pułapka na Johnsa. Sam Johns podejmuje ostatnią próbę pokojowego ostrzeżenia Fry - He'll leave all of you, bezskutecznie. Przy kolejnej próbie będzie próbował ocalić innych już na swoich warunkach. Scena wyjścia24 jest ładną klamrą wcześniejszej ""Karawany"" - tyle że teraz to Riddick przewodzi a Johns i reszta robią za muły ;)  Upadek Parisa - choć to Paris inicjuje scenę to w zasadzie Jack jest katalizatorem ignorując wcześniejsze polecenie Imama by trzymać się blisko. No ale ona bez problemu twierdziła że jest w stanie zabić kilku ludzi. Panika Parisa (oraz jego egoizm) przypieczętowują jego los. Sama scena śmierci też jest ciekawie sfilmowana (może dać ogląd na duszę Parisa w oczach Boga), Riddick wedle zwyczaju napawa się dobrze zrobioną robotą  Przed wejściem do Gehenny - W Biblii są dwie straszne doliny, jedna z Psalmu 23 a druga to dolina Hinnom (czyli Gehenna), ta druga jest tu właściwsza z uwagi na opis Riddicka Canyon ahead (...) That's death row up there oraz z uwagi na powiązanie jej z składaniem ofiar z dzieci - o czym następnie. Bo co robi tutaj Riddick? Especially with the girl bleeding17. To jest ostateczna pułapka założona na Johnsa. Następnie mamy klamrę z ""Narady wojennej"" tylko że sytuacja tutaj się odwraca, to Johns przejmuje z powrotem pałeczkę lidera (przy okazji łamiąc słowo dane Fry) i rozbijając grupę jeszcze bardziej. Jego upadek jest już blisko  Upadek Johnsa - kolejna spokojna (do czasu) i ciekawa konwersacja pomiędzy Johnsem a Riddickiem  Johns wraca do swojej sprawdzonej strategii paktowania z diabłem, tym razem oferując mu ofiarę Six of us left, If we made it through the canyon and lost just one - tu słychać w tle dźwięk bestii, to znak że Bóg widzi i Johns przekracza granicę kolejny dialog w ciekawy sposób porusza istotę samej roli Szatana w dziele bożym Johns: Battle doctors decide who lives and dies, it's called triage. Riddick: You kept calling it murder when I did it - zabawne Riddick kontynuuje proces kuszenia - pokazuje zalety wynikające ze złożenia ofiary, podsyca nadzieje Johnsa. Ale w głosie już słychać szyderstwo Nice embellishment  Johns podejmuje decyzję You do the girl, and I'll keep the others off your back - jest skończony  następuje walka po której Riddick zostawia Johnsa na łasce boskiej sprawiedliwości, nim jednak to nastąpi pozwala sobie na całkiem sporą dawkę drwin You were one brave fuck before, I told you to ghost me. Nie zapomina oczywiście o delektowaniu się samym końcem    Wilk wraca do owiec - prosta scena z dwoma ciekawymi punktami  odpowiedź Riddicka na pytanie Imama o los Johnsa - Which half? To nie jest zwykłe nawiązanie do sposobu jego śmierci, to nawiązanie do słów Ja jestem Pan, ja cię uświęcam, ja zachowuję cię całym  Ostrzeżenie dane Jack Don't you cry for Johns. Don't you dare, nie żeby chodziło w jakiś sposób o Johnsa, po prostu te emocje cofają Jack pod protekcję przysługującą nieletnim, nie jest to w interesie Riddicka18.    Imam vs szatan - Imam postanawia pomodlić się wspólnie z Riddickiem. Riddick oczywiście ma lepsze rzeczy do roboty niż tracenie ją na czynność która jest mu obojętna - Imam: It's painless, Riddick: It's pointless. Imam na swoje nieszczęście nie łapie aluzji i próbuje Riddicka nawracać19. Ten w odpowiedzi wytacza najcięższe działa w postaci problemu zła. Zasiewa też zwątpienie jeśli chodzi o ufność którą Imam pokłada w Bogu How much faith do you have left, Father?   Dolina Mordu - śmierć dookoła, nawet bestie pożerają same siebie. Przejście przez nią jest testem. Riddick narzuca tempo by wymusić sytuację w której pozostali będą musieli decydować o życiu lub śmierci swoich towarzyszy.  co ciekawe kiedy Jack błaga Riddicka o ratunek ten nie reaguje do czasu aż na ratunek Jack nie rusza Fry. To daje do zrozumienia że cała sytuacja jest testem dla Fry a Jack robi jedynie za narzędzie. Mimo to Jack, Imam i Fry pozytywnie go przechodzą kiedy zaczyna padać Riddick przypuszcza końcowy atak na wiarę Imama So, where the hell's your God now?. Chwilę później widzimy Imama pogrążonego w bezsilnym lamencie    Negocjacje z Bogiem - Riddick w deszczu wstępuje samotnie na wzniesienie otoczony hałasem bestii. Tu się toczy jakiś  dialog którego treści nie jesteśmy świadomi. Poznajemy tylko jej ostatnie zdanie/żądanie - We can't make it20 Zostaje ono wysłuchane, sekundę później Bóg zabiera ostatniego podopiecznego Imama  Grobowiec - Riddick zamyka pozostałych w grocie skalnej opuszczając ich (dokładnie tak jak przepowiedział Fry Johns). Jest to ostateczna próba wiary  mimo wszystko zdarza się cud, w momencie gdy cała nadzieja umiera Jack zauważa emitujące światło larwy na sklepieniu jaskini. Przypadek? Nie sądzę     Ostatnie kuszenie Fry - powoli zbliżamy się do końca, uzbrojona w nowe źródło światła podejmuje próbę przebicia się do statku ratunkowego (o dziwo bez większych problemów ze strony bestii). Riddick nie powiedział jednak jeszcze ostatniego słowa  konwersacja pomiędzy Fry a Riddickiem zawiera parę ciekawych fragmentów. Mianowicie w pewnym momencie Fry proponuje Riddickowi odkupienie There' gotta be some part of you that wants to rejoin human race. Riddick zgodnie z prawdą odpowiada że to nie leży w jego zasięgu Truthfully I wouldn't know how - on nie jest częścią rodzaju ludzkiego, prawdopodobnie nie dysponuje nawet wolną wolą. sama Fry jest słaba - nie chce sama wracać z powrotem po innych, chce użyć Riddicka na sposób Johnsa, problem polega na tym że nie jest Johnsem You don't know anything about me, I will leave you here  kuszenie wkracza w ostatnią fazę, Riddick gra na emocjach które czynią Fry słabą No one's gonna blame you. Save yourself Carolyn, osiąga prawie kompletny sukces Good girl  W tym momencie ponownie słychać głos bestii z oddali, Bóg widzi i Bóg ostrzega (klamra do ""Upadku Johnsa""). Fry dokonuje rachunku sumienia i w ostatnim akcie podejmuje walkę Listen to me! I'm the captain of this ship and I'm not leaving anyone on this rock with those fucking things. Riddick przegrał bitwę choć jeszcze nie wojnę (agresywne Shut up!) postanawia zaoferować Fry ostateczny układ - krew za krew, jej duszę za ocalenie pozostałych. To jest podstęp ale taka jest cena słabości. Gdy Fry godzi się na to, to po raz pierwszy w tej scenie Riddick ściąga okulary i ocenia ją surowymi oczyma How interesting     Ocaleni - po zawarciu paktu Riddick wraz z Fry wraca po resztę. Ciekawa jest różnica w atrybucji komu zawdzięczają ocalenie - Imam There is my god Mr. Riddick vs Jack I have no doubt (do Riddicka). To ważne bo pokazuje że o ile próba Imama kończy się pozytywnie to próba Jack dopiero się zaczyna  Śmierć/ocalenie Fry - ta scena przez wielu jest uważana za niejasną/bezsensowną (czy zabija ją Riddick? Co znaczą końcowe słowa Riddicka?) ale tak nie jest. W tym świecie prawa boskiej sprawiedliwości są niewzruszone a Fry związała się paktem z Riddickiem oddając siebie w zamian za pozostałych. Jej przeżycie nie równa się ocaleniu. Po kolei:  jeśli Fry pozostała by z resztą (i odleciała) to automatycznie oznacza to zwycięstwo Riddicka gdyż zaciągniętego zobowiązania nie byłaby w stanie wyrównać - teraz czy w przyszłości. Ale wolą Boga jest zostawienie Fry furtki. Fry decyduje się wrócić po Riddicka by go uratować. Odnajduje go, pomaga mu i kończy słowami I said I'd die for them, not you. Tym sposobem spłaca swój dług i kończy wolna. Chwilę później ginie21   Not for me - słowa które Riddick wykrzykuje z żalem są przyznaniem się do klęski. One są skierowane do Boga    Opuszczenie planety - całość tej sceny to przygotowanie gruntu pod sequel którego niestety nie dostaliśmy. Imam potwierdza swoją ufność Bogu22 co nie jest zaskoczeniem. Zaskoczeniem są słowa Jack (dla samego Imama) I know where I start. Jack powoli wchodzi w dorosłość gdzie będzie sądzona już za swoje czyny. Już po składzie załogi widać zalążek boskiego planu - Imam jako źródło prawości i oddania Bogu vs Riddick który nakłania do złego. W hipotetycznym sequelu stawką jest dusza Jack.  Mroczna Furia (opcjonalnie) Nie jest to prawdopodobnie sequel jaki Twohy miał pierwotnie na myśli kręcąc Pitch Black. Z jakichś powodów zdecydował się nakręcić Kroniki... ale mają one poza Riddickiem niewiele wspólnego z wątkami z pierwszego filmu. Mroczna Furia jest prawdopodobnie ukłonem dla widzów którzy zrozumieli przekaz oryginału i musieli zauważyć że wątek Jack pozostał zawieszony w powietrzu w końcowych scenach. Mimo to z powodu ograniczeń budżetowych (czas trwania) + wymogu retconowania z historią z ""Kronik"" w całej animacji są wg. mnie tylko trzy sceny warte uwagi - początkowa + końcowa gdyż ładnie dopinają wątek wejścia Jack w dorosłość oraz dialog Imama z Jack zaraz po odłączeniu się od nich Riddicka (około środka)  Junner trzymający Jack pod muszką i Riddick negocjujący warunki z kapitan Chillingsworth. To co jest ważne to uświadomienie sobie faktu że Jack cały czas uważa Riddicka za pewien pierwowzór zbawiciela (w końcu to on uratował ich z pustyni). Riddick gra na tych emocjach okazując Jack że nikt w tym świecie nie jest warty zaufania, praktycznie zgadzając się na jej śmierć w jej obecności. To jest przygotowanie pod akt końcowy - żeby czyn Jack miał pełną wagę ona sama musi doświadczyć na sobie jego konsekwencji  Dialog Imama z Jack po odłączeniu się Riddicka Jack: We've got to help him Imam.  We can't help him if we leave na co Imam trzeźwo odpowiada Sometimes that is exactly how it works. To jest nie-wprost nawiązanie do śmierci Fry i stanowi gorzki komentarz do emocjonalnego przywiązania Jack do Riddicka którego nie potrafi zmienić Imam  It is over - we have survived - ostatnia scena to ostateczna pułapka na Jack. Całość jest mocno surrealistyczna, nawet kolory przybierają odcień krwi. Riddick znów obserwuje całość swoimi oczami (bez gogli). Tu panuje surrealizm - kapitan Chillingsworth pojawia się zupełnie przypadkowo w szalupie ratunkowej którą wybrał Riddick i co więcej strzelając mu prosto w twarz nie czyni mu żadnej widocznej krzywdy. Ale to nie o nią tu chodzi - ostateczny akt należy do Jack pod którą cały ten teatr (test) został ustawiony  Imp(ressive) Jack dokonuje swojego pierwszego morderstwa z zimną krwią co dość sarkastycznie komentuje Riddick. Jego rola w tej bajce jest skończona - Jack staje się w pełni odpowiedzialna za swoje czyny i wchodzi w dorosłe życie z morderstwem na sumieniu23   Podsumowanie Tak więc drogie dziatki warto czytać Biblię nawet będąc ateistą bo inaczej można stracić wiele z przekazu braci w wierze. Wesołych Świąt! Przypisy   Strong survival instinct. I admire that in woman - końcowa scena kuszenia Fry przy statku ratunkowym, jest to klamra do sceny z odpaleniem członu pasażerskiego co przed czym powstrzymał ją Owens na samym początku filmu. Tak Riddick określa całą ferajnę w scenie gdy poddaje próbie Fry (rozmowa na statku ratunkowym)  Age of accountability - warto sugerować się podejściem z islamu + judaizmu gdyż są najbliższe temu czym inspirował się Twohy. Sam wiek nie jest nigdzie na sztywno wzmiankowany w Biblii - chodzi o świadome odróżnienie dobra od zła   One rule. Stay in the light - słowa Riddicka do Johnsa w momencie jego upadku  He die fast. If we any choice that's way we should all go out - Riddick tłumaczący Jack okoliczności śmierci Johnsa  Don't you touch that handle - słowa Owensa do Fry niedługo przed śmiercią, nie mają one większego sensu w kontekście sytuacji Ten tekst jest dopięty klamrą przez Riddicka w ostatniej scenie kuszenia Fry - How interesting, czyli jednak jest możliwość zachowania moralnego kompasu w świecie go pozbawionym. Liczba kamieni zgadza się z liczbą próbowanych osób z psychopatycznej rodzinki. Przypadek? Nie sądzę ;) Scena zabójstwa jest też klamrą dla śmierci Shazzy później. Wystarczy zwrócić uwagę że Paris + Jack są dokładnie w tym samym miejscu i +/- tym samym układzie co w momencie śmierci Shazzy później w filmie. Nie do końca rozumiem co reżyser chciał przez to powiedzieć ale śmierć Shazzy jest najmniej wyjaśniona z punktu widzenia logiki filmu. Jest całkiem możliwe że całe zabójstwo zostało zatajone przed resztą ekipy gdyż nikt o nim później nie wspomina - a wtedy mamy to nawiązanie  Dialog Jack z Riddickiem jest ciekawy również pod innym kątem. Jeśli potraktować Pitch Black, Mroczną Furię i Kroniki jako spójną całość to on w zasadzie przepowiada cały życiorys Jack do momentu ucieczki z więzenia w Kronikach Najśmieszniejsze jest to że teksty jakich używa Riddick w prowokacji okazują się być prorocze jeśli chodzi o koniec Johnsa. Całe I want you to remember this moment jest klamrą przy jego upadku W tej scenie wiele rzeczy wydaje się przypadkowych ale tak nie jest. Riddick jest świadomy obecności Jack i odkrywając generatory uruchamia mechanizm otwarcia wlotów światła do magazynu rdzeni co w następstwie zdarzeń doprowadza do śmierci podopiecznego Imama. W zasadzie jest to pierwszy atak wymierzony w Imama ale na tyle subtelny że nikt go nie wiąże z Riddickiem Johns jest przy tym przekazaniu pasa i jest najprawdopodobniej świadomy tego co zaszło biorąc pod uwagę że niedługo później zaczyna ponownie ostrzegać Fry przed Riddickiem przyznając że nie potrafi już go kontrolować  I've been meaning to catch up with you alone, unrestrained  CGI tej sceny jest tak dziwnie zrobione że można powiedzieć że to anioły wzbijają się do nieba. Może przypadek Co ciekawe nawet tu Riddick działa na niekorzyść grupy, ściągając swoją ucieczką bestię w sam jej środek Ciekawa jest reakcja Imama na to stwierdzenie (zdegustowanie połączone z rozczarowaniem) - ta reakcja nie jest bez powodu, w Islamie kontakt z krwią menstruacyjną unieważnia stan rytualnej czystości wymagany do przeprowadzenia obowiązkowych modlitw. Biorąc pod uwagę że Imam nie wie od kiedy ten kontakt mógł mieć miejsce to wg. Koranu wszystkie jego modlitwy do tej pory (czyli w zasadzie początku filmu) są nieważne i muszą zostać powtórzone - biorąc pod uwagę kontekst sytuacji to dość spore wyzwanie jak dla pobożnego muzułmanina Klamrą do tych słów jest początkowa scena w Mrocznej Furii gdy Junner trzyma Jack pod muszką a Riddick go prowokuje. Ostatecznie rezygnuje ze słowami Now just ain't the time kiedy Jack okazuje typowo dziecięcy strach Co ciekawe z uwagi na to że Riddick nie może kłamać nie może też zanegować bezpośrednio wiary w Boga - I absolutely believe in God and I absolutely hate the fucker  O co naprawdę chodzi w tym zdaniu ładnie pokazuje klamra w Mrocznej Furii gdy Jack po raz pierwszy własnoręcznie zabija człowieka - Yeah, we made it  Interesujący szczegół - Fry zostaje porwana w powietrze i znika. Praktycznie wszystkie pozostałe osoby giną na ziemi i Riddick delektuje się ich końcem. Jedyne wyjątki to minion imama w dolinie i Shazza - może jej śmierć też jest swojego rodzaju darem łaski? Słowa monologu Imama potwierdzają moje podejrzenia z przypisu 17 With so much prayer to make up for - on wie że musi nadrobić salat od początku filmu gdyż nie był świadomy że Jack miała okres Symboliczny jest też sposób ustawienie tej sceny - Jack zabija Chillingsworth strzałem w głowę z broni Junnera która była użyta w podobnym celu np. względem Jack na początku. Soundtrack w pierwszych kilkunastu sekundach tej sceny jest inny od całości. W 2006 Hybrid w albumie I Choose Noise popełnił kawałek Last Man Standing  gdzie w tle przewija się ten sam motyw choć w innym tempie. Może przypadek a może subtelny trybut - w końcu tytuł jak ulał pasuje do tego co się zaczyna dziać w kontekście sceny :)  Licencja Opublikowano na licencji WTFPL v2;"
"OK uważniej doczytałem w dokumentacji i pisze tam by zastąpić shuffle opcją: sample(x, k=len(x)). Po prostu od wersji 3.11 Pythona nie ma już shuffle... A czy shufle zwraca czy nie zwraca cokolwiek to pewnie zwraca więc twierdzenie ""Bo shuffle nic nie zwraca tylko mutuje obiekt."" Nie zbyt pomogło. Teraz użyłem sample i działa dzięki za pomoc from random import sample cards = [""J"", ""Q"", ""K""] print(sample(cards, k=len(cards)));"
"Konsulat SAP,  Salesforce, Power Platform albo coś podobnego. Robić spagetti low code i będziesz potem niezastąpiony :);"
"Cześć, Ostatnio mam dosyć rozmów z biznesem, definiowania user stories i później klepania tego wszystkiego tak, żeby story points się zgadzały. Chciałbym znaleźć jakąś pracę dla prawdziwego programisty, coś w czym nie zastąpi mnie łatwo bootcampowiec i będzie to jakiś zaawansowany software, ale nie dla jakiegoś korpo. Jakiego rodzaju projekty powiniennem szukać i czego się uczyć?;"
"No i widzisz, kolejny raz manipulujesz (wielokrotnie robisz to co zarzucasz innym). O tym, ze pierwszy raz w tamtym poscie gdzie chciales mi udowodnic manipulacje uzyles okreslenia gleboka w stosunku do korekty kazdy moze sie przekonac. W tym watku wczesniej pojawialy sie takie okreslenia jak (uwaga, stosuje cudzyslow bo to cytat) - lekki ""kryzys"", korekta, kryzys. I ci wytlumaczylem, ze nie slowa ze kryzys zrobilem lekka korekte, tylko z wyrazenia lekki ""kryzys"". W jakim celu niektorzy stosuja slowo ""kryzys"" (w cudzyslowie), a niektorzy potrafia napisac kryzys bez cudzyslowa niech kazdy sam oceni,  Tutaj musze uderzyc sie w piers, bo uwierzylem ci na slowo ze rynek cofnal sie o ~1.5 roku, a nawet z twojego zestawienia ofert pracy wynika, ze cofnal sie o 4 lata (ostatnia tak niska liczbe ofert pracy mielismy na pcozatku 2020 roku!). Pisanie o 1.5 roku to oczywiscie twoja kolejna manipulacja zeby negowac obecny kryzys.  To nie ja zaczalem porownywac jak przebiega obecny kryzys z kryzysem dotcomow, ty zaczales nawiazywac do tego ze tam cofniecie bylo o 6 lat, a nie 1.5 i dlatego tamta sytuacja byla kryzysem. I ze tam po kryzysie zaczelo sie odbijanie od dna, wiec teraz tez bedzie :) Ja odnioslem sie poczatkowo tylko do tego jak opisywane sa te wydarzenia. Cofniecie sie o 6 lat to kryzys, a cofniecie sie o 4 lata (nie poltora jak probowales tutaj czytelnikow zmanipulowac) teraz to tylko lekka korekta. Struktura owszem inna, bo tamto byl kryzys gieldowy, a teraz mamy kryzys liczby ofert/zarobkow IT, a nie krach na gieldzie (mamy krach w liczbie ofert i zarobkow).  Konsekwencja bylo to, ze przez lata nie wrocilismy do poziomu z gorki (tzw. eldorado). Twierdzisz ze teraz szybko do tego wrocimy? Podobienstwo przebiegow widac na mojej profesjonalnej analizie technicznej, gdzie zaznaczylem wazne punkty na wykresie i pokrywaja sie one niemal w 100% z aktualnym wykresem zarobkow/liczby ofert pracy.  Bo ty niestety nie potrafisz myslec wielowymiarowo, to jest twoj najwiekszy problem jaki zauwazam w tym watku. Powolne odbicie patrzac na liczbe ofert i stawki moze bedzie. Tylko ja pisze o tym, ze jest zle a bedzie jeszcze gorzej (fakt, nie opinia) w szerszym kontekscie. Juz to kilka razy wspominalem i ja i @Misiek_Uszaty. Koszty zycia w Polsce beda rosly, koszty uslug beda rosly, koszty mieszkan beda rosly, minimalna placa bedzie rosla. To wszystko powoduje ze realne zarobki w IT beda spadac (czyli uwaga, bedzie jeszcze gorzej niz jest teraz, pomimo tego ze suche zarobki moga rosnac). I w takiej sytuacji co mi z tego ze stawki urosna zalozmy w przeciagu najblizszego roku o 5-10% (bardzo optymistyczne zalozenie, nie spodziewalbym sie w 2024 jakiegokolwiek wzrostu w tym zakresie, a raczej dalszych spadkow), jesli w tym samym czasie koszty zycia wzrosna o kolejne 15%?  https://inhire.io/media/reports/inhire-it-market-snapshot-q1-2024-pl.pdf Masz tam wypowiedzi ekspertow - nie randomow (rajmonkow, warankow i tym podobnych) na forum - ktorzy dalej mowia o tendencji spadkowej na naszym rynku. Bo spada i liczba ofert i zarobki, drugi kwartal z rzedu! Przeciez spadek ofert widac nawet w twojej tabelce xD  To, ze aktualnie AI nie zastpi 100% programistow to jest oczywiste. Ale moze zastapic klepaczy kodu (a i seniorzy czasami takimi sa). Taki senior-lead wsparty AI nie bedzie potrzebowal gromadki juniorow/midow bo proste taski zaklepie pod jego nadzorem AI, a on tylko doszlifuje co trzeba, a calkowicie samodzielnie bedzie zajmowal sie trudniejszymi taskami i pilnowaniej architektury systemu. Zamiast zespolu skladajacego sie z:  uber senior/tech lead senior 2x mid 2x junior  Zostanie:  uber senior wsparty AI mid (zeby sie doksztalcac i w przyszlosci firma bedzie miala drugiego uber-seniora)   Wyzej ci wyjasnilem ze nie potraisz myslec wielowymiarowo i spojrzec szerzej - ale po krotce, Polska goni Zachod pod katem zarobkow/jakosci zycia, to nie te czasy gdzie wyjzdzajac za granice na magazyn miales 10x wieksze zarobki niz u nas. To jest to wyplaszczenie o ktorym mowie. I tak samo jak zarobki programistow na Zachodzie sa wyplaszczone, tak i u nas bedzie - bo dlaczego mialoby byc inaczej? Byly tak wysokie w porownaniu z innymi branzami u nas bo kapital lecial z Zachodu. Wyplaszczenie spowoduje ze bedzie tylko gorzej. To ja teraz zastosuje lubiane przez ciebie argumentum ad absurdum. Jak twierdzisz, ze nie bedzie gorzej (co rozumiem przez gorzej wyjasnilem wyzej w tym poscie i chyba nawet w pierwszym swoim poscie w tym watku) to rozumiem ze wedlug ciebie w IT w Polsce bedzie tylko lepiej i zarobki programistow beda rosly porownujac do wzrostu kosztow zycia i beda rosly proporcjonalnie szybciej niz rosnie srednia zarobki calego spoleczenstwa? Bo jak na to pytanie ktos odpowiada, ze tak nie bedzie, to znaczy ze bedzie gorzej, a nie lepiej :)  Czy tego chcesz czy nie to jest analiza techniczna. To ty zaczales przywolywac szczegoly i porownywac oba te kryzysy (tak, oba kryzysy) pod katem tego o ile lat cofnely branze i ze po kryzysie byly odbicia. To tylko pokazalem ze to co teraz uwazasz za odbicie zaraz moze sie przelozyc na jeszcze wiekszy kolaps, dezintegracje, krach, zapasc, implozje tak jak bylo w bance dot-comow. Ja to przywolalem tylko zeby zwrocic uwage na dziwna rozbieznosc w nazywaniu obu tych sytuacji. Dot-comy to gleboki kryzys bo cofnely branze o 6 lat, a aktualny sytuacja to lekka korekta, bo cofnela branze tylko o 4 lata (a nie wiemy gdzie sie skonczy).;"
"testerzy w niektórych firmach to jedyne osóby, które tak na prawdę wiedzą jak działa system i potrafią z niego w pełni korzystać. tego trzeba się samemu wyuczyć pracując rok czy dwa w danej firmie i kto ma takich ludzi niby zastąpić? programiści którzy proszą testerów żeby im wytłumaczyli gdzie jest button x w zakładce y, a najlepiej gdzie jest zakładka y bo tego też nie wiedzą, a zarabiają dwa razy więcej. AI tez nie zastąpi testerów, bo potrzebna jest żywa osoba, na którą będzie można zwalić winę, że coś nie zostało przetestowane, a weszło na prod;"
"To tylko złudne myślenie, nie ma ludzi których nie da się zastąpić. Byłem świadkiem jak zwalniano ludzi co pisali w firmie produktowej najważniejsze serwisy i funkcjonalności i robili w niej +5 lat. Niektóre systemy znali od podszewski. Musisz wejść na wyższy poziom abstrakcji, ale takiego managera/dyrektora co zarządza całym pionem mało to interesuje. Przychodzi decyzja z tzw. góry i się zwalnia.;"
"Dużo mówi się o tym że GPT zastąpi pracowników umysłowych, tymczasem roboli już się zastępuje: https://www.bbc.com/news/technology-67163680 Już za kilka lat tego typu pan powita ciebie w stacji kontroli pojazdów:  It's over dla robola!   screenshot-20231023083643.png (750 KB) - ściągnięć: 3;"
"Przełom będzie wtedy, kiedy koszt robota będzie niższy niż człowieka, a wykonają porównywalną pracę, czyli niedługo. Dla krajów żyjących z zapewniania taniej siły roboczej, jak np. Indie, może to oznaczać kłopoty, ponieważ bogatsze państwa nie zawahają się zastąpić tanich robotników automatami.;"
"Robie remont w domu i tak mysle, ze najtrudniej bedzie zastapic fachowcow od budowlanki -> moze i nowy dom uda sie wydrukowac, ale pozniej jakies zmiany aranzacji wykonczenie itp. to jeszcze dluga droga.;"
"Wiecie kogo najszybciej zastąpią maszyny? Pracę umysłową w każdej niemal dziedzinie - księgowych, programistów, ekonomistów i być może mnie radców prawnych. Być może nawet niebawem lekarzy. Natomiast najwolniej pracowników rzemieślniczych i fachowców z fachem w ręce a nie głowie. To jest bezpieczna przystań jeszcze na wiele lat.;"
"Dlaczego nawet za 100 lat lekarze będą ludźmi  a robole zostaną zastąpieni przez roboty? Słowo klucz to ODPOWIEDZIALNOSC. Jak lekarz algorytm skopie sprawę i ktoś umrze to nikt nie będzie mógł ponieść winy (nie wiadomo jak naprawdę te algorytmy działają, a zbiory uczące są zbyt duże). Podobnie jest z innymi dobrze płatnymi zawodami takimi jak prawnik czy pilot samolotu. Od tych ludzi wymaga się żeby ponieśli konsekwencje swoich działań. Pilot jak się pomyli to umrze. Lekarz może stracić prawo wykonywania zawodu a prawnik reputacje (bardzo ważną w tym zawodzie). AI dla mózgowców i jajogłowych to będzie rodzaj sekretarki, streści Ci newsy, zrobi executive summary emaili, przypomni o wizycie u dentysty i załatwi proste sprawy jak zapłacenie rachunków za telefon czy rezerwacja lotu samolotem. Ale interakcja z drugim człowiekiem nie zniknie. Wyobraźmy sobie że firma A wypuszcza algo-lekarza, taki algo-lekarz nie będzie mógł wystawiać recept - bo gdyby mógł to zaraz znajdą się cwaniacy (hakerzy) którzy sprawią że będzie rozdawał testosteron czy inne sterydy, morfinę i inne ciekawostki na prawo i lewo. W takim kraju jak Polska od razu pojawiły by się wały, ludzie by sobie wysyłali sposoby jak zmusić algo-lekarza do wystawiania lewych L4ek... Podobnie z prawnikiem, algorytm może streścić i przypomnieć aktulanie obowiązujące przepisy. Przeanalizować historię podobnych sporów czy nawet wyjść z nowatorską argumentacją ale to człowiek musi zadecydować. Na przykład argumentacja A by działała ale ponieważ klient jest politykiem to nie można jej użyć bo by negatywnie wpłyneła na jego postrzeganie (np. dał się zaszantażować i przez rok spełniał żądania szantażysty). Nie wspomnę już o tym że prawnicy czasami muszą naginać prawo (np. zakładać nielegalny podsłuch lub wynająć detektywa...). Natomiast robol - im mniejsza odpowiedzialność tym prościej go zastąpić - myślę że najpierw zobaczymy robota który układa płytki w łazience (obecny stan techniki) niż algo-lekarza.;"
"Jeśli AI zastąpiłoby w pełni programistów i architektów to kwestia możliwości zastąpienia wszystkich innych zawodów to kwestia max paru miesięcy.  Nic nie stoi na przeszkodzie żeby jeden lekarz zatwierdzał automatyczne diagnozy, co innego z takim chirurgiem. I tak w większości przypadków odszkodowanie pokryje ubezpieczenie a nie poleci z kieszeni odpowiedzialnej osoby. Wolałbym się poddać AI które podaje prawidłowe diagnozy w 99% niż lekarzowi ze znacznie niższą skutecznością który poniesie odpowiedzialność za swoje błędy i w nietypowych przypadkach dwóch latach przekierowywania między różnymi specjalistami żeby w końcu dostać trafną diagnozę.;"
"Wydaje mi się, że jeśli będziesz się ciągle rozwijał i uczył nowych rzeczy, to będziesz lepszy od innych i nie będzie się dało Ciebie tak łatwo zastąpić jakimś AI, biblioteczką, albo np. piekarzem, który zrobił bootcamp w 2 tygodnie. Poza edukacją, możesz spróbować dać innym jakąś wartość - np. w postaci artykułów na blogu, własnych bibliotek i frameworków, darmowego lub płatnego oprogramowania, jakiegoś kursu, itd. Każda z tych rzeczy buduje Twoją markę osobistą i jeśli choć za jedną lub dwie rzeczy z tej listy weźmiesz się naprawdę porządnie, to już jesteś do przodu przed 90% koderów, bo większość nie robi nic w ramach rozwoju poza pracą.;"
"BTW nie tylko Wordpress. Np. tyle się mówiło, że narzędzia no-code zastapią programistów, skoro każdy będzie mógł wyklikać. A wszedłem teraz na grupę ludzi zajmujących się Wixem i ten no-code tool, dzięki któremu podobno każdy może wyklikać stronę, w rzeczywistości jest źródłem kolejnych problemów do rozwiązania. Np. ludzie piszą, że:  ktoś dodał slidera, ale nie może połączyć tego z danymi ktoś chce zintegrować z tym Wixem jakąś usługę do drukowania online komuś coś się źle wyświetla.  W programowaniu tak samo. Jak powstaje nowy tool / libka / framework, to jedne problemy rozwiązuje, ale generuje dziesiątki innych, więc programiści mają więcej do roboty, a nie mniej.;"
"@elwis: Jasne, że ""aktualny kryzys"" może zostać zasypany kolejnym dodrukiem kasy. Jednak w jakiejś tam perspektywie on nastąpi. Nie mam wielkich obaw, że sobie nie poradzę. Mam spore doświadczenie, dość szeroką i aktualną wiedzę, w tym z aktualnie modnych obszarów jak ML. Nie sądzę też, że na aktualnym poziomie rozwoju, AI zastąpi programistów. Jeżeli zwiększy ich efektywność, to spadną koszty software, więc zwiększy się popyt. Może to zwiększyć barierę wejścia do IT, bo trzeba będzie się wykazać czymś więcej niż klepaniem banalnego kodu. Sam właściwie od początku kariery pchałem się w nowości, współpracowałem z biznesem, potrafię gadać z klientami i ogólnie dowieźć projekt, co jest dość mocno doceniane. Natomiast ""stabilność"" zawsze opierałem bardziej na zdolności spadania na cztery łapy, niż okopywaniu się na aktualnej pozycji. Zwyczajnie ciekawi mnie, jak obecnie widzimy czynniki, które wpływają na naszą wartość na rynku pracy.;"
"Nie rozumiem tego ciągłego odkłamywania rzeczywistości. Im mniej ludzi wie o branży tym lepiej. Dlatego mi nie przeszkadza jak ludzie gadają że zaraz AI mnie zastąpi lub ze spawacz zarabia więcej. Im mniej ludzi wie, pcha się do nas i próbuje ingerować tym lepiej. Zamiast szpanu powszechnym spuszczaniem się nad naszym stanem wole jeździć 4-6 razy w roku na wakacje, serwisować auto w ASO, mieszkać w dużym domu,  jak utopie komórkę czy zepsuje się lodówka to kupić z marszu nowy sprzęt za gotówkę czy pracować w losowych częściach świata. Dlatego moje oświadczenie jest takie że eldorado nie było, nie ma i nie będzie a ja ledwo wiążę koniec z końcem ale staram się myśleć pozytywnie. Mowa jest srebrem lecz milczenie złotem.;"
"Informatyka jest jak mapa, odkrywa się po kolei kolejne jej części. W tej chwili prawie nic się nie wymyśla. Wybrałeś ścieżkę WEBDEV, tutaj  będziesz miał problem z dużą konkurencja na rynku pracy. Technologie które poznałeś mogą się wkrótce zdewaluować, tzn. zostaną zastąpione innymi nowszymi. W życiu chodzi o ""chleb"" to znaczy nikt nie chce pracować za darmo. Jeżeli wybrałeś ścieżkę programisty powinieneś większy nacisk kłaść na angielski i algorytmikę. Jeżeli jesteś typem introwertyka (klapki na oczach, jeden problem naraz) może coś uda ci się osiągnąć w programowaniu. Idź na studia jeżeli nie masz pomysłu co dalej ze sobą zrobić i jesteś mało kreatywny. Ćwicz kompetencje miękkie (przyda się żeby przejść rekrutacje HR), prace w zespole, jeżeli uda ci się podjąć rękawice i zrobić karierę miej na uwadze ze po 40+ roku życia zajmiesz się głownie zarzadzaniem i prowadzeniem młodzików.;"
"Nie potrzeba AI do tego. Od dawna istnieją biblioteki programistyczne, które pozwalają za pomocą jednego wywołania funkcji zrobić to, co zajęłoby ci np. miesiąc. Programiści jakoś nie ucierpieli od tego.  To chyba w idealnym świecie, gdzie tworzenie oprogramowania polega tylko na programowaniu, a programista tylko odbiera taski, klepie kod i wypluwa. Jednak w realnym świecie oprócz programistów istnieją też niekompetentni menedżerzy, klienci, którzy nie wiedzą, czego chcą, niejasne wymagania biznesowe, niedoprecyzowany bądź nieprzemyślany design czy kapryśni użytkownicy. Żeby AI zastąpiło programistów, musiałoby najpierw zastąpić całą resztę zawodów/odpowiedzialności/aspektów które są potrzebne do tworzenia oprogramowania.;"
"""Factfulness"", Hans Rosling Książka dowodzi, że świat jest lepszy niż uważa większość ludzi. Autor nakłania czytelnika do odejścia od koncepcji podziału świata na kraje rozwinięte i rozwijające się. A wszystko to przedstawia na zasadzie instynktów, które kierują ludźmi w opisie i poglądzie na świat oraz zmiany w nim zachodzących. https://lubimyczytac.pl/ksiazka/4860810/factfulness-dlaczego-swiat-jest-lepszy-niz-myslimy-czyli-jak-stereotypy-zastapic-realna-wiedza;"
"Dla mnie najtrudniejszy było przestac bić się po mordzie jak słyszałem niemiecki XD. A serio, to znalazłem mały projekt z Niemiec, nudziło mi się, więc zaproponowałem bym spotkania odbywały się w ich języku (tak nauczyłem się Tureckiego*). Daily z 15 min przerodziły się w 1,5h. Wszyscy byli jednak zadowoleni, ja miałem praktykę, oni kabaret XD Ogólnie polecam znaleźć sobie jakiś znajomych z danego kraju. Jest masa portali, na których można wymienić się kontaktami. Ja tak teraz utrzymuje swój niemiecki na w miarę znośnym poziomie. Inna opcja to konwersatoria, organizowane w większych miastach w szkołach nauki danego języka. Minus jest taki, że trzeba płacić, albo ilość miejsc jest ograniczona. Ostatni sposób, nie do końca polecam, bo moim zdaniem najmniej daje korzyści, to konsumowanie kultury w danym języku. Dla mnie nic nie zastąpi kontaktu z żywym człowiekiem i widząc jak szybki progres od ""0 do 100"" zrobiłem w niemieckim, a jaki w angielskim. Gdzie ang. to ""otoczenie się kulturą"", a niemiecki to rozmowy z żywym człowiekiem. Pierwszego uczę się 20lat, drugiego 4, poziom taki sam XD * taki żarcik :P;"
"Ani to ani to. Wybierz coś przy czym będziesz czuł się inteligentny, robił przy cutting edge projektach, mógł znaleźć własną specjalizację, ciągle się rozwijać i mógł się pochwalić oraz pośmiać z webdevowców, że robią proste i powtarzalne dziadostwo (aż w końcu chatGPT ich zastąpi)Czyli C++, Python razem z ML/AI, quantum computing(tu wyjazd za granicę niestety), algebra liniowa, cloudy(chociaż to też obcykane trochę) a najlepiej to wszystko na raz.;"
"Tak, tak robot murarza nie zastąpi...;"
Uważasz że ten robot będzie w powszechnym użyciu w Polsce w ciągu 15 najbliższych lat? Bo jakieś tam robot z tego co pamiętam był w 1860 roku na pokazie w USA - ii co nadal pracownicy kolejowi pracują na torach. A to już prawie 200 lat temu. On wspomaga dziś wbijanie ćwieków w szyny. A ludzie nadal tam robią. Stolarki na zamówienie nie zastąpi ani elektryki i kładzeni kabli w domach.;
"Ostatnio był pogrom w świecie C++, praktycznie wszystkie korpo typu Nokia, Ericsson, Motorola itp. robiły zwolnienia po 15 000 ludzi (nie mam info ile w Polsce), rzucono w ten sposób na rynek setki zdesperowanych osób szukających pracy, ogłoszenia o pracę są oblegane przez osoby z dużym skillem i doświadczeniem, ciężko się przebić, na pewno ciężej niż w innych językach Co do śmierci C++, w świecie embedded imo szybko nie umrze, jest to bardzo konserwatywna branża gdzie zmiany postępują dekadami, w tej chwili C/C++ mają wsparcie dla egzotycznych architektur, biblioteki praktycznie na wszystko, dobrą integrację z innymi systemami, coś tam się kombinuje z Rustem, ale moim zdaniem zajmie to co najmniej dekadę, dwie zanim domyślny język będzie zastąpiony w tym świecie (szczególnie w Polsce, w USA może być inaczej, ale to znowu czas zanim zacznie spływać legacy) Ale z drugiej strony embedded w Polsce nie będzie nigdy dobrym rynkiem pracy, to nie webdev, gdzie żeby przenieść produkcję wystarczy wynająć biuro i kupić 10 laptopów, tutaj często jest potrzebne drogie, wyspecjalizowane laboratorium, drogi sprzęt pomiarowy no i praktycznie najlepiej na miejscu mieć fabrykę produkującą sprzęt, stąd trend jest taki żeby nie przenosić embedded do Polski, a raczej już prędzej do Chin, gdzie na miejscu masz ludzi projektujących hardware i obok fabrykę produkującą płytki, wtedy koszt usuwania błędów jest rząd niższy, bo gdy ""spalisz"" płytkę przez błąd w sofcie to nie trzeba zamawiać innej z drugiego końca świata i czekać na nią dwa miesiące;"
"Znalazłem 2 narzędzia do projektowania interfejsu Flutter: https://flutterflow.io - UI, animacje, akcje, zapytania do API, przepływy, własne funkcje generowane przez AI https://flutterviz.com - bardziej czytelna, ale tylko projektowanie UI Ciekawe, czy niedługo takie narzędzia zastąpią programistów. Przeszkodą jest konieczność nauczenia się obsługi narzędzia i posiadania podstawowej wiedzy technicznej. Im więcej rzeczy da się wyklikać, tym większy próg wejścia, ale już niedługo AI pozwoli osobom nietechnicznym tworzyć proste aplikacje w 1 dzień. Flutter jest bardziej dojrzały, ma więcej komponentów i możliwości. Oprócz tego jest masa szablonów. Jednak w Compose pisze się przyjemniej. Chcesz dodać komponent, to tworzysz funkcję z adnotacją Composable. Ale samo zarządzanie stanem, animacje, nawigacja, wymaga pisania więcej kodu, większy próg dla początkujących, np. rememberSaveable by mutableStateOf(null). Compose dopiero raczkuje i brakuje wielu komponentów. Skąd u mnie ta niechęć do Fluttera - chyba dlatego, że dopiero wszedłem w Compose i wywracam wszystko do góry nogami. Pewnie byłoby inaczej, gdybym od razu uczył się Fluttera. Nie wiem, jak się w tym wszystkim połapać, by szybko przejść na Fluttera bez spędzania kolejnego tygodnia nad tutorialami.;"
"Mnie najbardziej rozwala fakt, że każdy stał się ekspertem od AI i twierdzi, że to już koniec branży X i Y nie mając pojęcia co mówi. Jedyna przełomowa rzecz w ChatGPT to fakt, że jest on wytrenowany i ogólnie dostępny. Dla osób pracujących nad LLM nie jest to jakaś przełomowa technologia, bo ona po prostu ewoluuje w czasie. Do zastąpienia ludzi brakuje jeszcze całkiem sporo. Człowiek często nie docenia swoich własnych umiejętności. Jasne, w jakiś segment gospodarki to uderzy i zmieni. Ale czy kompletnie wyeliminuje w najbliższym czasie? Wątpię. Dlaczego mamy ciągle kierowców tirów, pilotów samolotów, kasjerów w sklepach? Przecież do tego przymierzamy się od dobrych 10 lat. Także spokojnie, jeszcze czeka nas faza zamrożenia AI żeby rządy zdążyły to jakoś uregulować prawnie.;"
"Ludzie coś piszą o juniorach i stażystach. Tam zawsze był i będzie dramat, wyścig szczurów. Aplikując na fronta żeby się wybic trzeba znać backend, na backendowca najlepiej jeszcze znać podstawy frontu i coś w cloudzie podstawowego umieć zrobić. Ale kryzys zaczyna dopadać ludzi z doświadczeniem kilkuletnim i to jest conajmniej dziwne, że znika potrzeba zatrudniania specjalistów z kilkuletnim doświadczeniem. No i naprawdę to nie wiadomo jak GPT-4 wpłynie na rynek pracy. Z jednej strony może dojść do paradoksu, minie kilka lat, powstaną różne wtyczki, narzędzia i taki GPT-4 będzie miał dostęp do całego gita i edytora kodu i sam będzie klepał jakieś fragmenty cruda, a programiśći będą tylko nadzorować, łatać i robić trudniejsze techniczne taski, których GPT nie ogarnie. Software zacznie powstawać szybciej, powstaną nowe stanowiska, kolejna faza eldorado na rynku. Z drugiej strony jeśli GPT-4 będzie zbyt szybki i zbyt optymalny to z pewnością będzie w stanie zastąpić te 70-80% odpowiedzialnych za generyczne crudy i może do solidnej redukcji etatów na rynku, zostaną tylko programiści niskopoziomowi, nadzorujący/piszący kod AI i specjaliści do tasków nie-generycznych w crudach, z którymi GPT sobie nie poradzi :) Jedno jest pewne, zamiast uczyć się kolejnego frameworka do javy lub javascriptu może lepiej powoli dokształcać się z dziedziny sztucznej inteligencji, uczenia maszynowego i big data, tak na wszelki wypadek;"
generyczne crudy to chyba chatgpt zastapi spring data. To wojna maszyn na jaka zaslugujemy;
"Może też dlatego, że każdy widzi jaka jest średnia wieku programistów w polskich firmach i wie, że do emerytury nie będzie mógł pracować tak jak lekarz, więc chce jak najwięcej zarobić zanim młodzi go zastąpią.;"
"Zastanawiam się, czy nie jest już tak, że w dobie ChatGPT zadania rekrutacyjne przestały mieć sens jako sposób na sprawdzenie umiejętności programisty. ChatGPT może nie zastąpi jeszcze programisty jako zawodu, ale umie pisać krótkie programiki na podstawie promptu tekstowego, a zadania rekrutacyjne to dokładnie to: ""piszą ci prompt tekstowy i masz zaimplementować"". To robota dla AI. Nawet jak trzeba będzie poprawiać, to jeśli możesz mieć już szkielet zrobionego zadania w minutę, to i tak oszczędność czasu (szczególnie, że zadania rekrutacyjne to często 5 czy więcej godzin pracy za darmo). Więc chyba teraz wręcz należałoby korzystać z ChatGPT do robienia zadań rekrutacyjnych.;"
"Wygląda jakbyś nie odkrył Ctrl+Shift+B w przeglądarce. Fajne hello world, ale polecam PowerToys Run do zastąpienia tego kalkulatora i otwierania rzeczy;"
"Dzień dobry Państwu, Chciałbym zasięgnąć Waszej opinii na temat sensowności nauki programowania i zdobywania doświadczenia komercyjnego w modelu samodzielna naka lub kurs + robienie płatnych projektów pozyskiwanych na platformach typu upwork lub useme. Moja sytuacja wygląda tak, że w 2020 r poszedłem na kurs front endu z Reactem od Coderslab za 10k (tak, wiem - z perspektywy czasu utopione pieniądze, ale dużym plusem byla mozliwość zrozumienia sposobu myślenia prowadzących), po czy spędziłem ok 6 miesięcy szukając pierwszej pracy/stażu. Niestety, jak to było do przewidzenia, odbiłem sie od przysłowiowej sciany i odpadajac po kilku rozmowach rekrutacyjnych, a także wobec braku odzewu na znaczna czesc wyslanych CV i topniejących oszczędności ""wrocilem do korzeni"", zatrudniajac sie w mojej wyuczonej branzy (prawo i podatki). Moja aktualna sytuacja wyglada tak, ze na etacie zarabiam na czysto ok 6k, a z dodatkowego zrodla dochodu pasywnego wyciagam dodatkowe ok 5k miesiecznie, wiec nie jest zle, ale praca w zawodzie nie daje mi satysfakcji, wiec chcialbym ja zastapic (lub polaczyc) z praca w IT. We froncie kreci mnie koniecznosc kombinowania i rozwiazywania problemow zupelnie innej, niz prawnicza natury, przy czym caly swiat sie aktualnie cyfryzuje, wiec zmiany w tym kierunku maja charakter globalny i ten proces bedzie postepowac, powoli wymiatajac z rynku tzw. srednia klase biurowa, ktora wkrotce zastapia algorytmy lub Saasy. I tak czytam ten watek i zastanawiam sie, co myslicie o takiej idei, zeby:  Najpierw polaczyc prace na etacie z nauka (powtorka) materialow z kursu Front-endowego; Znalezc jakiegos nauczyciela, ktory pomoglby mi w rozwiazywaniu problemow, na ktorych poprzednio utknalem (np. optymalizacja czasu ladowania fetchy do apki pokazujacej pogode we wszystkich miastach swiata); Rozpoczac realizowanie projektow komercyjnych dla nieprofesjonalnych uczestnikow rynku, oferujacych zlecenia na portalach typu upwork/useme/[znacie moze jakies inne takie miejsca?]. Plynnie przejsc do ""atakowania"" firm na stanowisko juniorskie, majac powiedzmy 1 rok realizowania ww. projektow komercyjnych.  Zakladajac, ze przejscie od punktu 1-3 zajmie mi realistycznie ok 6 miesiecy, zanim bede mogl oferowac uslugi na portalach, czy te ww. portale maja w ogole szanse zapewnic mi jakikolwiek sensowny przychod rzedu powiedzmy 2-3k miesiecznie? Czy to jest nieustanna walka na smierc i zycie o jak najnizsze ceny? Zakladam, ze majac zestaw gotowych templatek stron typu Onepage z RWD, wymagajaca jedynie wdrożenia grafiki dostarczonej przez klienta, mozna nawet ""isc na wolumen"", biorac po kilkanascie takich malych gig'ow w miesiacu. Mam rowniez pomysl na szereg malych aplikacji dla biznesu, ktore moglyby poprawic sprzedaz i z ktorymi moglbym uderzac bezposrednio do firm (np. wirtualna choinka dla sprzedawcow dekoracji bozonarodzeniowych, na ktorej klienci mogliby zawieszac produkty z koszyka zakupowego lub (gdybym sie douczyl programowania na Ios i Android) apka VRowa dzialajaca na zasadzie augmented reality, sluzaca do wizualizowania na zywo kupowanych elementow wystroju wnetrz).;"
"@Miang Nie mówiłem akurat o pracy prawnika sensu stricto, chociaż Dentons od lat pracuje nad AI mającym zastąpić prawników niskiego szczebla i praktykantów w zakresie researchu prawnego. Na pierwszy ogień pójdą wszystkie polskie i hinduskie low costowe service centres, gdzie do pracy wystarczy angielski na poziomie B1 i umiejętność obsługi Outlook'a. @nowy_kret_2 Brzmi logicznie, ale w tym przypadku nie ma takiej mozliwosci @Terrored Zasadniczo nieruchomości, ale to był jednorazowy fart i scenariusz nie do powtórzenia na dzień dzisiejszy. Tak, trafiłem na 2 stacjonarne procesy rekrutacyjne wysyłając łącznie ok 30 CV, ale to było przed pandemią jeszcze, jakoś w 2019 r, a domyślam się, że wysycenie rynku juniorami od tamtego momentu weszło na kolejne szczyty. A co myślisz o robieniu projektów na upworkach/useme? U mnie jest ten problem, że w CV mam studia nietechniczne, więc ciężko będzie się wybić na samym github'ie. Wydaje mi się, że możliwość pochwalenia się chociażby drobnymi, ale jednak komercyjnymi projektami, powinna być wyróżnikiem.;"
"Ja bym się mocno zastanowił na twoim miejscu, czy warto iść  w IT. Coraz większa konkurencja, coraz mniej miejsc pracy, masowe zwolnienia na całym świecie i widmo, że w przeciągu iluś lat zostaniesz zastąpiony przez AI. Informatyka to obecnie najpopularniejszy kierunek studiów, a jakby tego było mało, to 25% Polaków myśli o zmianie branży na IT. Wyścig szczurów staje się coraz intensywniejszy. Zadaj sobie pytanie, czy chcesz brać w tym udział.;"
"@revcorey @znowutosamo Dzięki za odpowiedzi, chodziło mi głównie o to w co warto iść, bo jest to waszym zdaniem przyszłościowa technologia/branża/język i będzie łatwiej o pracę w tym, a jeśli by się pokrywało w jakimś stopniu z tym co do tej pory robiłem to byłby to fajny dodatek. To skąd się uczyć danej rzeczy to sobie już wygoogluje.  @bustard2 Myślisz, że będzie aż tak źle? Dobrym juniorom będzie ciężko znaleźć prace, a dobrym pracownikom ją utrzymać? Też nie jestem w sytuacji, w której stawiam wszystko na jedną kartę i jak się coś nie uda to na tym tracę i marnuje poświęcony czas na naukę. Wiedza z C#, Pythona czy nawet ostatnio Js w jakimś stopniu polepszy moją pozycje w obecnej pracy/branży. Zastąpienie przez AI to też chyba dyskusyjna kwestia, często można przeczytać komentarze, które twierdzą, że nie jest to możliwe w najbliższym czasie. A nawet jeśli to czy nie otworzy to jakiś nowych ścieżek kariery, którymi może warto się wcześniej zainteresować?;"
"O kur..a takiego Szymka H. nie znałem: https://lubimyczytac.pl/ksiazka/4882442/boskie-zwierzeta-nowe-wydanie A że niby tylko w K odklejeńcy... EDIT: Dodam cytacik dla leniwych:  EDIT 2: No k... muszę to zamówić, szkoda że przed wyborami nie dojdzie... domyślam się że była by do niezastąpiona skarbnica cytatow pałujących 2050...;"
"Z tych wymienionych tylko Google daje szansę na rozwój w przyszłości. Dropbox działa w sektorze w którym istnieje silna konkurencja (MS OneDrive, Google GDrive) która dodatkowo posiada pakiety biurowe. Jak dla mnie Dropbox to firma zoombie. Atlassian, JIRA nie będzie łatwa do zastąpienia, niemniej ruchy takie jak integracja zarządzania projektami w GitHub'ie czy to że Google ma własny system do ticket'owania raczej nie wróżą tej firmie dobrze. Zapewne pozostanie już na zawsze firmą jednego sukcesu (one trick pony jak mawiają amerykanie). Obecnie szukał bym pracy w obszarach związanych z AI, na przykład taka NVidia w Warszawie ma zapewnioną świetlaną przyszłość. Teraz jest taki czas że ciężko polecić, nie wiadomo gdzie będzie layoff a gdzie jest hiring freeze...;"
"@Czitels: To nie jest kwestia wyłącznie uciekania części programistów w pracę bardziej zdalną. Od lat na polskim rynku (a właściwie globalnym), brakuje programistów (i innych specjalistów IT). W projektach po firmach pracuje dużo ludzi za małe stawki - racja. Tylko bardzo duża część z nich pracuje w IT i tak z przypadku. Nie mam nic przeciwko zastąpieniu tych ludzi specjalistami z Indii, czy innego Wietnamu, o ile to faktycznie będą specjaliści. Problemy są 2:  Różnice kulturowe. To nie jest rzecz do pominięcia, bo jest parę rzeczy, które w naszych kulturach są bardzo różne. Z tego co widzę, jest to podejście do mówienia nieprawdy i zdolność do dawania i przyjmowania negatywnego feedbacku. Jakość tych specjalistów. W Bangalore, większość ""specjalistów"", z jakimi się spotkałem, to złapani po najniższej możliwej stawce przypadkowi ludzie. Sorki jak spotykam się z kimś, kto jest ""senior devopsem"", to spodziewam się, że nie popłacze się, jak go poproszę o napisanie skryptu i że będzie wiedział jak naskrobać Dockerfile. A mam przykład z życia, że te nadzieje mogą zostać łatwo pogrzebane.  Więc moje zdanie: Rynek otwiera się na specjalistów z całego świata, którzy są wraz z rosnącymi stawkami coraz bardziej zainteresowani życiem w Polsce. Warto pamiętać, że pomimo naszego płaczu, że w SV zarabia się więcej, to w sporej części to mniej, jest rekompensowane niższymi podatkami (b2b) i dużo niższymi kosztami życia. Oprócz Hindusów, jest też sporo ludzi z Ukrainy, Białorusi i Rosji (chociaż tych nasze urzędy wojewódzkie ostatnio nie kochają). Pracowałem też z ludźmi z Ameryki Południowej, bo dla nich również przyzwoity poziom życia i znacząco niższe ryzyko dostania noża w plecy jest atrakcyjne.;"
"Gorzej, najwyraźniej musi podać też numer księgi wieczystej. A do tego w tej alternatywnej rzeczywistości można brać kredyty bez dokumentów tożsamości. No, ale przynajmniej możemy zamknąć już teraz z pięć niedawno powstałych wątków. Jednak ChatGPT da radę niektórych zastąpić w pracy. ;);"
"Oraz wzięcia odpowiedzialności za to, co wypuszczają w świat. Wypuścić program z bugami? Spoko, wypuszczają, bo biznes kazał. Wypuścić coś, co będzie zamulało aplikację? Wypuszczą, bo ""nie było czasu"" zrobić dobrze. Wypuścić coś, co będzie powodowało realne straty pieniędzy z powodu długu biznesowego? Też wypuszczą, bo przecież ""biznes chciał szybko"". Wujek Bob ostrzegał przed takim podejściem, że o ile teraz programiści to święte krowy, to w końcu ktoś kiedyś może ich pociągnąć do odpowiedzialności za to, że wpuszczają zabugowany kod (@Riddle pamiętasz może, gdzie to było? Gdzie Wujek Bob mówił o hipotetycznym scenariuszu, że programista napisze kod, który spowoduje wypadek, a później hipotetycznie państwa wprowadziłyby regulacje zawodu i gdzie radził, żeby programiści jako cała społeczność zastosowała uderzenie wyprzedzające i żeby programiści sami przyjęli dyscyplinę i etykę zawodu).  Okej, ale jeśli programista to posłuszny klepacz, który klepie bezmyślnie to, co mu każą, to za chwilę będzie zastąpiony za pomocą AI (dobra, część programistów się zostawi, żeby byli operatorami ChatGPT). Samo klepanie kodu to coś, co już teraz można zautomatyzować i ChatGPT też potrafi robić ""grube ify"". To, co najbardziej wartościowe dla biznesu, to nie klepańsko kodu, tylko głębsze spojrzenie i umiejętność połączenia strategii z taktyką. A jeśli programista rezygnuje z głębszego spojrzenia, tylko spaghetti byle by zdążyć, normalka, to jego pracę dość łatwo się zautomatyzuje.  ""Potem"" to dojdą kolejne wymagania i znowu nie będzie czasu.;"
"Xamarin to przeszłość, zastąpił go .NET MAUI ale nie wiem czy jest gotowy na produkcję, docelowo ma zdaje się mieć możliwość integracji z react-native. Jak znasz już react/dart/c# i chcesz szybko zrobić appkę to wybór prosty. Jak zaczynasz od zera to stawiałbym na react-native. Flutter jest od google, a z doświadczenia wiem że wszystko od G to g.  Trochę się bawiłem MAUI i to że robisz appkę na wiele platform nie wyklucza korzystania z natywnych możliwości. Nie widzę żadnych plusów pisania odrębnych aplikacji na każdą platformę może poza wydajnością - pisanie pod konkretną platformę powinno dawać najlepsze rezultaty wydajnościowe i najbardziej natywny wygląd. Tak czy inaczej musisz dostosować aplikację pod każdą platformę żeby dostosować się do userów platformy którzy mają już pewne przyzwyczajenia.  Nie wiem jak sobie to planujesz, ale wiedz że praca w tle na androidzie praktycznie już nie jest możliwa. Aplikacje na androida od kilku wersji praktycznie nie mają już żadnej możliwości pracy w tle, zostają przypadkowo ubijane lub spowalniane i mają tylko możliwość krótkiego zareagowania na pusha z FCM lub synchronizacji w losowych momentach, zwłaszcza na samsungach, oneplus, huawei i xiaomi - https://dontkillmyapp.com/ Apka może robić coś konkretnego tylko jak user na nią patrzy i utrzymuje z nią interakcję. Coś takiego jak crawler lepiej robić na serwerze;"
Czyli tak skrótowo - predykcja w tworzeniu software nie ma ekonomicznego sensu bo wszystko można zastąpić testami na produkcji?;
"A kto nie ma? Poziom nauczania informatyki w szkole jest żałosny Ja się uczyłem w tym wieku biorąc proste zlecenia przez neta i bezpośrednio na nich, ale to inne czasy były, środek dot-com ery. Po co się bawić jakimś scratchem jak można od razu na tym zarabiać. 11 latek szybciej ogarnia nowe rzeczy niż 20 latek, nie wiem czemu niektórzy traktują swoje dzieci jak dzieci. Uczenie się czegoś przydatnego w wieku 11 lat nie przekreśla dzieciństwa. Ale - ja to robiłem z własnej woli; w ogóle go w nic nie wprowadzaj - jeśli go coś zainteresuje to sam się wkręci. W dobie internetu sam może się o wszystkim dowiedzieć, nie potrzebuje wprowadzenia. Jak go zaczniesz do czegoś przymuszać to tylko go zniechęcisz. O programowaniu jako takim już się dowiedział. Z drugiej strony z perspektywy czasu widzę że nie posiadanie mentora było dużym błędem, powinienem się wkręcić w jakieś grupy programistyczne gdzie były osoby znające się na rzeczy a ja zamiast tego zarejestrowałem się na 4programmers.  Tja, no gdybym był bananowcem to też bym pewnie tak wolał, a tak trzeba było sobie samemu organizować czas. Łażenie po drzewach przez 10 godzin dziennie wbrew pozorom się nudzi. A programowanie to może być nie najlepszy pomysł, w ogóle nie wiadomo co jest teraz dobrym pomysłem; wygląda na to że AI zbierze żniwo w dzisiejszych zawodach, próg wejścia w IT za 10 lat może być niemożliwie wysoki. Po co zatrudniać juniora jak jeden senior będzie mógł zastąpić 20 juniorów przy użyciu AI. Dziś się nie opłaca zlecać prostych zadań seniorowi bo zabierze mu to cenny czas, ale to się zmieni gdy jego produktywność przy takich zadaniach skoczy kilkukrotnie.;"
"I tutaj wychodzi typowa nieznajomość procedur prawnych i taka chęć zastąpienia procesów sądowych jakimś demokratycznymi linczami polegającymi na tym, że jeśli sprawa jest oburzająca to wyrok powinien być surowy, a jak sprawa nie oburza to wyrok powinien być łagodny. A sędziowie to w ogóle jacyś bogowie, co mogą wszystko gdzieś i wydawać wyroki według własnego widzimisię.  Przypadkiem ""pominąłeś"" fakt, że prokurator wcześniej poszedł do biegłych ze Związku Medycyny Sądowej i to na podstawie właśnie ich opinii zdecydował, że czyn należy zaklasyfikować jako ""wypadek w stanie nietrzeźwości"", a nie ""wypadek w stanie nietrzeźwości z poważnym uszkodzeniem zdrowia"". Trochę szkoda, że zapomniałeś o tym wspomnieć, bo może mieć to kluczowe znaczenie do oceny działania prokuratora, prawda? Gdyby prokurator - tak jak @Haskell chce - bawił się w szeryfa to po prostu sąd musiałby uniewinnić aktora ze względu na złą klasyfikację czynu. Sam wyrok nie jest jakoś specjalnie niski w porównaniu do innych podpadających pod tą samą kategorię. Przykładowo: https://echodnia.eu/radomskie/pijany-kierowca-przy-hotelu-europejskim-w-radomiu-staranowal-dziesiec-aut-znany-przedsiebiorca-uslyszal-wyrok/ar/c1-16995655 - 1,95 promila (a więc prawie 3x więcej niż aktor), w wypadku wzięło udział dziesięć samochodów (w porównaniu do jednego motocykla). Wyrok? W sumie 30 tys. złotych kary, rok więzienia w zawieszeniu i pięć lat zakazu prowadzenia pojazdów. Podobnie np. jakiś ksiądz: https://torun.wyborcza.pl/torun/7,48723,29177764,lagodny-wyrok-dla-ksiedza-ktory-dachowal-majac-prawie-3-promile.html - wypadek po pijaku, grzywna i zakaz prowadzenia pojazdów. Brzmi znajomo?;"
"jest już silnik do javascriptu napisany w javie: https://github.com/oracle/graaljs (co prawda github pokazuje, że większość tego repozytorium to c, c++, itd, ale to dlatego, że do tego repozytorium oracle wdupił chyba prawie całego node.jsa (tzn. pewnie bez chrome v8, który jest zastąpiony graal jitem), który dominuje to repozytorium). graalvm (na którym oparty jest graaljs) obsługuje też webassembly i mnóstwo innych języków. graaljs to jednak zdecydowanie za mało, żeby stworzyć przeglądarkę. brakuje implementacji renderowania html (włączając w to css, dom itp), renderowania grafiki w ogólności (włączając wszelki api do rysowania, renderowanie svg i wiele innych), wielu api webowych, szerokiej obsługi multimediów, obsługi rozszerzeń itd;"
"Używam copilita od jakiś dwóch tygodni. Generalnie całkiem niezła pomoc i wklepuje zauważalnie mniej kodu, bo naprawdę świetnie się domyśla co chcę osiągnąć. Ale najlepiej wychodzi mu podpowiadanie komentarzy dokumentujacych publiczne api ;) Jak ktoś ma tendencje do kopiowania kodu z Internetu bez zrozumienia, to narzędzie nie sprawi, że nagle jego kod będzie lepszy. Będzie tak samo zły. Co nie znaczy, że doświadczony, samodzielny programista nie jest w stanie skorzystać z tego narzędzia by podnieść swoją produktywność. Pracy koncepcyjnej programisty nie zastąpi, ale z nudnym kodem pomoże.;"
"@Dregorio  W moim przypadku to będą akurat m. in. C++, PHP, Perl, Python, SQL. Języków funkcyjnych używa się szerzej niż w jakichś naukowych celach? ""Elementarna znajomość"" oznacza dla mnie, że do programowania w tych językach potrzebowałbym na bieżąco korzystać z Internetu czy książek, co przełożyłoby się na czas pracy, a kod nie byłby najwyższej jakości, ale ogólnie je rozumiem i mógłbym np. przenieść program z tych języków do któregoś z dobrze mi znanych.  Z Asm/C to wiadomo, że wychodzą z użycia, ale Java już też? Pewnie będę musiał się nauczyć jakichś nowszych języków, ale znajomość C mi się w tym przyda. Już mi się przydała w nauce Javy - kiedy (we wczesnych latach mojej nauki programowania) zmagałem się z tym językiem, to wydawał mi się nielogiczny, natomiast po nabraniu doświadczenia w C spojrzałem na nią z innej strony, wszystko rozumiejąc. Z tych nowych języków, czego warto się uczyć - Rust, czy coś jeszcze innego?  Mam w życiu dobrze, ale przecież zawsze mógłbym mieć jeszcze lepiej.  To też zamierzam zrobić, nawet jestem już na jednym takim portalu. Ale tam zawsze jest pole ""strona WWW"" i wydaje mi się, że warto jest mieć stronę z kompletem informacji. Chyba, że mi się tylko wydaje, i powinienem jednak podejść inaczej do zrobienia takiej strony?  Jeśli to jest problem, to za 4 miesiące, mając 15 lat, o ile się nie mylę, jakieś umowy będę mógł już chyba podpisać. @szafran98  Pewnie tak. Ale w mojej obecnej sytuacji nawet jak ktoś mi w ogóle nie zapłaci, to oczywiście nie będzie dobre, ale nie będzie też dużą tragedią, ponieważ na razie się nie utrzymuję samodzielnie. A jednak - znów, o ile nie jestem w błędzie - większa część osób jednak będzie uczciwa i zapłaci.  Czcionka sans-serif jest, marginesy są, co powinienem jeszcze zrobić, żeby nadać stronie nowocześniejszy wygląd? Eksperymentuję ze wzbogaceniem strony o efekt fade-in na wejściu (poprzez dynamiczną zmianę opacity na body) - taki efekt będzie wyglądał ciekawie, czy raczej zepsuje wrażenia odwiedzającego? @Troll anty OOP  To wyszczególnienie znanych mi języków (i podanie paru innych szczegółów w sekcji Aspekty techniczne) miała na celu pokazanie, że rzeczywiście się na tym znam, bo o robieniu programów pod Windows może napisać każdy. Przychodzi mi jeszcze do głowy, żeby napisać najpierw ogólnikowo, a poniżej przytoczyć więcej szczegółów. Mógłbyś rozwinąć tę kwestię?  Niestety to prawda, ale biegu czasu nie przyspieszę. @LukeJL  Dziękuję za przypomnienie, chociaż akurat już poprawiłem. Nie wrzuciłem jeszcze zmian, bo pewnie coś jeszcze będę zmieniał i wtedy zaktualizuję zbiorczo.  Opłaca się na razie zastąpić tę grafikę czystym tekstem, a ew. później ulepszyć ją i przywrócić? Ze stockiem byłby trochę problem, bo to jest co jak co użytek komercyjny.  Ta grafika ma ALT-tekst, który wyświetli się po zaznaczeniu na stronie obrazka i wklejeniu do pola tekstowego, tak jak w przeglądarce tekstowej na zrzucie poniżej.    screenshot-20230913154745.png (21 KB) - ściągnięć: 3;"
"no to błąd, bo możesz po prostu iść do pracy i zarabiać po 10.000zł miesięcznie kurs to marnowanie czasu, 8h kursu możesz zastąpić 2 godzinami samokształcenia, a certyfikatem ukończenia kursu możesz sobie co najwyżej zastąpić papier toaletowy chyba że bardzo wolno łapiesz to wtedy kurs może być ok;"
"Testujmy na produkcji, będzie szybciej :D https://twitter.com/elonmusk/status/1592177471654604800 A chwilę później: https://twitter.com/SamGuichelaar/status/1592238872309686272 Elon Musk notuje: ten był jednak potrzebny :D  Tego nikt nie twierdzi. Ale jak już się bierze za naprawianie to byłoby miło mieć na to jakiś rozsądny pomysł, inny niż zwalnianie losowych inżynierów, przekonywanie pozostałych, żeby tłukli 80h/tydzień, odpalanie i gaszenie funkcji oraz wyłączanie losowych mikroserwisów na prodzie :) Dodając do tego jak bardzo Elon się miotał przed zakupem, jak dla mnie nie miał na to żadnego planu i nie wie co robi. Im dłużej się nad tym zastanawiam, tym bardziej jestem za tym, aby ten eksperyment się nie udał. Z prostego powodu. Jeśli się uda, to takie metody zarządzania firmą - losowe zwolnienia, traktowanie kadry fachowców jak śmieci, gdzie każdego specjalistę można zastąpić skończoną liczbą studentów :) staną się nową prawdą objawioną jak wyciągać firmy z kłopotów. Pod kolejną śmieszną nazwą po agile, czy tam innym scrumie, tylko jeszcze bardziej toksyczną dla ludzi IT. Jeśli to się uda, to po pierwsze uważam, że to będzie czysty przypadek, bo w działaniach, które mają miejsce, nie widać ani ładu, ani składu, a po drugie, będzie to wyłącznie ze szkodą dla całej branży IT, bo znajdzie się wielu chcących takie praktyki zarządzania przenosić. Tylko tam już szczęścia nie będzie. Warto też zwrócić uwagę moim zdaniem jak Elon rozgrywa temat PR-owo. W sumie wszystko jest złe, źle zrobione, czyli co - wszyscy, którzy wypruwali sobie przez lata żyły to idioci i beztalencia. Tylko że za tymi komunałami nie stoją jakieś konkrety. Robi wrzutę, że 20% mikroserwisów jest zbędnych. Może i ileś jest, bo w każdym dużym projekcie bywa, że są abandoned z różnego powodu, ale gdzie konkrety? Wyłącza, to pada 2FA, więc coś nie za bardzo ta analiza była dogłębna. Ale ludożerka kupiła. Dorzuci tam coś o przywracaniu wolności i większość będzie faktycznie przeciw tym, którzy to miejsce przez lata tworzyli, bo zmanipulować przekaz prosto... O ile udało mu się w innych projektach (może miał dużo dobrych doradców), tak tutaj mam poważne zastrzeżenia jak to wygląda. A może wychodzi po prostu jaki Musk jest naprawdę.;"
"Można to rozwiązać za pomocą programowania dynamicznego: zauważ że tablicę: a	d	*	* b	e	*	* c	f	*	*  można zastąpić na: abd		*	* abce	*	* bcf		*	*  gdzie: abd=min(a+d,b+d)	 abce=min(a+e,b+e,c+e)	 bcf=min(b+f,c+f);"
"Siedzenie na tyłku 8h na dobę i czekanie na hemoroidy to taka zajebista praca? Mamy zarobki powyżej średniej ze względu na to że nasza praca jest łatwo przenaszalna między krajami, ale też łatwo takie stanowisko zlikwidować. Konkurujemy z całą Europą wschodnią, Chinami i Indiami. Kto wie jak długo nam to się będzie udawać? Jeśli ktoś myśli że może się poopierdzielać za 10k to oczywiście ma rację, tylko to myślenie krótkowzroczne. Bo albo zastąpi go Ukrainiec, albo ktoś się zorientuje że ma za mały wkład. Albo cała firma się zawinie do jakiejś Indonezji. Trzeba być ciągle ap-to-dejt, albo trzymać się jakiejś archaicznej technologii której nie uczą na butkampach w Kraju Połudiowej Azji. Każde z rozwiązań ma swoje plusy i minusy.;"
"Po pierwsze nie uważam że nauczyciele i wykładowcy to intelektualiści, przynajmniej nie ci z którymi miałem styczność. Zazwyczaj powtarzają rok do roku ten sam materiał, spróbuj ich spytać coś spoza niego to pojawi się problem. Można ich zastąpić już teraz z powodzeniem nagraniami video i chatgpt. W ogóle to niezły absurd żeby płacić tyle milionów za powtarzanie w kilkudziesięciu tysiącach miejsc w polsce codziennie w zasadzie to samo. Za te pieniądze można by było zrobić naprawdę solidne interaktywne materiały szkoleniowe. Po drugie uważam że średnia wieku rośnie, jeszcze parę lat temu wynosiła około 20 parę lat ale wtedy był największy bum na programowanie w polsce i najwięcej ludzi weszło w ten zawód. Na zachodzie od dłuższego czasu średnia jest powyżej 30 lat. W moim zespole średnia to około 35 lat, mamy jednego gościa w wieku przedemerytalnym, w ogóle nie widziałem dawno nikogo młodszego niż tam 25. Nie spotkałem się też z żadną historią żeby kogoś zwolniono z powodu wieku, prędzej trudność może być ze znalezieniem pracy, ale nikt nie każe ci określać swojego wieku w cv i jedynie twój głos może cię zdradzić.;"
"Jak już wspomniano, to nie jest skrót, a zastąpienie kilku liter gwiazdkami w celu cenzury brzydkich słów i jest to powszechnie stosowana praktyka.;"
"Tytuł trochę mylący. ZUS zawsze będzie miał z czego wypłacać emerytury, bo jak jemu zabraknie środków (co już się dzieje) to dopłaca budżet. Natomiast zgadzam się, że tak jak piszesz jakaś reforma będzie po drodze - pytanie czy prawo zadziała wstecz, czy obejmie dopiero osoby przechodzące na emeryturę. Jako osoba pracująca całe życie na B2B nigdy na ZUS nie liczyłem bo widać jakie są prognozowane przeliczniki zastąpienia dla emerytów przechodzących na emerytury za 20-30 lat. W skrócie wygląda na to, że wszyscy będą dostawać w okolicach emerytury minimalnej. Przy współczynniku zastąpienia 0.25 to osoba zarabiająca średnią krajową dostanie minimalną emeryturę. Jak ktoś zarabiał mniej to też dostanie minimalną... Już takie coś raz w życiu przerabiałem jak moja żona opłacająca regularnie przez sporo lat składki na ZUS od b2b dostała mniejszą wypłatę z urlopu macierzyńskiego niż osoba nie opłacająca żadnych składek. Wtedy państwo wspaniałomyślnie podwyższyło nam wypłatę do minimalnej ;-) Z emeryturami przypuszczam, że będzie identycznie tak samo. Albo zrobi to sama matematyka albo ustawa o emeryturze obywatelskiej i znowu osoby uczciwie płacące składki zostaną oszukane. Co do scenariuszy pozytywnych to widzę dwa:  Imigracja. Mamy szansę zrobić to dobrze ucząc się na doświadczeniach reszty Europy. Myślę, że jak imigrantom da się uczciwy i egzekwowany kontrakt, który sprowadza się do tego ""albo pracujesz albo wypad"" + przyłożymy się do asymilacji (np. obowiązkowa nauka języka, rozproszenie geograficzne imigrantów żeby uniknąć gett, import dużej ilości ludzi ze wschodu, a może nawet Zachodu Europy). Ogólnie trochę trudno mi sobie wyobrazić aby to się udało zrobić w obecnej Europie, ale marzyć można Kolejna rewolucja technologiczna - bogactwo opiera się o wydajność pracy. Jeśli dokona się kolejna rewolucja technologiczna to nawet garstka ludzi będzie mogła utrzymać na dobrym poziomie resztę. Pierwsze co przychodzi do głowy to AI. Oczywiście wiąże się to ze zmianą całej struktury społeczeństwa, wprowadzeniu skutecznych mechanizmów dystrybucji - taki trochę komunizm w wersji tech.  Jakbym miał obstawiać to bym obstawiał, że niestety będzie tak jak piszesz @0xmarcin czyli coś pokroju emerytura obywatelska i kto sobie odłożył ten ma, a reszta musi jakoś ""dożyć do śmierci"". Na taki scenariusz się nastawiam i buduje kapitał pod niego + karierę kieruję w kierunkach, gdzie długo będę mógł być produktywny. Mam tylko nadzieję, że komuś nie przyjdzie do głowy np. nacjonalizacja prywatnych oszczędności emerytalnych.;"
Jak coś ma łatwy próg wejścia (btw próg wejścia to może być niski) to nie chcesz tego robić chyba ze chcesz konkurować z innymi wannabe którzy będą próbowali cię zastąpić bo będą tańsi.;
"Ale Java jak i C# to chyba bardziej technologie przeszłości, a nie przyszłości? Co nie musi być złe, bo tak jak @tsz pisze Za kilka dekad dalej będzie kupa kodu i w jednym i w drugim. Czyli pewnie nie znikną tak szybko z rynku. Trochę jak PHP, JavaScript czy ten... Cobol, czy jak mu tam było. Taki język, w którym jaskiniowcy pisali skrypty do rzucania kamieniami w dinozaurów. A jak chcesz się przygotować na przyszłość, to ucz się nie technologii, tylko ogólnych kompetencji, które będą poszukiwane w przyszłości - na pewno angielski, być może również w przyszłości chiński. Umiejętność ogólnego programowania w jakimś języku programowania (tym, który będzie modny w przyszłości), umiejętność wyszukiwania informacji (co w przyszłości może być jeszcze bardziej istotne, bo jeszcze większy śmietnik informacyjny będzie), komunikatywność, empatia itp. A poza tym nic nie jest wiadome, np. jeszcze wczoraj byłem przekonany, że AI/Machine Learning/Data Science itp. to najbardziej przyszłościowy kierunek rozwoju na najbliższe 20 lat (bo AI dopiero się zaczyna rozwijać) a wszedłem na reddita i się okazuje (tak piszą ci, co w tym siedzą), że data scientistów jest na pęczki i że nikt ich tyle nie potrzebuje, że jacyś tam są potrzebni, ale bardzo niewiele i coraz mniej ma być ich potrzeba aż w końcu zostaną zastąpieni AI (o ironio), bo nic takiego trudnego nie robią wcale.;"
"Różnice światopoglądowe są istotne. Ja na przykład cenię sobie w środowisku .NET, że w większości przypadków istnieje jedna słuszna droga, nikt nie wymyśla kolejnych, alternatywnych języków mających zastąpić C# na CLR i większość programistów nie ma funkcyjnych zapędów, jak w przypadku Javy, sądząc po tym forum.;"
"W mojej ocenie ani frontend ani w ogole programowanie nie zniknie z uwagi na sama zlozonosc tej dziedziny. Zniknal zawod pani, ktora przelaczala rozmowy telefoniczne czy pana, ktory zapalal wieczorami latarnie. Jak jednak zastapic frontendowca gotowym klikalnym rozwiazaniem? Nawet takiego od HTML czy CSS? Te dwie technologie juz sa maksymalnie uproszoczone dla uzytkownika. Co za roznica czy uzyjemy samego flexboxa czy bootstrapowego flexa czy jeszcze jakiegos innego ""klikalnego"" rozwiazania? Co bedzie stale, niezaleznie od wyboru - to opcje konfiguracji koncowego produktu. Przykladowo czy chcemy rozmiescic elementy ""do lewej"" czy ulozyc je w wiersz badz kolumne. To jest swiadoma decyzja klienta - trzeba wprowadzic konkretny input. Wyklikac pewno latwiej, ale gdy takich wyborow beda tysiace - user sie pogubi i koniec koncow powstanie ""developer-klikacz"", ktory bedzie wiedzial co wyklikac, zeby osiagnac pozadany efekt. I dlatego wlasnie programowanie nie zniknie, poniewaz jeden klient bedzie chcial miec zielony okragly button a drugi bedzie wolal klikalny text. Nie znam sie na grafice, ale gdy pierwszy raz otworzylem photoshopa - to nie wiedzialem o co w tym chodzi i dalej nie wiem, a przeciez to no-code solution (chyba). Shalom kiedys zwrocil na to uwage, ze te wszystkie ""uproszczenia"" koniec koncow zawsze tak sie komplikuja, ze ich zlozonosc przypomina zlozonosc jezyka programowania. A komplikowac sie musza, jesli chca zapewnic te wszystkie mozliwosci, ktore daje programowanie. Dopoki maszyna nie bedzie w stanie skomunikowac sie bezposrednio z klientem, doputy zawsze bedzie istnial posrednik (developer) miedzy nimi.;"
"AFAIK to że na start nie ma kasy nie znaczy że nie ma przyszłości. Dużo firm zaczynało jako hobby projekt open source bez kasy i tak się on rozkręcił, a dopiero potem doszły paid features, consulting, VC money, może jakieś adaptacje strukturalne jak przejście na model open-core, itp. Ostatio czytałem o Postman, Inc. że tak miał (teraz $5.6B Valuation, VC funding: $434M). Poza tym AFAIK, np.: Red Hat, Inc., Canonical Ltd., MongoDB, Inc., Elasticsearch B.V., GitLab Inc., Docker, Inc., HashiCorp Inc., Nginx, Inc., Cloudera, Inc., czy taki Confluent, Inc. (przykładów jest o wiele więcej, podaję tylko 10). Spostrzeżenia @LukeJL o dźwigni wydają mi się bardziej trafione, a do tego nawapawą mnie drobnym optymizmem i zdrową pokorą. Btw: ""Pessimism sounds smart but optimism makes money"".  Wiem że tak nie jest, ale jak czytam tu forumowiczów to wydaje mi się niekiedy że każdy by każdego na hajs robił gdyby tylko mógł . Mało kto tu zakłada że faktycznie ktoś będzie chciał robić dobrze. Te uwagi o wyzyskiwaniu i nadużywaniu mechanizmu są bardzo dobre i obowiązkowo muszą być rozwiązane, bo faktycznie nieuniknione jest że ktoś tak będzie robić, ale... (wiem że systemy złożone się ciężko przewiduje) tutaj pomiędzy contributors jest mechanizm konkurencji taki jak w naszej kapitalistycznej ekonomii. Ostatnim razem jak sprawdzałem w naszym kapitalistycznym systemie promuje to jednak jakiś postęp, jakość usług i produktów oraz ogólnie innowacje. Koniec końców ta lepsza jakość wygrywa i się przebija (no @SkrzydlatyWąż tu to trochę trafniej opisał że aż tak pięknie nie jest, no ale ogólnie tak to działa). Jak mi jakiś contributor zacznie trollować to go w PR Review odrzucę i ticket przejdzie do kogoś innego a on na każdym takim oblanym review nie wzmiacnia swojego priority (w przeciwieństwie do tego kto ten ticket od niego przejął).  Bardzo fajny pomysł. Prostszy od mojego pomysłu (prostsze = lepsze IMO (przeważnie)) a bardzo sensowne i do tego jest łatwiejsze w implementacji. Chyba od tego powinienem zacząć moje zabawy z smart contractami (escrow), nie ważne czy moim celem jest to co ja opisuję czy to co Ty. Thx.  Brzmi ciekawie, thx. Noted.  Są np.: takie firmy których produkty są open source albo open core, te firmy już się mocno rozrosły i nie polegają już na contributors, choć na początku zbudowali je contributors, tylko mają już pracowników na etacie (i co za tym idzie HR, bo mechanizm ""etat"" wymaga poniekąd HR). Poza tym kminię nad tym czy firma/organizacja która swoich programistów zdobywa takim skutecznym (kminimi czy to by było skuteczne, IMO tak) bez-rekrutacyjnym mechanizmem (który ma o wiele mniej frykcji, jest bardziej elastyczny, adaptacyjny i otwarty), może wygryść z rynku pracy firmy pozyskujące programistów urzywając do tego klasycznego podejścia z HR.  Ogólnie to mam dobry prywatny kontakt z dobrymi księgowymi różnych kalibrów i przyznaję mój tytuł posta to lekki clickbait. Księgowość robi ogrom innych rzeczy i w firmie taki mechanizm by ich nie zastąpił (jedynie utrudnił ich pracę, bo np. trzeba te smart kontrakty i ich pracę jakoś raportować oraz wiedzieć wgl czym to jest według prawa podatkowego (spoiler: prawo podatkowe nawet nie przewiduje do końca że taki mechanizm może istnieć)). Co do HR niestety prywatnie nie znam dobrze nikogo z tej branży. Mam paruletnie doświadczenie, od bardzo dobrze zorganizowanej i prosperującej firmy typu produkt po kontraktownie i projekty jakoś tam dryfujące z lekkim overengineering, takie gdzie się klepie dla klienta od słupka do słupka oraz takie co upadają z powodów politycznych wewnątrz firmy lub underengineeringu i niekompetencji. Wszędzie HR był jak alicja w krainie czarów, i ni c**** nie rozumiały te babki co się faktycznie koło nich dzieje. IMO aktualnie potrzebujemy HR tylko dlatego że nikt nie wymyślił niczego lepszego a do tego prawo narzuca pewne rzeczy których efektem są problemy do których aktualnie trzeba HR (a prawo narzuca je daltego że nikt nie wymyślił jak to zagwarantować wcześniej bez prawomocnych ustaw (i tu na biało zaczynają wchodzić smart-contracty, tak w wielkim uproszczeniu)). Szukam i szukam na necie co robi HR, oglądam jakieś vlogi laseczek z HR w IT (""dzień w pracy"", ""tips and tricks do pracy"", ""pierwsze wrażenia"", ""wish I knew"" itp). Na Google czytam co chwila że w sumie to ""zatrudnianie pracowników oraz dbanie o motywację i rozwój pracowników"". W moim systemie te dwie główne funkcje już są rozwiązane ""by design"", także aktualnie szczerze wydaje mi się że mało potrzebny jest ten HR. Koniec końców nie chce HR w rekrutacji bo jeszscze NIGDY nie zdażyło mi się by coś wniosły do tego procesu oprucz wstępnej filtracji ludzi po słowach kluczowych i latach ogłoszenia w CV.;"
"Na studiach nauczą Cię specjalizacji? Przecież IT się zmienia tak szybo, że zanim uczelnia to przetrawi i wdroży to już będzie nieaktualne. Potrzeba mocnych podstaw z matmy, algebry, algorytmów, fizyki, modelowania matematycznego.  Jakich specjalizacji? Zrobisz dwie rzeczy mocno a za 5 lat się okaże, że to już jest nieaktualne i co wtedy? Wyspecjalizujesz się w czymś co nie wiadomo czy nie zostanie zastąpione za parę lat.  Ale ja się odnoszę do tego co napisałem w moim poście. Kończy się praca w jednym zawodzie przez całe życie. A najlepszym sposobem by się w tym odnaleźć jest bycie elastycznym, tzn uczenie się ogólnie różnych rzeczy. Specjalizowanie się jest dobre gdy już zaczniesz gdzieś pracę a nie na etapie studiów. Studiując nigdy nie wiesz gdzie w końcu trafisz.;"
"@tefu  frejmłorki do frontu i toole od startupów będące nakładkami na api clouda czy chata gpt może faktycznie szybko się zmieniają ale fundamenty OSów, silników bazodanowych czy kompilatory nie zmieniają się co 2 tygodnie, a są tematami nad którymi na bank można się pochylić bardziej niż 1 przedmiocik na studiach przez 1 semestr  no to masz te podstawy?  No życie, trzeba było lepiej wybrać. Tak samo przecież można napisać Jakie studia? Pójdziesz na infę a za 5 lat się okaże, że już boomu nie ma? Wyspecjalizujesz się w czymś co nie wiadomo czy nie zostanie zastąpione za parę lat przez AI. Można nadal zrobić tak, że 1 stopień pozostaje taki, jaki jest teraz, a drugi to mocna specjalizacja, a nie to co jest teraz że 1 i 2 stopień to takie ogólne uczenie + jakieś tam małe specjalizacje  Zawód możesz zmieniać, ale czy zmieniasz branże? I kiedy zmieniasz - gdy już się dorobisz i cię złapie wypalenie? To nadal musisz najpierw się dorobić. No bo wiesz, co za różnica gdy zaczynasz jako softłer inżyniur, po 5 latach idziesz bardziej w dev łops, a kończysz jako menagjer? Nadal branża raczej ta sama;"
"Podjąłem jednak inną decyzję, pewnie w jakimś stopniu za jakiś czas będę jej żałował, ale doszedłem do wniosku, że przy tym trybie zajęć, planu, odległości studiowanie nie będzie zbyt efektywne. W poprzednim semestrze było kilka zajęć, na których prowadzący faktycznie pomogli i tego chyba będę żałował najbardziej. Niestety teraz już po pierwszym tygodniu widać, że w zasadzie większość jest do samodzielnej nauki w domu, praktycznie od początku do końca. Czytanie na wykładzie prezentacji słowo w słowo w 2022 r. mnie przerosło. Prawdopodobnie w kolejnych semestrach zmieni się to na plus. Poznałem w porządku ludzi, myślę, że udzielą kodów i w co przydatniejszych wykładach będę uczestniczył zdalnie. Z ćwiczeń porobię ksero albo zdjęcia - nic nie zastąpi fizycznej obecności i wysłuchania na własne uczy, ale dobre i to, tym bardziej, że te rzeczy będę i tak się uczył we własnym zakresie. Niestety prawie w całości zajęte dni związane z zajęciami i dojazdem nie pozwolą mi zrealizować tego co bym chciał w sposób w jaki bym chciał. Tym bardziej że oprócz samej analityki danych i programowania są też inne przedmioty, wymagające i zapewne czasochłonne jak fizyka, metody numeryczne, równania różniczkowe i jeszcze 2 semestry samej analizy matematycznej. Ciężka decyzja, nie ma dobrego wyjścia, ale jeśli znowu mam niedosypiać i naganiać wieczorami /nocami to już wolę swoim tempem za pomocą tego co dostępne online + w książkach. Z tytułu braku papieru będzie też pewnie kłopot z pierwszym stażem. Będę chciał to nadrobić skillem, a jeśli będzie za mały tzn. że się nie nadaję do tej pracy i trzeba będzie szukać szczęścia gdzie indziej. Wstępny plan na najbliższe pół roku to Podstawy pythona/ podstawy statystyki/ angielski.;"
"Pamiętaj, że zęby od zawsze są i będą, a nas co roku ma zastąpić AI w pisaniu kodu :);"
"int findMaxDistance(Integer[] arr) {          Map<Integer, Integer> indices = new HashMap<>();         int maxDistance = 0;          for (int i = 0; i < arr.length; i++) {              indices.putIfAbsent(arr[i], i);              int pairDistance = i - indices.get(arr[i]);             if (pairDistance > maxDistance) {                 maxDistance = pairDistance;             }         }          return maxDistance;     }  Do przerobienia z Java na C# Map, HashMap to mapa key i value typu integer putIfAbsent to java syntactic sugar do zastąpienia przez klasyczne if(map.get(key) == null){map.put(key, value)} lub od razu przez to co oferuje C#, .NET;"
"No… analiza danych polega na analizowaniu danych, pod kątem jakichś szukanych informacji. Na przykład: prowadzisz restaurację i chcesz wiedzieć, jak pogoda wpływa na sprzedaż. Albo chcesz stworzyć model predykcyjny sprzedaży na podstawie prognozy pogody. Albo chcesz się dowiedzieć, czy po uwzględnieniu wszystkich innych czynników (jakich?) kelnerzy wpływają na sprzedaż, a jeśli tak, to który jest najlepszy. Albo zdecydować, które potrawy usunąć z menu — a tutaj prosta analiza „to się sprzedaje najmniej” nie wystarcza, bo może ktoś przychodzi właśnie na tę rzadko sprzedawaną potrawę, której nie ma jak zastąpić; więc jak wyrzuci się jedną z zup, nawet taką która się dobrze sprzedaje, to różnice będą niewielkie, ale jak wywali się jedyną potrawę wegańską, to będą większe problemy, itd.;"
"uses crt; type TElem = double;      TArray = array of TElem; const EPS = 1e-12;  {    Procedura znajdujaca czynnik kwadratowy    Znajduje takze wspolczynniki wielomianu po deflacji znalezionym czynnikiem kwadratowym    Korzysta z metody stycznych Newtona aby rozwiazac uklad rownan nieliniowych    powstaly po przyrownaniu do zera reszty z dzielenia wielomianu przez trojmian kwadratowy  }  procedure Bairstow(deg:integer;a:TArray;var b:TArray;r0,s0:TElem;var r:TElem;var s:TElem); var i:integer;     d,dr,ds:TElem;     c:TArray; begin    SetLength(c,deg+1);    repeat      b[deg] := a[deg];      b[deg-1] := a[deg-1]+r0*b[deg];      c[deg] := 0;      c[deg-1] := b[deg];      for i := deg - 2 downto 0 do      begin        b[i] := a[i] + r0 * b[i + 1] + s0 * b[i + 2];        c[i] := b[i + 1] + r0 * c[i + 1] + s0 * c[i + 2];      end;      d := (c[0] * c[2] - sqr(c[1]));      dr := (c[1] * b[1] - c[2] * b[0])/d;      ds := (c[1] * b[0] - c[0] * b[1])/d;      r0 := r0 + dr;      s0 := s0 + ds;    until ((abs(dr)<EPS)and(abs(ds) < EPS));    r := r0;    s := s0; end;  {     Procedura rozwiazujaca numerycznie rownanie wielomianowe     wykorzystujaca czynnik kwadratowy i wspolczynniki wielomianu     po deflacji znalezionym czynnikiem kwadratowym     Powyzsze dane otrzymujemy w wyniku dzialania procedury Bairstow     Procedura znajduje wszystkie pierwiastki wielomianu takze te zespolone     unikajac arytmetyki zespolonej przy zalozeniu ze wspolczynniki wielomianu sa rzeczywiste }  procedure PolyRoots(deg:integer;a:TArray;p0,q0:TElem;var xr:TArray;var xi:TArray); var i:integer;         b,c:TArray;         p,q,d:TElem; begin   SetLength(b,deg+1);   SetLength(c,deg+1);   for i := 0 to deg do       c[i] := a[i]/a[deg];   for i := 0 to deg-1 do   begin     xr[i] := 0;     xi[i] := 0;   end;   while (deg >= 2) do   begin     Bairstow(deg,c,b,p0,q0,p,q);     d := sqr(p) + 4*q;     if (d < 0) then     begin       xr[deg-1] := 0.5 * p;       xr[deg-2] := 0.5 * p;       xi[deg-1] := -0.5 * sqrt(-d);       xi[deg-2] := 0.5 * sqrt(-d);     end     else     begin       xr[deg-1] := 0.5 * (p - sqrt(d));       xr[deg-2] := 0.5 * (p + sqrt(d));     end;     deg := deg - 2;     for i := 0 to deg do         c[i] := b[i+2];   end;   if (deg = 1) then      xr[0] := -c[0]/c[1]; end;  {   Glowny blok programu demonstrujacy dzialanie procedur }  var     i,deg:integer;     a,xr,xi:TArray;     p0,q0:TElem;     esc : char;  begin   ClrScr;   WriteLn('Przyblizone rozwiazywanie rownan wielomianowych metoda Bairstowa');   repeat   WriteLn('Podaj stopien wielomianu');   ReadLn(deg);   SetLength(a,deg+1);   SetLength(xr,deg);   SetLength(xi,deg);   WriteLn('Podaj poczatkowe wartosci wspolczynnikow trojmianu');   ReadLn(p0,q0);   WriteLn('Podaj wspolczynniki wielomianu');   for i := deg downto 0 do   begin     Write('P[',i,']=');     ReadLn(a[i]);   end;   PolyRoots(deg,a,p0,q0,xr,xi);   WriteLn('Przyblizone wartosci pierwiastkow wielomianu to: ');   for i := 0 to deg - 1 do     if xi[i] < 0 then         WriteLn('x[',i,']=',xr[i]:1:12,xi[i]:1:12,'*i')     else        WriteLn('x[',i,']=',xr[i]:1:12,'+',xi[i]:1:12,'*i');     esc := ReadKey;   until esc = #27; end.  Co do mozliwosci modyfikacji to:  Czy istnieje jakis sposob wyboru wartosci poczatkowych? Czy mozna zmodyfikowac badz zastapic metode Newtona tak aby zagwarantowac zbieznosc procedurze Bairstow?;"
"Fajnie, ze są benchmarki tylko z mojego punktu widzenia, to albo jest o co się bić z wydajnością i wtedy użycie Optional blednie na tle całych wiader ustępstw w clean code, dzieleniu na warstwy i zastąpieniu kolekcji tablicami, bo faktycznie trzeba się bić o każdy cykl procesora z jakiegoś tam powodu, albo mamy standardową aplikację działającą sobie na serwerze i wydajność w zupełnie nieistotnej części zależy od tego czy użyliśmy tej klasy, czy innej, bo narzut całego bałaganu z użyciem refleksji, komunikacją przez HTTP, odczyt i zapis danych do DB, czy od obsługa wyrażeń regularnych sprawia, że narzut iluś tam nanosekund nie ma żadnego realnego znaczenia. Gdyby wydajność była jedynym czynnikiem o który warto walczyć, to wszyscy siedzielibyśmy w asm'ie. Nawet jeżeli jest sens walczyć o wydajność, to zwykle ten miliard wywołań na sekundę można opakować w coś (klasa, moduł, metoda) z napisem ""DRAGONS AHEAD, DO NOT ENTER` a efekt tego miliona wywołań zapakować w optionala jeżeli ma to sens. Wtedy mamy prawie maksymalną wydajność tam gdzie trzeba i ""ładnie"" tam gdzie na tej wydajności nam nie zależy tak bardzo. Zupełnie osobna sprawa, to pytanie czy jeżeli mamy zadanie w którym wydajność jest naprawdę ważne powinniśmy używać do jego obsługi języka, który od 25 lat twierdzi, że już za chwilę będzie szybszy od C++ i jak to kolejne wynalazki pozwolą uzyskać nie wiadomo jak wielkie przyśpieszenie, o którym później mówi się już jakoś mniej.;"
"Niestety nie ma pozytywnego. To taka współczesna alternatywa zapełniania serwisu słowami kluczowymi. 20 lat temu wystarczyło jak na stronie wpisałeś ""BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY BUTY "" i już byłeś na hasło buty na pierwszym miejscu. Potem kto więcej słów buty umieścił na stronie wygrywał. Ciągle to samo... od 100 lat. Tak jak kiedyś zakładano firmy o badziewnych nazwach w stylu ""AAAAA buty"" albo ""AAAAAAAA Hydraulik"", żeby być na pierwszej stronie książki telefonicznej tak samo teraz tworzy się i wykorzystuje stary badziewny content na strony WWW tylko po to żerby było dużo i żeby wpaść na pierwszą pozycję w google. To taka walka ilością zamiast jakości bo dużo ""goowna"" działa równie dobrze podobnie jak mniejsza ilość rzetelnie przygotowanych i aktualnych treści a jak łatwo się domyślić goowno jest tańsze bo srać każdy może a wartościowych materiałów już nie każdy dostarczy:-)  Nie do końca tak. Współpracowałem z firmami, które jakość contentu stawiają na pierwszym miejscu a środki, które przeznaczają na utrzymanie tej jakości są liczone w setkach tysięcy dolarów miesięcznie. Czy to działa? Zdecydowanie tak i jest bardzo perspektywiczne. Niestety taka strategia wymaga czasu, pieniędzy i cierpliwości a we współczesnym biznesie internetowych tego ostatniego nie ma prawie nikt. Ta cierpliwość jednak nie może być pominięta bo to jeden z czynników sukcesu składającego się na to, że firma/strona postrzegana jest jako profesjonalna i odwiedzana. Zatem skoro brakuje jednego czynnika to trzeba go zastąpić jakimś tanim marketingowym ""goownem"" typu przekreślone ceny, końcówki .99 albo wyskakujące okienka typu tą wycieczkę ogląda w tej chwili 18 internautów. Na żadnej stronie turystycznej w Polsce ten komunikat nie ma nic wspólnego z rzeczywistością :-) Sam na życzenie klientów pisałem algorytmy, które generowały liczby, które mają jakikolwiek sens, np. tak żeby o 3:00 nad ranem nie było takich samych wartości jak o 15:00 albo żeby na wycieczce do Mozambiku z terminem za 2 lata nie było tyle samo co na last minute do Grecji na jutro :-) Wszystko to jednak nie ma żadnego sensu. Zwykle właściciele serwisu chcą takie ""goowno"" bo tak im podpowiedział ""specjalista"" od marketingu lub po zapoznaniu się z realnymi kosztami i czasem rzetelnego zbudowania zaplecza SEO. Dalej to bezmyślne zgapianie jeden od drugiego... bo jak biuro FiuFiuTravel takie ma a właściciel Heniek jeździ Jeepem to pewnie wie co robi więc ja też takie chcę :-) Szkoda słów. W branży turystycznej w ciągu ostatnich 20 lat zrealizowaliśmy kilkaset serwisów. Na zrobienie prawdziwego sensownego SEO zdecydowało się 5 (słownie pięciu) klientów. Owszem z tych kilkuset tak z 70% potrzebowało stronę żeby pod adresem na wizytówce coś było ale te 30% jednak wychodziło z założenia, że serwis ma być ich dodatkowym lub głównym kanałem sprzedaży a mimo to nie robili nic.  Powoli to wszystko jednak zaczyna iść w pozytywnym kierunku. Wciąż odwalam mrówczą robotę w kilku projektach i ta rzetelna praca jednak przynosi stabilne efekty. Niestety dość powoli ale to kwestia środków. Trendy są jednak stale rosnące i coraz bardziej obiecujące. W pewnym momencie pojawią się środki na tworzenie większej ilości wartościowych materiałów i usług a to jednak przyciąga klientów a co najważniejsze przywiązuje klientów do marki. Wszystko chyba sprowadza się do tego czy chcemy zrobić dobry produkt lub usługę, która sama się obroni czy chcemy jak najszybciej wcisnąć klientowi kit, sprzedać i zapomnieć. Można by o tym pisać godzinami dotykając przy tym psychologii klienta, sprzedawcy, właściciela firmy itp... itd... Jedno jest pewne. Dobrych stron, które bronią się jakością i przy tym nie potrzebują wparcia treściami SEO ani tanimi chwytami marketingowymi jest ułamek promila i pewnie każdy je zna.  Bo chodzi tylko o to żeby wszedł i kliknął w reklamę. O nic więcej. Do tego stopnia, że kilka lat temu można było zauważyć wysyp artykułów generowanych przez AI na podstawie losowych filmików. Był filmik o pisie co podskoczył a AI wygenerowało do tego 5 zdań na podstawie kilku klatek i tekst leciał na główną stronę takiego WP czy Onetu. Oczywiście tekst był od czapy ale:  był unikalny; był o czymś o czym inni nie pisali; był powiązany tematycznie z filmem (więc poważna sprawa i teoretycznie dodatkowe punkty); to że był o niczym a czytelnika tylko wku....ał nie ma najmniejszego znaczenia z punktu widzenia statystyki. Bo ważne było żeby dużo nowych treści było.;"
"Akurat ta zmiana z O(n*n) do O(n) poskutkowała mniejszą ilością kodu niż była wcześniej. Zmiana polegała na zastąpieniu Set.exists(predicate) (musi lecieć po elementach po kolei i odpalać predykat) na Set.contains(element) (tutaj HashSet może policzyć hasha i wyszukać element w O(1)). W innym przypadku optymalizacja polegała np na wyniesieniu tworzenia mapy poza wewnętrzną pętle - przez to, że O(n) razy była tworzona identyczna mapa złożoność całego algorytmu mocno rosła. Często na początku, podczas tworzenia serwisu są dane o małym rozmiarze, ale z czasem rosną. Co się dzieje jak takie kulawe algorytmy niedomagają? Zamiast sprofilować i zoptymalizować algorytm (oj, to musi być zbyt skomplikowane!) pierwszym odruchem jest: ""zróbmy więcej instancji serwisu, niech działają równolegle"". Średniawe rozwiązanie. Zbicie złożoności z O(n*n) do O(n) niespecjalnie da się zastąpić dorzucaniem kolejnych instancji.  Właśnie obecność gotowców w bibliotekach (nie)standardowych sprawia, że dbanie o złożoność obliczeniową da się zrobić elegancko, zwięźle i czytelnie. Dalej można używać tych gotowców, ale odpowiednio je dobierając, tak by wykorzystać ich mocne strony.;"
"Z M$ jest też trochę tak, że wymyślają jakąś super hiper technologię i w sumie nie wiadomo czy zaraz z niej nie zrezygnują, żeby zastąpić ją inną, jeszcze bardziej hiper technologią. :) Tak przecież było z WPF'em, którego można powiedzieć, że porzucono (chociaż ewangeliści M$ powiedzieliby, ze tylko lekko przystopowano rozwój) na rzecz UWP, które okazało się niewypałem. Później jeszcze dokonali samozaorania platformy Windows Mobile co sprawiło, że UWP jeszcze bardziej straciło sens. Naturalnie, żeby było jeszcze ciekawiej, zastanawiają się nad nową, uniwersalną platformą PWA, chociaż pomysł tutaj nie pochodzi od M$... i tak w kółko. Właściwie profesjonalny, ""korporacyjny"" desktop ma dzisiaj do wyboru prawie porzucone WPF i przestarzałe Formsy co już samo w sobie świadczy trochę niekorzystnie o M$.;"
"Teraz w pracy piszę w ruby, ale chciałbym za około 2 lata zmienić pracę. Pisałem coś tam w pythonie i w javie i oba języki są w porządku, więc dlatego patrze teraz na to co jest bardziej przyszłościowe.  W tym momencie myślę, że chce całkowicie wiązać swoją przyszłość z testami automatycznimi i jakością oprogramowania, no chyba że zawód zostanie zastąpiony przez AI :P Próbowałem też pisać w JS'e, ale łagodnie powiem, że mi się nie podobało i to bardzo.;"
Tylko czy zastąpienie mnożeń większą ilością dodawań istotnie przyspieszy obliczenia na dzisiejszych procesorach? Niekoniecznie. Na dodatek może pogorszyć dokładność obliczeń (dodawanie liczb zmiennoprzecinkowych jest mniej dokładne od mnożenia). Raczej bym próbował użyć instrukcji SSE (jeśli mowa o x86) do tego typu operacji. No chyba że chodzi o zadanie typu „zmniejsz ilość mnożeń do 8 za wszelką cenę”.;
"I podobnie jak w wątku poniżej nie chcę się kłócić, że ""funkcyjne jest be"", tylko naprawdę nie rozumiem. Ostatnio mamy wielki trend który głosi, że ""Programowanie funkcyjne jest dużo lepsze niż nie-funkcyjne"". A w szczególności - lepsze niż wszystko, co imperatywne. Niech im będzie. Ale dla mnie programowanie funkcyjne jak i argumentacje za nim sa naprawdę trudne do przełknięcia. Po pierwsze: Dla mnie osobiście jest ono bardzo nieintuicyjne. Ktoś na reddicie twierdził, że nieintuicyjność FP być może wypływa tylko z tego, że ludzie od początku są szkoleni do myślenia imperatywnego. Gdyby wyrzucić języki imperatywne ze szkół i zastąpić je funkcyjnymi, to myślenie funkcyjne byłoby równie intuicyjne. Ja natomiast osobiście odnoszę wrażenie, że po prostu informatyka byłaby jeszcze bardziej znienawidzona przez większość uczniów. Wydaje mi się, że dla człowieka naturalne jest myślenie czasownikami i w kategoriach zmieniającego się stanu. Imperatywnie: Piszę na kartce zdanie Ala ma kota pod akapitem, który napisałem wcześniej. Funkcyjnie: Niech k będzie dowolną kartką. k' jest kartką taką, że cały tekst napisany na k' jest identyczny z tekstem napisanym na k, a dodatkowo na k' jest jeszcze zdanie Ala ma kota poniżej jakiegokolwiek innego tekstu. Nawet pisze się koślawo, co wskazuje, że język naturalny nie powstał do tego rodzaju opisu (bo ludzie tak nie myślą). Językiem ojczystym będzie tu raczej język matematyczny: k' = ιk∈K. tekst(k') = tekst(k) || ""Ala ma kota"". Tutaj dopiero to wygląda naturalnie; ale ludzie nie posługują się takim językiem na co dzień. Gdzie tu są problemy? (a) Wyrzucamy czasowniki, bo one ze swej natury modyfikują stan; zamiast tego mamy myśleć deklaratywnie, a więc opisywać co czym jest, a nigdy: co się z czym odbywa. Jednak ludzie myślą czasownikami. (b) Co za tym idzie: Tworzymy nową kartkę. (WTF? Jak piszę na kartce to nie pojawia mi się stosik kartek po każdym napisanym słowie?) Wyrzucenie czasowników wywołuje eksplozję rzeczowników, wskutek czego zdawałoby się jeden i ten sam obiekt nagle opisywany jest wieloma rzeczownikami, a tak w ogóle to są to zupełnie różne obiekty. Jednak tak nie jest w rzeczywistym życiu, skąd ludzie czerpią intuicje. Krojenie marchewki nie tworzy nowej marchewki. Włączenie telewizora nie powoduje, że w pokoju telewizor włączony zaczyna stać obok identycznego, ale wyłączonego. Skądinąd zastanawiam się, co by było, gdyby przeprowadzić takie badanie: Wziąć tzw. ""zwykłego człowieka"" i programistę funkcyjnego i poprosić o wypowiedź na ten sam temat. Zanotować, jaka była u kogo proporcja rzeczowników do czasowników (wyjąwszy ""być"" i ""mieć"") oraz proporcja czasowników ""być"" i ""mieć"" do innych czasowników. Mam podejrzenia, że programista funkcyjny nawet na co dzień używałby mniej czasowników. Jestem ciekaw, co by z takiego badania wyszło. Bo jeśli moje przypuszczenia są prawdziwe - to jakby potwierdzało to, że bycie programistą funkcyjnym wymaga bardzo głębokich zmian w intuicji. Po drugie: Współdzielony zmieniający się stan bywa wygodny!! Na JPP na studiach był prikaz, by napisać interpreter wymyślonego przez siebie języka w Haskellu. To mnie zmusiło, by tego Haskella wreszcie spróbować. Jakoś nie byłem zachwycony. Wymyśliłem sobie język (imperatywny, ale z kilkoma nowatorskimi pomysłami). Tak - jest monada State. Pomocna przy takiej zabawie. Wśród licznych obiektów odpowiadających za stan mamy np. listę scope'ów. W moim języczku akurat nie było eksplozji możliwych dowiązań do tego samego scope'u, ale wciąż jednak pod pewnymi warunkami można się było dostać do tego samego scope'u z kilku różnych miejsc. To natychmiast zaczęło wymagać, by każdy scope miał swój id. Scope nie mógł być dowiązany bezpośrednio do nazwy zmiennej - nie, nazwa zmiennej miała przechowywać id swojego scope'a. Zamiast zatem prostego przejścia ze zmiennej do scope'a: Pobranie id, pobranie scope'a o tym id ze stanu przechowywanego w monadzie, zrobienie coś z tym scope'em, zapisanie nowego stanu... I tak jednolinijkowiec stawał się co najmniej trójlinijkowcem. (FP ma zmniejszać boilerplate w porównianiu do obiektówki) I co za tym jeszcze idzie: Trzeba nagle eksplicite w ogóle deklarować tę listę scope'ów! W języku imperatywnym w ogóle takiej listy bym nie stworzył. Zamiast tego bym po prostu dołączał odpowiednie referencje. (I co jeszcze za tym idzie, choć to już nie problem z mojego projektu, bo w moim języku z innych przyczyn i tak byłoby to niemożliwe: Problemy z automatycznym zarządzaniem pamięcią. Wyobrażam sobie, że gdybym pisał interpreter w nawet tej nieszczęsnej Javie (interpreter normalniejszego języka niż to, co wymyśliłem), to miałbym garbage collecting za darmo. Ginie ostatnia zmienna, która dowiązywała do jakiegoś scope'u? Brak jest dowiązań do scope'u, ginie i scope. W Haskellu? Ponieważ musi być centralny słownik wszystkich scope'ów, to dowiązanie do scope'a jest i wyciek pamięci gotowy.) Co więcej: to wymuszało, by pojedyczne funkcje były naprawdę bardzo małe i robiły naprawdę tylko jedną rzecz. Dlaczego? Bo po zapisaniu zmian do monady trzeba... Pobrać dane z monady ponownie. Jeśli tego nie zrobię, to będę operował na nieaktualnych danych. To wymusza wyrzucanie każdej operacji pobierz/zapisz do osobnej funkcji, bo inaczej funkcja zaczyna być nieznośna. (Tak, pewnie ktoś zaraz powie, że ""to dobrze bo i w obiektówce funkcje winny być jak najmniejsze - ciesz się, programowanie funkcyjne wymusza na tobie, co i tak powinieneś robić.) Chodzi mi o to, że - jak dla mnie - w FP trzeba bardzo pilnować, by się stan nie rozsynchronizował. Ciągłe tworzenie nowych i jeszcze nowych obiektów łatwo może doprowadzić do tego, że skądś dojdziemy do nieaktualnych danych. A teraz teoretycznie: Gra. Chociażby ta, którą dłubię. To wydaje się być po prostu w opór imperatywne: Jeden stworek wali drugiego więc drugi traci 20 HP. Chcę wykorzystać fakt, że można modyfikować stan globalny! Bo teraz za darmo mam już to, że to zmniejszenie się HP jest widoczne zewsząd: z listy stworków drużyny pojedynczego gracza, ze stworka, który właśnie zadał cios (referencja o wdzięcznej nazwie opponent), wszytkie efekty które zależą od HP też będą miały dostęp do aktualnego HP... W Haskellu nie miałbym tego. Gdybym po prostu zrobił dowiązania, to te dowiązania zdezaktualizowałyby się z chwilą zadania ciosu. A więc znów - centralny rejestr wszystkich stworków, jakieś sztuczne id tych stworków pewnie (aktualny przeciwnik nie jest zatem stworkiem tylko jakąś dziwną liczbą, na podstawie której trzeba dopiero pobrać stworka), i pewnie jeszcze to samo z wieloma innymi rzeczami, gdzie obecnie wykorzystuję dowiązania. Globalny stan jest be - ale jak stworek oberwie to ja naprawdę chcę, żeby ze wszystkich innych miejsc w kodzie było widać zmniejszone HP!! A przecież w myśl paradygmatu funkcyjnego to jest właśnie tragedia, jeśli zmiana w jednym miejscu kodu propaguje się nagle do innych miejsc w kodzie. Tyle że dla mnie wyrzucenie takich propagacji wymusza komplikowanie kodu, jak opisałem na przykładach wyżej. Jednak Uznaję, że powyższe problemy mogą po prostu wynikać z tego, że nigdy nie nauczyłem się porządnie pisać funkcyjnie. Może po prostu próbuję przenosić praktyki, nawyki i intuicje z jęz. imperatywnych do jęz. funkcyjnych, widzę, że one jakoś nie pasują, więc odrzucam Haskella podczas gdy powinienem odrzucić te nawyki - czyli oduczyć się wszystkiego, co już umiem, i uczyć się na nowo. Może zatem dla własnego dobra trzeba by się zmusić do pisania fukncyjnego, i powrócenia do tematu za pół roku albo i rok nawet - może po takim ćwiczeniu też bym nagle zaczął dostrzegać same zalety FP i już nigdy bym nie chciał z własnej woli pisać imperatywnie. Nie za bardzo widzę, jak to zrobić w praktyce. W pracy mam Pythona na razie - nie chcę wykorzystywać zadań z pracy do nauki paradygmatu, z którym na razie nie za bardzo mi po drodze. Ucierpiałaby praca. Uczyć się tego sam dla siebie? Sam dla siebie piszę grę w C# - jak zacznę przepisywać ją na Haskella to chyba nigdy jej nie zrobię. Tzn będzie to może interesujące ćwiczenie pod wzgl. nauki Haskella, ale raczej będzie wymagało porzucenia marzeń o ukończeniu jej. Tak, niby na upartego w C# DA SIĘ pisać funkcyjnie, ale znów to samo... zbyt wielkie skupienie na tym, JAK to mam robić doprowadzi do tego, że tego nie zrobię. Tym bardziej, że obecnie dostrzegam tylko upierdliwości na myśl o porzuceniu wszelkich side-effectów. Uczyć się funkcyjnego jako trzecie zadanie, obok pracy i powyższej gry? Sorry.. doba ma 24h. A jednak przejść nad tym do porządku dziennego nie mogę. Za wiele ludzi śpiewa peany na cześć FP. Naprawdę może być tak, że nie ucząc się go, krzywdzę wyłącznie samego siebie. I z własnego wyboru pozostaję niekompetentny. W zasadzie nie wiem, co teraz z tym zrobić.;"
"AI już pisze kod w Javie: https://www.dobreprogramy.pl/Sztuczna-inteligencja-juz-dzis-pisze-kod-za-programiste-czy-jutro-go-zastapi,News,87796.html niedługo programiści w ogóle przestaną być potrzebni;"
"Do zmiennej typu string próbujesz przypisać wiele wartości, do tego służą tablice. .Select tylko zaznacza komórki, zastąp go .value Popatrz na poniższy kod: Sub laczenie()     Dim a() As Variant     Dim b() As Variant     Dim c() As Variant          a() = Range(""a1:a4"").Value     b() = Range(""b1:b4"").Value          ReDim Preserve c(1 To UBound(a), 1 To 1)          For i = 1 To UBound(c, 1)         c(i, 1) = a(i, 1) & "" "" & b(i, 1)     Next i          Range(""c1:c4"").Value = c()  End Sub;"
"A programowanie nie łączy cię z ludźmi, którzy tworzą g*wniany kod? Tak w ogóle to pani profesor socjologii (czy czego tam) powiedziała, że programowanie będzie niedługo zastąpione przez AI, bo programiści tylko klikają i takie powtarzalne zadania łatwo zautomatyzować. Takie mają laicy myślenie o programowaniu. Warto się nimi przejmować?;"
"C# zagarnie wielka część rynku, jako język na wszystkie platformy po aktualizacji Listopad '20, Java nadal będzie bardzo popularna bo w 5 lat jej się nie zastąpi, dodatkowo zagarnie większość funkcjonalności od Scali czy Kotlina, Mam nadzieję, że hype na Pythona ucichnie bo już niedobrze sie od niego robi, Mam nadzieję, że ludzkość wymyśli cos lepszego od JS, np zaczną używać Darta(?),;"
"Powstanie kolejny język na JVM, o którym się będzie mówiło, że zastąpi Javę wraz z wyjaśnieniem, dlaczego Kotlin tego nie zrobił. Java 8 dalej będzie używana do chwalenia się, że w firmie są najnowsze technologie.;"
"Na oko przyszłość to interfejsy bardziej przyjazne człowiekowi:  Alexy i inne asystenty, komunikacja za pomocą głosu Wearables typu Apple Watch które mierzą tętno, ciśnienie i h*** wie co tam jeszcze. Już teraz Apple Watch ostrzega jak siedzisz bez ruchu ponad 1h przed kompem :P Generalnie tego typu urządzenia zastąpią zapewne trenerów osobistych, będą nie tylko pomocą w dbaniu o formę ale również o zdrowie.  Klawiatura i ekran staną się przeżytkami których używa tylko niewielka część społeczeństwa (programiści), ""normalni"" ludzie będą się komunikować z maszynami za pomocą głosu. Ekrany nawet te LCD to zabierające miejsce na biurku rupiecie. W przyszłości będziemy mieli urządzenia w stylu google glass które wyświetlą ci przed oczami obraz jaki chcesz, gdzie chcesz i w jakiej odległości chcesz. Przyjazne oczom i super przenośne. Zapewne co bardziej techniczni będą instalować adblockery, będą również VR apki pomagające w parkour czy jeździe na deskorolce lub innym cudzie. Znając naturę ludzką będą też pewnie inne apki np. dorabiające wąsy szefu itp. Sporo aplikacji będzie pisana poprzez naukę (tak jak robią to dzieci). Programiści będą przypominać mix data-science i AI-dev'a, programowanie będzie polegać na stworzeniu odpowiedniego zbioru uczącego oraz zapewnieniu odpowiedniego marginesu błędu. OK trochę się zapędziłem, ale tak może wyglądać przyszłość za 50 lat... A teraz wracając na ziemię: świat idzie w mobile. Cokolwiek co dobrze działa na smartphone ma szansę na sukces. Osobiście obstawiam aplikacje-strony www bazujące na WASM'ie. Ale apki natywne też powinny się trzymać nieźle - zwłaszcza że niektóre elementy korporacyjne (Apple) będą przeciwne obchodzeniu ich sklepów z niezwykle wysoką marżą.;"
"A co do zastępowania zawodów przez maszyny. To ja się w ogóle zastanawiam jak to jest. Trąbią że kasjerzy zostaną zastąpieni przez maszyny (w niektórych tesco tak jest )ale jakoś tego nie realizują(najprostsza czynność do zastąpienia). Chyba za 30 lat. Pomijając fakt, że gdzieś czytałem, że chyba ze 30% zawodów jest bezsensownych i coraz bardziej się z tym zgadzam.;"
"Szarpnąłbym się na zastąpienie macierzy listami – kod będzie ”ładniejszy” i nie trzeba będzie implementować quick sorta (co jest bez sensu), co najwyżej samą metodę porównującą elementy. Zresztą uzależnianie projektu od modułu Crt w tym przypadku jest kompletnie bez sensu, bo jedyne czego z tego modułu używasz to procedury ClrScr. A wywołanie tej procedury nie jest kluczowe dla działania kodu (czyli zbędne). Cały kod natomiast wygląda na bardzo stary, tak jakby był pisany 40 lat temu w TP. Poza tym pasowało by wybrać lepsze nazwy dla typów zmiennych, a sam kod sformatować.;"
"Szarpnąłbym się na zastąpienie macierzy listami – kod będzie ”ładniejszy” i nie trzeba będzie implementować quick sorta (co jest bez sensu), co najwyżej samą metodę porównującą elementy. Masz na myśli użycie gotowców z fcl-stl Nie pisałem kodów obiektowo w Pascalu Chętnie bym zobaczył przykład użycia tych gotowców z fcl-stl Implementowanie quick sorta bez sensu  ? Jakimś algorytmem musimy jednak tę tablicę posortować Wybrałem quick sorta bo jego kod jest dość krótki i można go zapisać za pomocą jednej procedury a przypadek pesymistyczny nie występuje zbyt często Poza tym chciałbym aby kod mógł być skompilowany także za pomocą innych kompilatorów niż fpc Modułu Crt użyłem także do czytania klawiszy aby zapętlić główny blok programu Gdybym dane czytał z pliku to pewnie z modułu Crt można by było zrezygnować  Cały kod natomiast wygląda na bardzo stary, tak jakby był pisany 40 lat temu w TP. Poza tym pasowało by wybrać lepsze nazwy dla typów i zmiennych i go sformatować. W maju tego roku minie 20 lat jak zdałem maturę a Pascal był pierwszym językiem jakiego się uczyłem więc jeszcze mniej niż 20 lat temu uczyli pisać kod w ten sposób W Pascalu uczyłem się programowania strukturalnego , właśnie używając TP Co do lepszych nazw dla typów i zmiennych to jest drobnostka , masz jakiś pomysł na nie ? W TP nie ma tablic dynamicznych poza tym jest ograniczenie pamięciowe na tablice więc na pewno w TP kod się nie skompiluje Jeśli chodzi o obecne rozwiązanie to nie widziałem procedury zwalniającej pamięć na tablicę Czyżby zastosowano tutaj garbage collectora Chciałbym zamienić dynamiczną tablicę na listę dwukierunkową (być może cykliczną) ale nie mam pomysłu jak to zrobić;"
Jak to mówią: każdego specjalistę można zastąpić skończoną liczbą stażystów :);
"Założenie jest błędne. Algorytmy, które piszą algorytmy istnieją od dawna. Już w okolicach 2008 dostępne były liczne generatory (czyli algorytmy), które po określeniu przez użytkownika danych w postaci prostego schematu bazy danych, generowały działający program. Tego typu rozwiązania rynku nie zawojowały, ale są rozwijane do dzisiaj i mają swoją niszę. Problemem jest to, że ciężko w ten sposób zaimplementować nawet proste wymagania wynikające poza typowego CRUD'a — a to tylko czasem spełnia oczekiwania klienta. Dodatkowo, taka sieć neuronowa to w sumie algorytm, który potrafi modyfikować sam siebie. Prawidłowe pytanie powinno brzmieć. Co się stanie, kiedy powstanie algorytm, zdolny do analizy wymagań/potrzeb drugiego człowieka i stworzenia na podstawie ich działającego programu oraz do dalszych modyfikacji programu, z uwzględnieniem rozwiązywania konfliktów wymagań i propozycji ich rozwiązania. Zakładamy tutaj, że tym człowiekiem będzie analityk biznesowy, a w późniejszym etapie osoba nietechniczna. Obawiam się jednak, że taka SI będzie w stanie zastąpić każdego z nas, może poza psychologami. Ktoś wspomniał o tym, by przekwalifikować się na piekarza, ale to też kiepski pomysł wypiekanie chleba, mieszanie ciasta, czy jego wyjmowanie z pieca, to wszystko procesy dość łatwe do zautomatyzowania, nawet dziś, tylko niezbyt się to opłaca. Częściowa automatyzacja jednak już i tak nastąpiła w tym zakresie, chociażby w piekarniach supermarketów. Ogólnie uczenie maszynowe rozwinęło się w ostatnich latach, ale bardziej pod kątem dostępności dla szarego developera i możliwościami samych komputerów, niż pod kątem jakiejś wielkiej rewolucji w samych teoriach, które są dość stare. Jednak dzięki temu możliwe jest stworzenie autonomicznych samochodów (tylko czasem kogoś rozjadą, tak samo, jak ludzki kierowca) lub algorytmów pozwalających orzekać jak sędzia (też czasem się pomyli) - więc moim zdaniem jest to wielki sukces. Być może kiedyś stworzymy sztucznego człowieka, ale osobiście wolałbym nie, mam na ten temat zdanie podobne jak Hawking.;"
"Weź mój kod, wywal szablony. W pieszym szablonie po prostu usuń T, w drugim T zastąp jakimś typem (np double) i gotowe (no prawie, bo trzeba dodać parę funkcjonalności, które miałeś, a nie były treścią zadania).;"
Każdą poprawną transkrypcję można zastąpić skończona liczbą studentów.;
"wg tej definicji na wikipedii to programowanie jest jednocześnie sztuką, rzemiosłem jak i inżynierią:  W pracy programisty widzę element kreatywny - musisz wymyśleć jak coś zrobić czyli kreatywność (co nie zawsze jest oczywiste, trzeba czasem przemyśleć różne rozwiązania, pogłówkować), jest element doświadczenia (trzeba popróbować różne rzeczy, i wysuwać wnioski na podstawie swoich błędów i sukcesów z przeszłości), jak i gra rolę wiedza techniczno-naukowa (opis algorytmów w książce czy spis wzorców projektowych to przykłady takiej wiedzy).  Jeśli nie rozwiązujesz problemów jako programista, to twoja praca jest w kolejce do zastąpienia przez AI, bo generatory kodu wg ustalonych schematów już są.;"
"Ta... generatory kodu to już miały powstać w latach 80. Twoja praca chyba będzie prędzej zastąpiona przez innego programistę, bo nie wiem jak można rak bardzo nie rozumieć tekstu ;) Wszak odnoszę się do pracy juniora. Nikt zdrowy nie zleci juniorowi odkrywczej pracy. Pisałem kilka systemów real time w których trzeba było wymyślić pare sposobów na przetwarzanie live pewnych danych. Samo opracowanie sposobu było odkrywcze i trwało z polowe czasu przeznaczonego na projekt ale potem w kodzie było to z 20% całości a reszte 80% oczywistego kodu też musiał ktoś napisać i potem zintegrować - tutaj wkraczają juniorzy.;"
"Na backendzie python nie będzie popularny. Czysty webowy backend lepiej jest argumentować oraz robic w innych językach. Python dopiero jest ok jesli musisz miec biblioteki naukowe i po prostu robisz web w pythonie by zmniejszyć liczbę zależności. Pythona można argumentować ze jest to poprawny php, dobry język do prototypwania, itp ale te zalety moim zdaniem miały wartosc 6-10 lat temu. Obecne możliwości pythona łatwo jest zastąpić czy nawet przebić innym językiem.;"
"Ja nic nie muszę się odnosić. Pierwsze, najważniejsze - bo nie znam specyfiki projektu, wymagań, stacku technologicznego, dostępności bibliotek, developerów i wielu innych zmiennych, które wpływają na wybór poszczególnych rozwiązań. W wielu złożonych projektach, używa się wielu stacków, a każdy stack odpowiada za co innego. To ty napisałeś Ten jezyk jest swietny do prostych zadan. I krotkich. A nie do nawalania skomplikowanej logiki. więc to udowodnij, bo ja go spotkałem w wielu zaawansowanych zastosowaniach, w tym też takich, które na pierwszy rzut oka wymagały ""wydajności"". Na razie, póki co, w jakimś szale przeklejasz jaki to Go jest wspaniały, wklejając różne niepowiązane wypowiedzi różnych devów, kompletnie nie podając specyfiki danego projektu. Ja np. jestem programistą Go (Pythona też) i na tym zarabiam i sam widziałem jak kilka projektów w Go padło, bo ktoś zapomniał sprawdzić, czy będą właściwe biblioteki do właściwego celu (o taki przypał). Nie dotyczy tylko zresztą samego Go (widziałem to samo w Javie i Pythonie). Także teraz, jak w dyskusji o architekturze (daj Bóg, że czasem się trafią, bo to już sukces) wyskakuje jakiś mądrok, co twierdzi piszmy to w Go, bo jest szybkie, zanim w ogóle zaczniemy dyskusje o problemie, to już wiem, że mamy zealota w zespole i będzie śmiesznie. Jak to zealot od klienta, to najcześciej będzie śmieszno i straszno zarazem. Język programowania to tylko narzędzie. W pewnych zastosowaniach gorsze lub lepsze. Ale z doświadczenia wiem, że powodzenie projektu zależy głównie od architektury - jak ta jest dobra, można pisać nawet skrypty w cmd.exe i będzie to działać i zadowalać biznes. A jak jest zła, to nawet najlepszy język (nie ma takiego) projektu nie uratuje i na nic się zdadzą jego wszelkie zalety, którym podraja się tylko część developerów. Choć osobiście wolę Go od Pythona, to uważam (pewnie nie tylko ja), że Python jest ""good enough"" do wielu zastosowań. Już widziałem próby jego zastępowania np. Rustem, bo jest 100x szybszy i zdziwienie, że program nie chodzi 100x szybciej, bo niestety, ale bottleneck był zupełnie gdzie indziej. Widziałem już projekt, którym Jave zastąpiono Go, do Kafki, bo ktoś chciał mieć łatwiejszy deploy i to przyklepał. Zapomniał tylko, że użycie pewnego liba na cgo od confluenta (wrappera na librdkafka) wywali zalety Go i sprowadzi kilka ""extra"" problemów do projektu (i finalnie utrudni też deploy). Dynamiczne typowanie znowu, to zaleta i wada, zależy od kontekstu i potrzeb, obecne lintery i IDE na tyle są dobre i trzymają wszystko przysłowiowo ""za morde"", że można mieć Pythona w dużym projekcie z poprawnością typów niemal identyczną jak w statycznie i silnie typowanych językach. Zaś dynamiczne typowanie, pozwala na szybsze prototypowanie, przykładowa zaleta, mówiąc wprost: po tygodniu zespół prototypujący w Pythonie będzie już wiedział, czy iść w dany serwis (rozwiązanie), bo będzie już go miał ""na kolanie"" napisanego, a Ty po tygodniu, będziesz się jeszcze użerał z typami w C/Java/Go/Rust.  Znaczy, to rozumiem Twój argument? Bo się gdzieś rekrutowałeś i ""tam było""? I w ogóle, kto tu jest niby fanem? Nie widziałem, by ktoś wychwalał Pythona nadmiernie, co najwyżej pisał, że się nadaje na backend, co jest oczywiście prawdą. Czy się nadaje lepiej już gorzej, to patrz moje pierwsze zdanie.;"
"Widzę, ze dużo szczegółów padło  co może i prawdopodobnie będzie zoptymalizowane żeby nie używać ""ręcznego"" kodu profilowanie, a nie domysły  Dodam, do gorącej herbaty, że nie ma zamienności zmiennych w klasie i zmiennych lokalnych w metodzie. Powiem jeszcze bardziej, nie ma zmiennych w klasie, a są pola. To trzeba sobie mocno w głowie oddzielić. Pola są informacją o wiele bardziej trwałą, niż doraźne zmienne. Po rozdzieleniu w głowie j/w drugi temat: nazwy. O ile ix jest dla mnie 'spoko' nazwą zmiennej lokalnej o zakresie 3 linii, to fatalną nazwą pola (czy zmiennej o dużym zakresie). Źle użyta nazwa ma razić, nie dać spać itd i nakłonić do refaktoringu. Tak się składa, że w 95% przypadków dążenie do czytelnego, stylowego kodu polepsza optymalizację (pozostałe 5% to dodanie poziomu abstrakcji, może nieco osłabić szybkosć). Na gruncie tego wątku: najbardziej lokalny charakter zmiennych, jaki jest możliwy, jest czynnością ku dobremu stylowi, i daje kompilatorowi okazję optymalizacji. Współczesny CPU ma więcej rejestrów niż dawniej, ale dalej to skończona ilość, niech tam pracują zmienne najbardziej lokalne. Dodam, że arytmetyka wskaźnikowa to przypuszczalnie była szybsza od indeksowej (tablicowej), ale to było trzydzieści lat temu. for (; In < In_RowEnd; In++, Out++) *Out = *In;   to nie tylko można zastąpić funkcją z karty graficznej, ale memcpy czy czymś, co się zinlinuje. Po (drugie??? chyba już siedemnasta myśl), wątpię, by porównanie końca zakresu na wskaźnikach było szybsze niż na integerach integerze (jednym), chętnie o mniejszym zakresie (i zmienne silnie lokalne). Dwa długie inkrementy, zamiast jednego (krótkiego) itd Ten zapis ma jeden cel: czuć się jak hacker. Gdybym miał pisac ręcznie, bym dał: for(short i=0; i< row_length; i++) a[i] = b[i];   Z drobiazgów, które są pro-stylowe, a dają kompilatorowi szanse do wykazania się, są const i constexpr @Wibowit wolał bym, zebyś wycofał się z porady  Ta klasa ma przed sobą DUŻY zakres analizy, co jest polem, jakim jest polem itd, niech to najpierw się stanie. W sumie, to nie ma pewności czy klasa to naprawdę Image, czy coś innego (ImageBuffer ?) a metoda to Draw. Na pewno w obecnym kształcie nie jest to klasa, która da się użyć w grze, poza testem wydajnościowym - tu jeszcze wiele będzie się działo;"
"Na studiach prowadząca opowiadała nam, że teraz rodzice zmuszają małe dzieci do programowania, dzieciaki tego nienawidzą, nie wiedzą po co to robią, ale rodzice ich zmuszą bo są dobre pieniądze :) Gnije bo automatyzacja nie dotyczy jedynie kasjerek, kierowców, prawników czy lekarzy (systemy eksperckie lepiej diagnozują choroby niż ludzie) ale też programistów. Mamy coraz lepsze narzędzia i o ile nie zastąpi nas raczej AI to będzie mocno wspomagać, już teraz w takim django czy dot necie można klepać projekty w ekstremalnym tempie w dużo mniejszych zespołach niż dawniej. A co będzie za 20 lat jak te gówniarze zaleją rynek swoimi wymuszonymi umiejętnościami?  Ten rynek [CIACH!] to jest pewne. Kto się załapie i będzie miał ładne CV ten się załapie a reszta będzie za miskę ryżu pracowała, z resztą zarobki programistów na zachodzie nie są już tak wcale zajebiste;"
"Może ta popularność wynika z zastąpienia javy pythonem na amerykańskich uczeniach. W każdym razie dla mnie jest dziwne czemu tak i tak jest mało ofert do projektów w pythonie. Jeszcze sytuację z web jestem w stanie zrozumieć, ale przy ciekawszych rzeczach to mocno słabo.;"
"Python i PHP to najłatwiejsze języki programowania na rynku. Potem Ruby i JavaScript. Python w bogatszych krajach zyskuje na popularności. Jak w Polsce zastąpi wysłużony Pascal na uczelniach, wtedy dopiero boom na Pythona ruszy w tym kraju. Już teraz developerzy przechodzą z PHP na Pythona z frameworkiem Django. Taki reddit napisany jest w Pythonie i frameworku Pylons/Pyramid. Jak najbardziej Python może być głównym językiem. Kiedyś czytałem taką książkę bodajże 10 lat temu, gdzie zawodowi programiści przewidywali, że takie języki jak Python i Ruby to przyszłość programowania. Wraz z rosnącą mocą obliczeniową komputerów. I mieli rację, Python jest w NASA, Cern, AI, Robotyce, Motoryzacji, Web, Mobile. https://www.tensorflow.org https://www.dobreprogramy.pl/Python-zyskuje-popularnosc-w-bogatych-krajach-szybciej,News,83062.html;"
"Ale ja nie napisałem, że Python ma zastąpić Jave, tylko że jest w różnych dziedzinach. Być może Jave zastąpi Scala, Kotlin, a może całkowicie zrezygnują z takiego Monolita na rzecz nowoczesnych mikroserwisów. Zachód wyznacza trendy w IT. Modularność zdobywa popularność, patrz Java 9, Plasma, QT 5.;"
"Mam rozterkę i potrzebuję głosów rozsądku (tl;dr na dole posta). W planach mam spróbować kiedyś wskoczyć do projektów z okolic finansowych. Robiłem już lekkie rozeznanie, bo próba wskoczenia do tych projektów wymaga sporo czasu poświęconego na naukę we własnym zakresie. Tutaj pojawia się pierwszy problem. Sporo z nich wykorzystuje między innymi C++ i jest to w 9/10 ofert jeden z wymogów koniecznych. C++ ostatni raz używałem na studiach w standardzie C++98. Fakt, że był to jeden z lepiej opanowanych języków ale było to tak dawno, że nic z tego nie pamiętam. Później były inne wytwory około programistyczne jak Java czy C# (bez urazy dla pracujących w tym). Jakiś czas temu poznałem nieco Rust dla samego siebie. Nie poznałem jeszcze wielu zagadnień tego języka i czytając różne kody są rzeczy, które nic mi nie mówią. Dlaczego wspominam o Rust? Wiele wskazuje na to, że jest to solidny kandydat może nie tyle do wyparcia C++ ale do zastąpienia w wielu różnych zastosowaniach gdzie potrzeba wydajności i względnego bezpieczeństwa. Ma to zresztą już miejsce w różnych projektach i tych aktualnych i tych przyszłych. Wspominam też dlatego, że jeżeli ostatecznie jednak nie pójdę w to C++ to skręcę w kierunku Rust. Istnieje szansa, że nie uda mi się wskoczyć do działki o której myślę i wtedy nauka C++ może zabrać tylko czas. Chyba, że jestem w błędzie i przegapiłem proces ewolucji tego języka i jego wykorzystania? Ktoś z szanownych czytających wie coś więcej na temat wykorzystania C++ poza desktopem? Osobiście znam kilka przypadków gdzie jakieś usługi dużych aplikacji są oparte o C++ ewentualnie jeszcze AI/ML ale na tym kończy się moja wiedza. Kolejna sprawa jest taka, że zapoznanie się ze standardem 17/20 (raczej nowszy) nie gwarantuje jego zawodowego wykorzystania, bo projekty do których chcę się dostać mogą być odrobinę wstecz. tl;dr Zastanawiam się czy w 2020 roku nadal jest sens wchodzenia w C++ podczas gdy mamy Rust. Standard 20 jest nowy, 17 powinien już funkcjonować w projektach. Jednak nie jestem pewny jaki % zajmują te nowsze standardy w aktualnych projektach? Jakie znacie domeny w których jeszcze wykorzystuje się C++ (poza embedded/desktop) we w miarę świeżym standardzie?;"
"Jak jesteś na studiach to łatwo znaleźć pracę np w takim Krakowie, bo stażów jest trochę i jak ktoś up pisał - korpo chłonie. Niemniej jednak jest to siedzienie w dużych wielomilionowych kobyłach przy urzymaniówce jak np w Nokii. Stąd siłą rzecz skoro projekty są stare nie będzie nowoczesnych standardów i tak faktycznie jest. Wymaga się nowszych, bo jak jest coś nowego to używa się nowych możliwości na tyle na ile kompilator daje taką możliwość bez wysypania się starego bryka. (np max c++ 11) Nowych projektów nikt nie zaczyna w c++, bo jest wiele języków prostszych, którymi można c++ zastąpić. Są takie branże gdzie dalej ta technologia dominuje, niemniej jednak wiele rzeczy już zostało napisane. Podsumowując:  jeżeli nie wbijesz się na rynek podczas studiów, albo zaraz po jako świeży absolwent to mówię od razu, że ** nie masz szans** wejść jako samouk, ponieważ tutaj rekrutuje się głównie do korpo a na dodatek ciężko zrobić projekt jako niedoświadczony który byłby użyty tylko do c++, więc odpuść sobie. jeżeli nie masz wybranej konkretnej branży którą bardzo lubisz i chcesz w niej zostać to szczerze mówiąc są obecnie lepsze technologie do zarabiania pieniędzy. ilość ofert pracy nie będzie rosnąć i trzeba się z tym pogodzić. Na pewno dla juniorów nie będzie rosnąć. Dla starych utrzymaczy kodu tak. bardzo ciężko w Polsce znaleźć fajną pracę w c++ poza utrzymaniówką i myślę, że śmiało można stwierdzić, że prawie jej nie ma. Dlatego musisz się dostosować do takiego klimatu. Outsourcing, analiza/konfiguracja przez 80% sprintu a następnie dodanie jednego ifa, żeby dzialało. Nie nauczysz się programować, bo z roku programowania wyjdzie Ci w praktyce może dwa miesiące ze względu na ogromną ilość domenowej zabawy i analizowania kodu.;"
"To trzeba w końcu zrobić! Czarną listę tematów, tak jak na elektrodzie! Moje propozycje:  Mam 30 lat i chciałbym zostać programistą. Czy mam jeszcze szansę? Czy programistów zastąpi AI? Czy studia są potrzebne? Co minimalnie trzeba ogarnąć żeby dostać pracę w IT? Czemu odrzucają moje CV? Przecież dałem link do Githuba Jaki język wybrać na początek? Ten temat  Jakby się uprzeć to można by zatrudnić jakiś machine learning do detekcji tego typu tematów a potem wklejać standardową odpowiedź, albo jeszcze lepiej, wstawić całą opracowaną wcześniej przez specjalistów dyskusję!;"
"Witam, Czy jest ktoś w stanie pomóc mi w modyfikacji kodu. Głowna zasada gry mówi, że statki nie mogą dotykać się bokami ani krawędziami. Tutaj jej brakuje. Niestety programowanie nie jest moją silną stroną. Bardzo proszę o pomoc. (function() {  // Global Constants var CONST = {}; CONST.AVAILABLE_SHIPS = ['carrier', 'battleship', 'destroyer', 'submarine', 'patrolboat']; // You are player 0 and the computer is player 1 // The virtual player is used for generating temporary ships // for calculating the probability heatmap CONST.HUMAN_PLAYER = 0; CONST.COMPUTER_PLAYER = 1; CONST.VIRTUAL_PLAYER = 2; // Possible values for the parameter `type` (string) CONST.CSS_TYPE_EMPTY = 'empty'; CONST.CSS_TYPE_SHIP = 'ship'; CONST.CSS_TYPE_MISS = 'miss'; CONST.CSS_TYPE_HIT = 'hit'; CONST.CSS_TYPE_SUNK = 'sunk'; // Grid code: CONST.TYPE_EMPTY = 0; // 0 = water (empty) CONST.TYPE_SHIP = 1; // 1 = undamaged ship CONST.TYPE_MISS = 2; // 2 = water with a cannonball in it (missed shot) CONST.TYPE_HIT = 3; // 3 = damaged ship (hit shot) CONST.TYPE_SUNK = 4; // 4 = sunk ship  // TODO: Utwórz ten lepszy kod OO. CONST.AVAILABLE_SHIPS powinna być tablicą // obiektów, a nie dwóch równoległych tablic. Albo lepiej // rozwiązaniem byłoby zapisanie ""USED"" i ""UNUSED"" jako właściwości // pojedynczy obiekt statku. // Te liczby odpowiadają CONST.AVAILABLE_SHIPS //1) ""pancernik"" 2) ""niszczyciel"" 3) ""okręt podwodny"" 4) ""patrolboat"" // Ta zmienna jest używana tylko wtedy, gdy DEBUG_MODE === true. Game.usedShips = [CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED]; CONST.USED = 1; CONST.UNUSED = 0;  // Game Statistics function Stats(){ 	this.shotsTaken = 0; 	this.shotsHit = 0; 	this.totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 	this.totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 	this.gamesPlayed = parseInt(localStorage.getItem('gamesPlayed'), 10) || 0; 	this.gamesWon = parseInt(localStorage.getItem('gamesWon'), 10) || 0; 	this.uuid = localStorage.getItem('uuid') || this.createUUID(); 	if (DEBUG_MODE) { 		this.skipCurrentGame = true; 	} } Stats.prototype.incrementShots = function() { 	this.shotsTaken++; }; Stats.prototype.hitShot = function() { 	this.shotsHit++; }; Stats.prototype.wonGame = function() { 	this.gamesPlayed++; 	this.gamesWon++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'win', this.uuid); 	} }; Stats.prototype.lostGame = function() { 	this.gamesPlayed++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'lose', this.uuid); 	} }; // Zapisuje statystyki gry do lokalnego magazynu, a także przesyła je, gdzie użytkownik umieścił // ich statki do Google Analytics, aby w przyszłości mogłem zobaczyć // które komórki ludzkie są nieproporcjonalnie nastawione do umieszczania statków. Stats.prototype.syncStats = function() { 	if(!this.skipCurrentGame) { 		var totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 		totalShots += this.shotsTaken; 		var totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 		totalHits += this.shotsHit; 		localStorage.setItem('totalShots', totalShots); 		localStorage.setItem('totalHits', totalHits); 		localStorage.setItem('gamesPlayed', this.gamesPlayed); 		localStorage.setItem('gamesWon', this.gamesWon); 		localStorage.setItem('uuid', this.uuid); 	} else { 		this.skipCurrentGame = false; 	} 	 	var stringifiedGrid = ''; 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			stringifiedGrid += '(' + x + ',' + y + '):' + mainGame.humanGrid.cells[x][y] + ';\n'; 		} 	}  	if (!DEBUG_MODE) { 		ga('send', 'event', 'humanGrid', stringifiedGrid, this.uuid); 	} }; // Aktualizuje pasek boczny z aktualnymi statystykami Stats.prototype.updateStatsSidebar = function() { 	var elWinPercent = document.getElementById('stats-wins'); 	var elAccuracy = document.getElementById('stats-accuracy'); 	elWinPercent.innerHTML = this.gamesWon + "" of "" + this.gamesPlayed; 	elAccuracy.innerHTML = Math.round((100 * this.totalHits / this.totalShots) || 0) + ""%""; }; // Zresetuj wszystkie statystyczne statystyki gry do zera. Nie zresetuj uuid. Stats.prototype.resetStats = function(e) { // Pomiń statystyki śledzenia do końca bieżącej gry lub innego // odsetek dokładności będzie niewłaściwy (ponieważ śledzisz // trafienia, które nie zaczęły się od początku gry) 	Game.stats.skipCurrentGame = true; 	localStorage.setItem('totalShots', 0); 	localStorage.setItem('totalHits', 0); 	localStorage.setItem('gamesPlayed', 0); 	localStorage.setItem('gamesWon', 0); 	localStorage.setItem('showTutorial', true); 	Game.stats.shotsTaken = 0; 	Game.stats.shotsHit = 0; 	Game.stats.totalShots = 0; 	Game.stats.totalHits = 0; 	Game.stats.gamesPlayed = 0; 	Game.stats.gamesWon = 0; 	Game.stats.updateStatsSidebar(); }; Stats.prototype.createUUID = function(len, radix) { 	var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), 	uuid = [], i; 	radix = radix || chars.length;  	if (len) { 		// Compact form 		for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix]; 	} else { 		// rfc4122, version 4 form 		var r;  		// rfc4122 requires these characters 		uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; 		uuid[14] = '4';  		// Fill in random data.  At i==19 set the high bits of clock sequence as 		// per rfc4122, sec. 4.1.5 		for (i = 0; i < 36; i++) { 			if (!uuid[i]) { 				r = 0 | Math.random()*16; 				uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r]; 			} 		} 	}  	return uuid.join(''); };  // Obiekt menedżera gier // Konstruktor function Game(size) { 	Game.size = size; 	this.shotsTaken = 0; 	this.createGrid(); 	this.init(); } Game.size = 10; // Domyślny rozmiar siatki to 10x10 Game.gameOver = false; // Sprawdza, czy gra jest wygrywana, a jeśli tak, ponownie zainicjuje grę Game.prototype.checkIfWon = function() { 	if (this.computerFleet.allShipsSunk()) { 		alert('brawo!'); 		Game.gameOver = true; 		Game.stats.wonGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} else if (this.humanFleet.allShipsSunk()) { 		alert('srobuj ponownie'); 		Game.gameOver = true; 		Game.stats.lostGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} }; // strzela do docelowego gracza w siatce. // Zwraca {int} Constants.TYPE: Co odkryto Game.prototype.shoot = function(x, y, targetPlayer) { 	var targetGrid; 	var targetFleet; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		targetGrid = this.humanGrid; 		targetFleet = this.humanFleet; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		targetGrid = this.computerGrid; 		targetFleet = this.computerFleet; 	} else { 		// Should never be called 		console.log("".................""); 	}  	if (targetGrid.isDamagedShip(x, y)) { 		return null; 	} else if (targetGrid.isMiss(x, y)) { 		return null; 	} else if (targetGrid.isUndamagedShip(x, y)) { // zaktualizować planszę / siatkę 		targetGrid.updateCell(x, y, 'hit', targetPlayer); // WAŻNE: Ta funkcja musi być nazwana _after_ aktualizacją komórki do ""trafienia"" // ponieważ zastąpi klasę CSS ""zatopioną"", jeśli okaże się, że statek został zatopiony 		targetFleet.findShipByCoords(x, y).incrementDamage(); // increase the damage 		this.checkIfWon(); 		return CONST.TYPE_HIT; 	} else { 		targetGrid.updateCell(x, y, 'miss', targetPlayer); 		this.checkIfWon(); 		return CONST.TYPE_MISS; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdej z 100 komórek siatki Game.prototype.shootListener = function(e) { 	var self = e.target.self; 	// Extract coordinates from event listener 	var x = parseInt(e.target.getAttribute('data-x'), 10); 	var y = parseInt(e.target.getAttribute('data-y'), 10); 	var result = null; 	if (self.readyToPlay) { 		result = self.shoot(x, y, CONST.COMPUTER_PLAYER);  		// Remove the tutorial arrow 		if (gameTutorial.showTutorial) { 			gameTutorial.nextStep(); 		} 	}  	if (result !== null && !Game.gameOver) { 		Game.stats.incrementShots(); 		if (result === CONST.TYPE_HIT) { 			Game.stats.hitShot(); 		} // Kula AI wystrzeliwa, gdy gracz kliknie komórkę, której jeszcze nie kliknąłeś 		self.robot.shoot(); 	} else { 		Game.gameOver = false; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdym ze statków w rosterze Game.prototype.rosterListener = function(e) { 	var self = e.target.self; 	// Usuń wszystkie klasy ""umieszczania"" z listy flot 	var roster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < roster.length; i++) { 		var classes = roster[i].getAttribute('class') || ''; 		classes = classes.replace('placing', ''); 		roster[i].setAttribute('class', classes); 	}  	// Move the highlight to the next step 	if (gameTutorial.currentStep === 1) { 		gameTutorial.nextStep(); 	} 	 	// Set the class of the target ship to 'placing' 	Game.placeShipType = e.target.getAttribute('id'); 	document.getElementById(Game.placeShipType).setAttribute('class', 'placing'); 	Game.placeShipDirection = parseInt(document.getElementById('rotate-button').getAttribute('data-direction'), 10); 	self.placingOnGrid = true; }; // Tworzy detektory zdarzeń kliknięcia na siatce ludzkiego gracza, aby obsługiwać // umieszczenie statku po wybraniu przez użytkownika nazwy statku Game.prototype.placementListener = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		// Extract coordinates from event listener 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		 	// Nie wkręcaj kierunku, jeśli użytkownik próbuje ponownie umieścić. 		var successful = self.humanFleet.placeShip(x, y, Game.placeShipDirection, Game.placeShipType); 		if (successful) { 		// Sporządzono umieszczenie tego statku 			self.endPlacing(Game.placeShipType);  		// Usuń strzałkę pomocniczą 			if (gameTutorial.currentStep === 2) { 				gameTutorial.nextStep(); 			}  			self.placingOnGrid = false; 			if (self.areAllShipsPlaced()) { 				var el = document.getElementById('rotate-button'); 				el.addEventListener(transitionEndEventName(),(function(){ 					el.setAttribute('class', 'hidden'); 					if (gameTutorial.showTutorial) { 						document.getElementById('start-game').setAttribute('class', 'highlight'); 					} else { 						document.getElementById('start-game').removeAttribute('class');	 					} 				}),false); 				el.setAttribute('class', 'invisible'); 			} 		} 	} }; // Tworzy zdarzenia obsługi zdarzeń mouseover, które obsługują mouseover na // siatka ludzkiego gracza narysuje statek fantomowy, co oznacza, że użytkownik // można tam umieścić statek Game.prototype.placementMouseover = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		var classes; 		var fleetRoster = self.humanFleet.fleetRoster;  		for (var i = 0; i < fleetRoster.length; i++) { 			var shipType = fleetRoster[i].type;  			if (Game.placeShipType === shipType && 				fleetRoster[i].isLegal(x, y, Game.placeShipDirection)) { 				// Virtual ship 				fleetRoster[i].create(x, y, Game.placeShipDirection, true); 				Game.placeShipCoords = fleetRoster[i].getAllShipCells();  				for (var j = 0; j < Game.placeShipCoords.length; j++) { 					var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 					classes = el.getAttribute('class'); 					// Check if the substring ' grid-ship' already exists to avoid adding it twice 					if (classes.indexOf(' grid-ship') < 0) { 						classes += ' grid-ship'; 						el.setAttribute('class', classes); 					} 				} 			} 		} 	} }; // Tworzy zdarzenia detekcji zdarzeń myszy, które nie rysują statku fantomowego // na siatce ludzkiego gracza, gdy użytkownik przechodzi przez inną komórkę Game.prototype.placementMouseout = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		for (var j = 0; j < Game.placeShipCoords.length; j++) { 			var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 			classes = el.getAttribute('class'); // Sprawdź, czy substrat 'grid-ship' już istnieje, aby uniknąć dodawania go dwukrotnie 			if (classes.indexOf(' grid-ship') > -1) { 				classes = classes.replace(' grid-ship', ''); 				el.setAttribute('class', classes); 			} 		} 	} }; // Click handler for the Rotate Ship button Game.prototype.toggleRotation = function(e) { 	// Toggle rotation direction 	var direction = parseInt(e.target.getAttribute('data-direction'), 10); 	if (direction === Ship.DIRECTION_VERTICAL) { 		e.target.setAttribute('data-direction', '1'); 		Game.placeShipDirection = Ship.DIRECTION_HORIZONTAL; 	} else if (direction === Ship.DIRECTION_HORIZONTAL) { 		e.target.setAttribute('data-direction', '0'); 		Game.placeShipDirection = Ship.DIRECTION_VERTICAL; 	} }; // Click handler for the Start Game button Game.prototype.startGame = function(e) { 	var self = e.target.self; 	var el = document.getElementById('roster-sidebar'); 	var fn = function() {el.setAttribute('class', 'hidden');}; 	el.addEventListener(transitionEndEventName(),fn,false); 	el.setAttribute('class', 'invisible'); 	self.readyToPlay = true; // Rozwiń krok samouczek 	if (gameTutorial.currentStep === 3) { 		gameTutorial.nextStep(); 	} 	el.removeEventListener(transitionEndEventName(),fn,false); }; // Kliknij przycisk obsługi programu Restart Game Game.prototype.restartGame = function(e) { 	e.target.removeEventListener(e.type, arguments.callee); 	var self = e.target.self; 	document.getElementById('restart-sidebar').setAttribute('class', 'hidden'); 	self.resetFogOfWar(); 	self.init(); }; // Funkcja debugowania służąca do umieszczania wszystkich statków i dopiero początek Game.prototype.placeRandomly = function(e){ 	e.target.removeEventListener(e.type, arguments.callee); 	e.target.self.humanFleet.placeShipsRandomly(); 	e.target.self.readyToPlay = true; 	document.getElementById('roster-sidebar').setAttribute('class', 'hidden'); 	this.setAttribute('class', 'hidden'); }; // Zakończenie umieszczania obecnego statku Game.prototype.endPlacing = function(shipType) { 	document.getElementById(shipType).setAttribute('class', 'placed'); 	 	// Mark the ship as 'used' 	Game.usedShips[CONST.AVAILABLE_SHIPS.indexOf(shipType)] = CONST.USED;  	// Wipe out the variable when you're done with it 	Game.placeShipDirection = null; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; }; // Sprawdza, czy wszystkie statki są umieszczone // Zwraca boolean Game.prototype.areAllShipsPlaced = function() { 	var playerRoster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < playerRoster.length; i++) { 		if (playerRoster[i].getAttribute('class') === 'placed') { 			continue; 		} else { 			return false; 		} 	} 	// Reset temporary variables 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; 	return true; }; // Zresetuje mgłę wojny Game.prototype.resetFogOfWar = function() { 	for (var i = 0; i < Game.size; i++) { 		for (var j = 0; j < Game.size; j++) { 			this.humanGrid.updateCell(i, j, 'empty', CONST.HUMAN_PLAYER); 			this.computerGrid.updateCell(i, j, 'empty', CONST.COMPUTER_PLAYER); 		} 	} 	// Reset all values to indicate the ships are ready to be placed again 	Game.usedShips = Game.usedShips.map(function(){return CONST.UNUSED;}); }; // Zresetowanie stylu CSS na pasku bocznym Game.prototype.resetRosterSidebar = function() { 	var els = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < els.length; i++) { 		els[i].removeAttribute('class'); 	}  	if (gameTutorial.showTutorial) { 		gameTutorial.nextStep(); 	} else { 		document.getElementById('roster-sidebar').removeAttribute('class'); 	} 	document.getElementById('rotate-button').removeAttribute('class'); 	document.getElementById('start-game').setAttribute('class', 'hidden'); 	if (DEBUG_MODE) { 		document.getElementById('place-randomly').removeAttribute('class'); 	} }; Game.prototype.showRestartSidebar = function() { 	var sidebar = document.getElementById('restart-sidebar'); 	sidebar.setAttribute('class', 'highlight');  	// Deregister listeners 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].removeEventListener('click', this.shootListener, false); 	} 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].removeEventListener('click', this.rosterListener, false); 	}  	var restartButton = document.getElementById('restart-game'); 	restartButton.addEventListener('click', this.restartGame, false); 	restartButton.self = this; }; // Tworzy divy HTML dla siatki dla obu graczy Game.prototype.createGrid = function() { 	var gridDiv = document.querySelectorAll('.grid'); 	for (var grid = 0; grid < gridDiv.length; grid++) { 		gridDiv[grid].removeChild(gridDiv[grid].querySelector('.no-js')); // Removes the no-js warning 		for (var i = 0; i < Game.size; i++) { 			for (var j = 0; j < Game.size; j++) { 				var el = document.createElement('div'); 				el.setAttribute('data-x', i); 				el.setAttribute('data-y', j); 				el.setAttribute('class', 'grid-cell grid-cell-' + i + '-' + j); 				gridDiv[grid].appendChild(el); 			} 		} 	} }; // inicjuje grę. Również resetuje grę, jeśli została wcześniej zainicjowana Game.prototype.init = function() { 	this.humanGrid = new Grid(Game.size); 	this.computerGrid = new Grid(Game.size); 	this.humanFleet = new Fleet(this.humanGrid, CONST.HUMAN_PLAYER); 	this.computerFleet = new Fleet(this.computerGrid, CONST.COMPUTER_PLAYER);  	this.robot = new AI(this); 	Game.stats = new Stats(); 	Game.stats.updateStatsSidebar();  	// Reset game variables 	this.shotsTaken = 0; 	this.readyToPlay = false; 	this.placingOnGrid = false; 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = [];  	this.resetRosterSidebar();  // Dodaj metodę kliknięć dla metody Grid.shoot () dla wszystkich komórek // Tylko dodaj tego słuchacza do sieci komputerowej 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].self = this; 		computerCells[j].addEventListener('click', this.shootListener, false); 	} // Dodaj listener do listy	 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].self = this; 		playerRoster[i].addEventListener('click', this.rosterListener, false); 	}  // Dodawanie detektora kliknięć do siatki ludzkiego gracza podczas wprowadzania 	var humanCells = document.querySelector('.human-player').childNodes; 	for (var k = 0; k < humanCells.length; k++) { 		humanCells[k].self = this; 		humanCells[k].addEventListener('click', this.placementListener, false); 		humanCells[k].addEventListener('mouseover', this.placementMouseover, false); 		humanCells[k].addEventListener('mouseout', this.placementMouseout, false); 	}  	var rotateButton = document.getElementById('rotate-button'); 	rotateButton.addEventListener('click', this.toggleRotation, false); 	var startButton = document.getElementById('start-game'); 	startButton.self = this; 	startButton.addEventListener('click', this.startGame, false); 	var resetButton = document.getElementById('reset-stats'); 	resetButton.addEventListener('click', Game.stats.resetStats, false); 	var randomButton = document.getElementById('place-randomly'); 	randomButton.self = this; 	randomButton.addEventListener('click', this.placeRandomly, false); 	this.computerFleet.placeShipsRandomly(); };  // Grid object // Constructor function Grid(size) { 	this.size = size; 	this.cells = []; 	this.init(); }  // Inicjowanie i wypełnienie siatki Grid.prototype.init = function() { 	for (var x = 0; x < this.size; x++) { 		var row = []; 		this.cells[x] = row; 		for (var y = 0; y < this.size; y++) { 			row.push(CONST.TYPE_EMPTY); 		} 	} };  // Aktualizuje klasę CSS komórki w oparciu o typ przekazany Grid.prototype.updateCell = function(x, y, type, targetPlayer) { 	var player; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		player = 'human-player'; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		player = 'computer-player'; 	} else { 		// Should never be called 		console.log(""There was an error trying to find the correct player's grid""); 	}  	switch (type) { 		case CONST.CSS_TYPE_EMPTY: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 		case CONST.CSS_TYPE_SHIP: 			this.cells[x+1][y+1] = CONST.TYPE_SHIP; 			break;  		case CONST.CSS_TYPE_MISS: 			this.cells[x][y] = CONST.TYPE_MISS; 			break; 		case CONST.CSS_TYPE_HIT: 			this.cells[x][y] = CONST.TYPE_HIT; 			break; 		case CONST.CSS_TYPE_SUNK: 			this.cells[x][y] = CONST.TYPE_SUNK; 			break; 		default: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 	} 	var classes = ['grid-cell', 'grid-cell-' + x + '-' + y, 'grid-' + type]; 	document.querySelector('.' + player + ' .grid-cell-' + x + '-' + y).setAttribute('class', classes.join(' ')); }; // Sprawdza, czy komórka zawiera nieuszkodzony statek // Zwraca boolean Grid.prototype.isUndamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_SHIP; }; // Sprawdza, czy strzał został pominięty. To jest równoważne // sprawdzenie, czy komórka zawiera kulę armatnią // Zwraca boolean Grid.prototype.isMiss = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_MISS; }; // Sprawdza, czy komórka zawiera uszkodzony statek, // uderzysz lub zatapia. // Zwraca boolean Grid.prototype.isDamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_HIT || this.cells[x][y] === CONST.TYPE_SUNK; };  // obiekt Floty // Ten obiekt służy do śledzenia portfela statków gracza // Konstruktor function Fleet(playerGrid, player) { 	this.numShips = CONST.AVAILABLE_SHIPS.length; 	this.playerGrid = playerGrid; 	this.player = player; 	this.fleetRoster = []; 	this.populate(); } // Posiada flotę Fleet.prototype.populate = function() { 	for (var i = 0; i < this.numShips; i++) { 		// loop over the ship types when numShips > Constants.AVAILABLE_SHIPS.length 		var j = i % CONST.AVAILABLE_SHIPS.length; 		this.fleetRoster.push(new Ship(CONST.AVAILABLE_SHIPS[j], this.playerGrid, this.player)); 	} }; // umieszcza statek i zwraca, czy miejsce docelowe jest skuteczne // Zwraca boolean Fleet.prototype.placeShip = function(x, y, direction, shipType) { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var shipTypes = this.fleetRoster[i].type;  		if (shipType === shipTypes && 			this.fleetRoster[i].isLegal(x, y, direction)) { 			this.fleetRoster[i].create(x, y, direction, false); 			shipCoords = this.fleetRoster[i].getAllShipCells();  			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 			} 			return true; 		} 	} 	return false; }; // Miejsca statków są losowo umieszczane na pokładzie // TODO: Unikaj umieszczania statków zbyt blisko siebie Fleet.prototype.placeShipsRandomly = function() { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var illegalPlacement = true; 	 		// Prevents the random placement of already placed ships 		if(this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] === CONST.USED) { 			continue; 		} 		while (illegalPlacement) { 			var randomX = Math.floor(10*Math.random()); 			var randomY = Math.floor(10*Math.random()); 			var randomDirection = Math.floor(2*Math.random()); 			 			if (this.fleetRoster[i].isLegal(randomX, randomY, randomDirection)) { 				this.fleetRoster[i].create(randomX, randomY, randomDirection, false); 				shipCoords = this.fleetRoster[i].getAllShipCells(); 				illegalPlacement = false; 			} else { 				continue; 			} 		} 		if (this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] !== CONST.USED) { 			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 				Game.usedShips[i] = CONST.USED; 			} 		} 	} }; // Znajduje statek według lokalizacji // Zwraca obiekt statku znajdujący się pod adresem (x, y) // Jeśli żaden statek nie istnieje w (x, y), zamiast tego zwraca null Fleet.prototype.findShipByCoords = function(x, y) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var currentShip = this.fleetRoster[i]; 		if (currentShip.direction === Ship.DIRECTION_VERTICAL) { 			if (y === currentShip.yPosition && 				x >= currentShip.xPosition && 				x < currentShip.xPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} else { 			if (x === currentShip.xPosition && 				y >= currentShip.yPosition && 				y < currentShip.yPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} 	} 	return null; }; // Znajduje statek według jego typu // Param shipType to ciąg znaków // Zwraca obiekt statku, który jest typu typu shipType // Jeśli żaden statek nie istnieje, zwraca null. Fleet.prototype.findShipByType = function(shipType) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		if (this.fleetRoster[i].type === shipType) { 			return this.fleetRoster[i]; 		} 	} 	return null; }; // Checks to see if all ships have been sunk // Returns boolean Fleet.prototype.allShipsSunk = function() { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		// If one or more ships are not sunk, then the sentence ""all ships are sunk"" is false. 		if (this.fleetRoster[i].sunk === false) { 			return false; 		} 	} 	return true; };  // Ship object // Constructor function Ship(type, playerGrid, player) { 	this.damage = 0; 	this.type = type; 	this.playerGrid = playerGrid; 	this.player = player;  	switch (this.type) { 		case CONST.AVAILABLE_SHIPS[0]: 			this.shipLength = 5; 			break; 		case CONST.AVAILABLE_SHIPS[1]: 			this.shipLength = 4; 			break; 		case CONST.AVAILABLE_SHIPS[2]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[3]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[4]: 			this.shipLength = 2; 			break; 		default: 			this.shipLength = 3; 			break; 	} 	this.maxDamage = this.shipLength; 	this.sunk = false; } // Sprawdza, czy umieszczenie statku jest legalne // Zwraca boolean Ship.prototype.isLegal = function(x, y, direction) { 	// najpierw sprawdź czy statek znajduje się w sieci ... 	if (this.withinBounds(x, y, direction))  	{ 	// ... sprawdź, czy nie koliduje z innym statkiem 		for (var i = 0; i < this.shipLength; i++)  		{ 			if (direction === Ship.DIRECTION_VERTICAL)  			{ 				if (this.playerGrid.cells[x + i][y] === CONST.TYPE_SHIP || 				this.playerGrid.cells[x - i][y] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_MISS || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_SUNK)  				 					{ 					return false; 				     } 			}  			else  			{ 				if (this.playerGrid.cells[x][y + i] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_MISS || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_SUNK)  					{ 					return false;}				 			}			 		}		 		return true; 	}  	else  		return false;	 }; // Sprawdza, czy statek znajduje się w granicach sieci // Zwraca boolean //statek mieści się w granicach gry Ship.prototype.withinBounds = function(x, y, direction) { 	if (direction === Ship.DIRECTION_VERTICAL) { 		return x + this.shipLength <= Game.size; 	} else { 		return y + this.shipLength <= Game.size; 	} }; // zwiększa licznik uszkodzeń statku // Zwraca statek Ship.prototype.incrementDamage = function() { 	this.damage++; 	if (this.isSunk()) { 		this.sinkShip(false); // Sinks the ship 	} }; // Sprawdza, czy statek jest zatopiony // Zwraca boolean Ship.prototype.isSunk = function() { 	return this.damage >= this.maxDamage; }; // Zanurzysz statek Ship.prototype.sinkShip = function(virtual) { 	this.damage = this.maxDamage; // Force the damage to exceed max damage 	this.sunk = true;  // Uczynienie klasy CSS zatopionej, ale tylko wtedy, gdy statek nie jest wirtualny 	if (!virtual) { 		var allCells = this.getAllShipCells(); 		for (var i = 0; i < this.shipLength; i++) { 			this.playerGrid.updateCell(allCells[i].x, allCells[i].y, 'sunk', this.player); 		} 	} };  Ship.prototype.getAllShipCells = function() { 	var resultObject = []; 	for (var i = 0; i < this.shipLength; i++) { 		if (this.direction === Ship.DIRECTION_VERTICAL) { 			resultObject[i] = {'x': this.xPosition + i, 'y': this.yPosition}; 		} else { 			resultObject[i] = {'x': this.xPosition, 'y': this.yPosition + i}; 		} 	} 	return resultObject; }; // Inicjuje statek o podanym współrzędnym i kierunku (łożyska). // Jeśli statek zostanie uznany za ""wirtualny"", wtedy statek zostanie zainicjowany // jego współrzędne, ale NIE umieszcza się na siatce. Ship.prototype.create = function(x, y, direction, virtual) { 	// This function assumes that you've already checked that the placement is legal 	this.xPosition = x; 	this.yPosition = y; 	this.direction = direction;  	// Jeśli statek jest wirtualny, nie dodaj go do sieci. 	if (!virtual) { 		for (var i = 0; i < this.shipLength; i++) { 			if (this.direction === Ship.DIRECTION_VERTICAL) { 				this.playerGrid.cells[x + i][y] = CONST.TYPE_SHIP; 			} else { 				this.playerGrid.cells[x][y + i] = CONST.TYPE_SHIP; 			} 		} 	} 	 }; // direction === 0 when the ship is facing north/south // direction === 1 when the ship is facing east/west Ship.DIRECTION_VERTICAL = 0; Ship.DIRECTION_HORIZONTAL = 1;  // Tutorial Object // Constructor function Tutorial() { 	this.currentStep = 0; 	// Check if 'showTutorial' is initialized, if it's uninitialized, set it to true. 	this.showTutorial = localStorage.getItem('showTutorial') !== 'false'; } // Advances the tutorial to the next step Tutorial.prototype.nextStep = function() { 	var humanGrid = document.querySelector('.human-player'); 	var computerGrid = document.querySelector('.computer-player'); 	switch (this.currentStep) { 		case 0: 			document.getElementById('roster-sidebar').setAttribute('class', 'highlight'); 			document.getElementById('step1').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 1: 			document.getElementById('roster-sidebar').removeAttribute('class'); 			document.getElementById('step1').removeAttribute('class'); 			humanGrid.setAttribute('class', humanGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step2').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 2: 			document.getElementById('step2').removeAttribute('class'); 			var humanClasses = humanGrid.getAttribute('class'); 			humanClasses = humanClasses.replace(' highlight', ''); 			humanGrid.setAttribute('class', humanClasses); 			this.currentStep++; 			break; 		case 3: 			computerGrid.setAttribute('class', computerGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step3').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 4: 			var computerClasses = computerGrid.getAttribute('class'); 			document.getElementById('step3').removeAttribute('class'); 			computerClasses = computerClasses.replace(' highlight', ''); 			computerGrid.setAttribute('class', computerClasses); 			document.getElementById('step4').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 5: 			document.getElementById('step4').removeAttribute('class'); 			this.currentStep = 6; 			this.showTutorial = false; 			localStorage.setItem('showTutorial', false); 			break; 		default: 			break; 	} };  // AI Object // Optimal battleship-playing AI // Constructor function AI(gameObject) { 	this.gameObject = gameObject; 	this.virtualGrid = new Grid(Game.size); 	this.virtualFleet = new Fleet(this.virtualGrid, CONST.VIRTUAL_PLAYER);  	this.probGrid = []; // Probability Grid 	this.initProbs(); 	this.updateProbs(); } AI.PROB_WEIGHT = 5000; // arbitrarily big number // jaka masa ma przynieść komórki wysokiego prawdopodobieństwa książki otwartej AI.OPEN_HIGH_MIN = 20; AI.OPEN_HIGH_MAX = 30; // ile wagi daje się średnim prawdopodobieństwom książki otwarcia AI.OPEN_MED_MIN = 15; AI.OPEN_MED_MAX = 25; // how much weight to give to the opening book's low probability cells AI.OPEN_LOW_MIN = 10; AI.OPEN_LOW_MAX = 20; // Amount of randomness when selecting between cells of equal probability AI.RANDOMNESS = 0.1; // AI's opening book. // This is the pattern of the first cells for the AI to target AI.OPENINGS = [ 	{'x': 7, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 2, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 7, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 2, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 5, 'y': 5, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 4, 'y': 4, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	// {'x': 9, 'y': 5, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 0, 'y': 4, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 5, 'y': 9, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 4, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 0, 'y': 8, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 1, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 8, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 9, 'y': 1, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 9, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 0, 'y': 0, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)} ]; // Zrzuca siatkę w oparciu o maksymalne prawdopodobieństwo i strzela do komórki // ma największe prawdopodobieństwo zawarcia statku AI.prototype.shoot = function() { 	var maxProbability = 0; 	var maxProbCoords; 	var maxProbs = []; 	 	// Add the AI's opening book to the probability grid 	for (var i = 0; i < AI.OPENINGS.length; i++) { 		var cell = AI.OPENINGS[i]; 		if (this.probGrid[cell.x][cell.y] !== 0) { 			this.probGrid[cell.x][cell.y] += cell.weight; 		} 	}  	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			if (this.probGrid[x][y] > maxProbability) { 				maxProbability = this.probGrid[x][y]; 				maxProbs = [{'x': x, 'y': y}]; // Replace the array 			} else if (this.probGrid[x][y] === maxProbability) { 				maxProbs.push({'x': x, 'y': y}); 			} 		} 	}  	maxProbCoords = Math.random() < AI.RANDOMNESS ? 	maxProbs[Math.floor(Math.random() * maxProbs.length)] : 	maxProbs[0];  	var result = this.gameObject.shoot(maxProbCoords.x, maxProbCoords.y, CONST.HUMAN_PLAYER); 	 	// If the game ends, the next lines need to be skipped. 	if (Game.gameOver) { 		Game.gameOver = false; 		return; 	}  	this.virtualGrid.cells[maxProbCoords.x][maxProbCoords.y] = result;  	// If you hit a ship, check to make sure if you've sunk it. 	if (result === CONST.TYPE_HIT) { 		var humanShip = this.findHumanShip(maxProbCoords.x, maxProbCoords.y); 		if (humanShip.isSunk()) { 			// Remove any ships from the roster that have been sunk 			var shipTypes = []; 			for (var k = 0; k < this.virtualFleet.fleetRoster.length; k++) { 				shipTypes.push(this.virtualFleet.fleetRoster[k].type); 			} 			var index = shipTypes.indexOf(humanShip.type); 			this.virtualFleet.fleetRoster.splice(index, 1);  			// Update the virtual grid with the sunk ship's cells 			var shipCells = humanShip.getAllShipCells(); 			for (var _i = 0; _i < shipCells.length; _i++) { 				this.virtualGrid.cells[shipCells[_i].x][shipCells[_i].y] = CONST.TYPE_SUNK; 			} 		} 	} 	// Update probability grid after each shot 	this.updateProbs(); }; // Update the probability grid AI.prototype.updateProbs = function() { 	var roster = this.virtualFleet.fleetRoster; 	var coords; 	this.resetProbs(); // Prawdopodobieństwa nie są znormalizowane, aby pasowały do przedziału [0, 1] // dlatego, że jesteśmy zainteresowani maksymalną wartością.  // Działa to poprzez dopasowanie każdego statku do każdej komórki w każdej orientacji // W każdej komórce, tym bardziej legalnym sposobem, w jaki statek może przechodzić przez niego, tym bardziej // prawdopodobnie komórka ma zawierać statek. // Komórki otaczające znane ""trafienia"" otrzymują arbitralnie duże prawdopodobieństwo // tak, że AI próbuje całkowicie zatopić statek przed przejściem dalej.  // TODO: Pomyśl o bardziej efektywnej implementacji 	for (var k = 0; k < roster.length; k++) { 		for (var x = 0; x < Game.size; x++) { 			for (var y = 0; y < Game.size; y++) { 				if (roster[k].isLegal(x, y, Ship.DIRECTION_VERTICAL)) { 					roster[k].create(x, y, Ship.DIRECTION_VERTICAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var i = 0; i < coords.length; i++) { 							this.probGrid[coords[i].x][coords[i].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _i = 0; _i < coords.length; _i++) { 							this.probGrid[coords[_i].x][coords[_i].y]++; 						} 					} 				} 				if (roster[k].isLegal(x, y, Ship.DIRECTION_HORIZONTAL)) { 					roster[k].create(x, y, Ship.DIRECTION_HORIZONTAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var j = 0; j < coords.length; j++) { 							this.probGrid[coords[j].x][coords[j].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _j = 0; _j < coords.length; _j++) { 							this.probGrid[coords[_j].x][coords[_j].y]++; 						} 					} 				}  				// Set hit cells to probability zero so the AI doesn't 				// target cells that are already hit 				if (this.virtualGrid.cells[x][y] === CONST.TYPE_HIT) { 					this.probGrid[x][y] = 0; 				} 			} 		} 	} }; // Initializes the probability grid for targeting AI.prototype.initProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		var row = []; 		this.probGrid[x] = row; 		for (var y = 0; y < Game.size; y++) { 			row.push(0); 		} 	} }; // Resets the probability grid to all 0. AI.prototype.resetProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			this.probGrid[x][y] = 0; 		} 	} }; AI.prototype.metagame = function() { 	// Inputs: 	// Proximity of hit cells to edge 	// Proximity of hit cells to each other 	// Edit the probability grid by multiplying each cell with a new probability weight (e.g. 0.4, or 3). Set this as a CONST and make 1-CONST the inverse for decreasing, or 2*CONST for increasing }; // Finds a human ship by coordinates // Returns Ship AI.prototype.findHumanShip = function(x, y) { 	return this.gameObject.humanFleet.findShipByCoords(x, y); }; // Checks whether or not a given ship's cells passes through // any cell that is hit. // Returns boolean AI.prototype.passesThroughHitCell = function(shipCells) { 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			return true; 		} 	} 	return false; }; // Gives the number of hit cells the ships passes through. The more // cells this is, the more probable the ship exists in those coordinates // Returns int AI.prototype.numHitCellsCovered = function(shipCells) { 	var cells = 0; 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			cells++; 		} 	} 	return cells; };  // Global constant only initialized once var gameTutorial = new Tutorial();  // Start the game var mainGame = new Game(10);  })();  // Array.prototype.indexOf workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf if (!Array.prototype.indexOf) { 	Array.prototype.indexOf = function (searchElement, fromIndex) {  		var k;  		// 1. Let O be the result of calling ToObject passing 		//    the this value as the argument. 		if (this === null || this === undefined) { 			throw new TypeError('""this"" is null or not defined'); 		}  		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get 		//    internal method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If len is 0, return -1. 		if (len === 0) { 			return -1; 		}  		// 5. If argument fromIndex was passed let n be 		//    ToInteger(fromIndex); else let n be 0. 		var n = +fromIndex || 0;  		if (Math.abs(n) === Infinity) { 			n = 0; 		}  		// 6. If n >= len, return -1. 		if (n >= len) { 			return -1; 		}  		// 7. If n >= 0, then Let k be n. 		// 8. Else, n<0, Let k be len - abs(n). 		//    If k is less than 0, then let k be 0. 		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);  		// 9. Repeat, while k < len 		while (k < len) { 			var kValue; 			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the 			//    HasProperty internal method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			//    i.  Let elementK be the result of calling the Get 			//        internal method of O with the argument ToString(k). 			//   ii.  Let same be the result of applying the 			//        Strict Equality Comparison Algorithm to 			//        searchElement and elementK. 			//  iii.  If same is true, return k. 			if (k in O && O[k] === searchElement) { 				return k; 			} 			k++; 		} 		return -1; 	}; }  // Array.prototype.map workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map // Production steps of ECMA-262, Edition 5, 15.4.4.19 // Reference: http://es5.github.io/#x15.4.4.19 if (!Array.prototype.map) {  	Array.prototype.map = function(callback, thisArg) {  		var T, A, k;  		if (this == null) { 			throw new TypeError("" this is null or not defined""); 		}  		// 1. Let O be the result of calling ToObject passing the |this|  		//    value as the argument. 		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get internal  		//    method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If IsCallable(callback) is false, throw a TypeError exception. 		// See: http://es5.github.com/#x9.11 		if (typeof callback !== ""function"") { 			throw new TypeError(callback + "" is not a function""); 		}  		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined. 		if (arguments.length > 1) { 			T = thisArg; 		}  		// 6. Let A be a new array created as if by the expression new Array(len)  		//    where Array is the standard built-in constructor with that name and  		//    len is the value of len. 		A = new Array(len);  		// 7. Let k be 0 		k = 0;  		// 8. Repeat, while k < len 		while (k < len) {  			var kValue, mappedValue;  			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the HasProperty internal  			//    method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			if (k in O) {  				// i. Let kValue be the result of calling the Get internal  				//    method of O with argument Pk. 				kValue = O[k];  				// ii. Let mappedValue be the result of calling the Call internal  				//     method of callback with T as the this value and argument  				//     list containing kValue, k, and O. 				mappedValue = callback.call(T, kValue, k, O);  				// iii. Call the DefineOwnProperty internal method of A with arguments 				// Pk, Property Descriptor  				// { Value: mappedValue,  				//   Writable: true,  				//   Enumerable: true,  				//   Configurable: true }, 				// and false.  				// In browsers that support Object.defineProperty, use the following: 				// Object.defineProperty(A, k, {  				//   value: mappedValue,  				//   writable: true,  				//   enumerable: true,  				//   configurable: true  				// });  				// For best browser support, use the following: 				A[k] = mappedValue; 			} 			// d. Increase k by 1. 			k++; 		}  		// 9. return A 		return A; 	}; }  // Browser compatability workaround for transition end event names. // From modernizr: http://stackoverflow.com/a/9090128 function transitionEndEventName() { 	var i, 		undefined, 		el = document.createElement('div'), 		transitions = { 			'transition':'transitionend', 			'OTransition':'otransitionend',  // oTransitionEnd in very old Opera 			'MozTransition':'transitionend', 			'WebkitTransition':'webkitTransitionEnd' 		};  	for (i in transitions) { 		if (transitions.hasOwnProperty(i) && el.style[i] !== undefined) { 			return transitions[i]; 		} 	} }  // Returns a random number between min (inclusive) and max (exclusive) function getRandom(min, max) { 	return Math.random() * (max - min) + min; }  // Toggles on or off DEBUG_MODE function setDebug(val) { 	DEBUG_MODE = val; 	localStorage.setItem('DEBUG_MODE', val); 	localStorage.setItem('showTutorial', 'false'); 	window.location.reload(); };"
"Jeśli nie jesteś w stanie stworzyć i zweryfikować modelu to równie dobrze można zastąpić cię dobrze wytrenowanym psem. Prawdą jest że pewnie nie będziesz sobie pisał od zera algorytmów trenujących, no ale statystykę na poziomie lepszym niż ""wstęp do statystyki"" to by wypadało znać. Jak nie rozumiesz modeli których używasz (typu CRF) to jaka jest twoja wartość?;"
"Mi osobiście się wydaje, że programista to jeden z ostatnich zawodów, w którym maszyna w pełni zastąpi człowieka. To nie jest prosty zawód jak np. kasjer do zastąpienia przez automaty, w którym czynności są proste, jest ich mało oraz się powtarzają.;"
"@Spine to tak nie działa. Programiści faktycznie non stop budują narzędzia które ułatwiają pracę, tylko że w efekcie:  Buduje się bardziej rozbudowane systemy Buduje się systemy szybciej  Co z tego ze dziś możesz sobie ""wyklikać"" w kilka godzin grę lepszą niż 10 lat temu napisałby zespół programistów w ciągu kilku miesięcy, skoro użytkownik ma wyższe oczekiwania? Nie wspominam już nawet o tym że rozwój tych narzędzi powoduje wzrost zatrudnienia, bo zwyczajnie generuje się rynki których nie było wcześniej. 25 lat temu nie było w ogóle czegoś takiego jak WWW, a dziś każdy musi mieć swoją stronę internetową a masa aplikacji ma tylko webowy frontend. 15 lat temu w ogóle nie było czegoś takiego jak smartphone i aplikacje ""mobilne"" a dziś miliony ludzi ma takie urządzenie i aktywnie z niego korzysta. Trik polega na tym że nie ma z góry określonego limitu na popyt na pracę programistów. Liczba ślusarzy sie nie skaluje, podobnie zresztą choćby liczba nauczycieli czy lekarzy. Nowy zabiera część pracy innym, bo zapotrzebowanie jest stałe. Taka sytuacja nie ma miejsca w IT. Jasne że postępuje ""automatyzacja"", tylko że automatyzuje sie ""bezmyślne"" kroki, dzięki czemu programiści mogą się skupić na ciekawszych rzeczach. Więc ""roboty"" (a raczej jakieś generatory) mogą zastąpić co najwyżej takich informatycznych kasjerów w biedronce, którzy nie robili nic kreatywnego w swojej pracy.;"
"Witam, Potrzebuję pomocy w modyfikacji kodu. Główną zasadą gry w statki jest, brak możliwości stykania się ścianami oraz rogami. Niestety nie mogę wprowadzić tej zmiany w zamieszczonym kodzie. Czy mógłby mi ktoś pomóc (function() {  // Global Constants var CONST = {}; CONST.AVAILABLE_SHIPS = ['carrier', 'battleship', 'destroyer', 'submarine', 'patrolboat']; // You are player 0 and the computer is player 1 // The virtual player is used for generating temporary ships // for calculating the probability heatmap CONST.HUMAN_PLAYER = 0; CONST.COMPUTER_PLAYER = 1; CONST.VIRTUAL_PLAYER = 2; // Possible values for the parameter `type` (string) CONST.CSS_TYPE_EMPTY = 'empty'; CONST.CSS_TYPE_SHIP = 'ship'; CONST.CSS_TYPE_MISS = 'miss'; CONST.CSS_TYPE_HIT = 'hit'; CONST.CSS_TYPE_SUNK = 'sunk'; // Grid code: CONST.TYPE_EMPTY = 0; // 0 = water (empty) CONST.TYPE_SHIP = 1; // 1 = undamaged ship CONST.TYPE_MISS = 2; // 2 = water with a cannonball in it (missed shot) CONST.TYPE_HIT = 3; // 3 = damaged ship (hit shot) CONST.TYPE_SUNK = 4; // 4 = sunk ship  // TODO: Utwórz ten lepszy kod OO. CONST.AVAILABLE_SHIPS powinna być tablicą // obiektów, a nie dwóch równoległych tablic. Albo lepiej // rozwiązaniem byłoby zapisanie ""USED"" i ""UNUSED"" jako właściwości // pojedynczy obiekt statku. // Te liczby odpowiadają CONST.AVAILABLE_SHIPS //1) ""pancernik"" 2) ""niszczyciel"" 3) ""okręt podwodny"" 4) ""patrolboat"" // Ta zmienna jest używana tylko wtedy, gdy DEBUG_MODE === true. Game.usedShips = [CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED, CONST.UNUSED]; CONST.USED = 1; CONST.UNUSED = 0;  // Game Statistics function Stats(){ 	this.shotsTaken = 0; 	this.shotsHit = 0; 	this.totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 	this.totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 	this.gamesPlayed = parseInt(localStorage.getItem('gamesPlayed'), 10) || 0; 	this.gamesWon = parseInt(localStorage.getItem('gamesWon'), 10) || 0; 	this.uuid = localStorage.getItem('uuid') || this.createUUID(); 	if (DEBUG_MODE) { 		this.skipCurrentGame = true; 	} } Stats.prototype.incrementShots = function() { 	this.shotsTaken++; }; Stats.prototype.hitShot = function() { 	this.shotsHit++; }; Stats.prototype.wonGame = function() { 	this.gamesPlayed++; 	this.gamesWon++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'win', this.uuid); 	} }; Stats.prototype.lostGame = function() { 	this.gamesPlayed++; 	if (!DEBUG_MODE) { 		ga('send', 'event', 'gameOver', 'lose', this.uuid); 	} }; // Zapisuje statystyki gry do lokalnego magazynu, a także przesyła je, gdzie użytkownik umieścił // ich statki do Google Analytics, aby w przyszłości mogłem zobaczyć // które komórki ludzkie są nieproporcjonalnie nastawione do umieszczania statków. Stats.prototype.syncStats = function() { 	if(!this.skipCurrentGame) { 		var totalShots = parseInt(localStorage.getItem('totalShots'), 10) || 0; 		totalShots += this.shotsTaken; 		var totalHits = parseInt(localStorage.getItem('totalHits'), 10) || 0; 		totalHits += this.shotsHit; 		localStorage.setItem('totalShots', totalShots); 		localStorage.setItem('totalHits', totalHits); 		localStorage.setItem('gamesPlayed', this.gamesPlayed); 		localStorage.setItem('gamesWon', this.gamesWon); 		localStorage.setItem('uuid', this.uuid); 	} else { 		this.skipCurrentGame = false; 	} 	 	var stringifiedGrid = ''; 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			stringifiedGrid += '(' + x + ',' + y + '):' + mainGame.humanGrid.cells[x][y] + ';\n'; 		} 	}  	if (!DEBUG_MODE) { 		ga('send', 'event', 'humanGrid', stringifiedGrid, this.uuid); 	} }; // Aktualizuje pasek boczny z aktualnymi statystykami Stats.prototype.updateStatsSidebar = function() { 	var elWinPercent = document.getElementById('stats-wins'); 	var elAccuracy = document.getElementById('stats-accuracy'); 	elWinPercent.innerHTML = this.gamesWon + "" of "" + this.gamesPlayed; 	elAccuracy.innerHTML = Math.round((100 * this.totalHits / this.totalShots) || 0) + ""%""; }; // Zresetuj wszystkie statystyczne statystyki gry do zera. Nie zresetuj uuid. Stats.prototype.resetStats = function(e) { // Pomiń statystyki śledzenia do końca bieżącej gry lub innego // odsetek dokładności będzie niewłaściwy (ponieważ śledzisz // trafienia, które nie zaczęły się od początku gry) 	Game.stats.skipCurrentGame = true; 	localStorage.setItem('totalShots', 0); 	localStorage.setItem('totalHits', 0); 	localStorage.setItem('gamesPlayed', 0); 	localStorage.setItem('gamesWon', 0); 	localStorage.setItem('showTutorial', true); 	Game.stats.shotsTaken = 0; 	Game.stats.shotsHit = 0; 	Game.stats.totalShots = 0; 	Game.stats.totalHits = 0; 	Game.stats.gamesPlayed = 0; 	Game.stats.gamesWon = 0; 	Game.stats.updateStatsSidebar(); }; Stats.prototype.createUUID = function(len, radix) { 	var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), 	uuid = [], i; 	radix = radix || chars.length;  	if (len) { 		// Compact form 		for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix]; 	} else { 		// rfc4122, version 4 form 		var r;  		// rfc4122 requires these characters 		uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; 		uuid[14] = '4';  		// Fill in random data.  At i==19 set the high bits of clock sequence as 		// per rfc4122, sec. 4.1.5 		for (i = 0; i < 36; i++) { 			if (!uuid[i]) { 				r = 0 | Math.random()*16; 				uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r]; 			} 		} 	}  	return uuid.join(''); };  // Obiekt menedżera gier // Konstruktor function Game(size) { 	Game.size = size; 	this.shotsTaken = 0; 	this.createGrid(); 	this.init(); } Game.size = 10; // Domyślny rozmiar siatki to 10x10 Game.gameOver = false; // Sprawdza, czy gra jest wygrywana, a jeśli tak, ponownie zainicjuje grę Game.prototype.checkIfWon = function() { 	if (this.computerFleet.allShipsSunk()) { 		alert('brawo!'); 		Game.gameOver = true; 		Game.stats.wonGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} else if (this.humanFleet.allShipsSunk()) { 		alert('srobuj ponownie'); 		Game.gameOver = true; 		Game.stats.lostGame(); 		Game.stats.syncStats(); 		Game.stats.updateStatsSidebar(); 		this.showRestartSidebar(); 	} }; // strzela do docelowego gracza w siatce. // Zwraca {int} Constants.TYPE: Co odkryto Game.prototype.shoot = function(x, y, targetPlayer) { 	var targetGrid; 	var targetFleet; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		targetGrid = this.humanGrid; 		targetFleet = this.humanFleet; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		targetGrid = this.computerGrid; 		targetFleet = this.computerFleet; 	} else { 		// Should never be called 		console.log("".................""); 	}  	if (targetGrid.isDamagedShip(x, y)) { 		return null; 	} else if (targetGrid.isMiss(x, y)) { 		return null; 	} else if (targetGrid.isUndamagedShip(x, y)) { // zaktualizować planszę / siatkę 		targetGrid.updateCell(x, y, 'hit', targetPlayer); // WAŻNE: Ta funkcja musi być nazwana _after_ aktualizacją komórki do ""trafienia"" // ponieważ zastąpi klasę CSS ""zatopioną"", jeśli okaże się, że statek został zatopiony 		targetFleet.findShipByCoords(x, y).incrementDamage(); // increase the damage 		this.checkIfWon(); 		return CONST.TYPE_HIT; 	} else { 		targetGrid.updateCell(x, y, 'miss', targetPlayer); 		this.checkIfWon(); 		return CONST.TYPE_MISS; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdej z 100 komórek siatki Game.prototype.shootListener = function(e) { 	var self = e.target.self; 	// Extract coordinates from event listener 	var x = parseInt(e.target.getAttribute('data-x'), 10); 	var y = parseInt(e.target.getAttribute('data-y'), 10); 	var result = null; 	if (self.readyToPlay) { 		result = self.shoot(x, y, CONST.COMPUTER_PLAYER);  		// Remove the tutorial arrow 		if (gameTutorial.showTutorial) { 			gameTutorial.nextStep(); 		} 	}  	if (result !== null && !Game.gameOver) { 		Game.stats.incrementShots(); 		if (result === CONST.TYPE_HIT) { 			Game.stats.hitShot(); 		} // Kula AI wystrzeliwa, gdy gracz kliknie komórkę, której jeszcze nie kliknąłeś 		self.robot.shoot(); 	} else { 		Game.gameOver = false; 	} }; // Tworzy detektory zdarzeń kliknięcia na każdym ze statków w rosterze Game.prototype.rosterListener = function(e) { 	var self = e.target.self; 	// Usuń wszystkie klasy ""umieszczania"" z listy flot 	var roster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < roster.length; i++) { 		var classes = roster[i].getAttribute('class') || ''; 		classes = classes.replace('placing', ''); 		roster[i].setAttribute('class', classes); 	}  	// Move the highlight to the next step 	if (gameTutorial.currentStep === 1) { 		gameTutorial.nextStep(); 	} 	 	// Set the class of the target ship to 'placing' 	Game.placeShipType = e.target.getAttribute('id'); 	document.getElementById(Game.placeShipType).setAttribute('class', 'placing'); 	Game.placeShipDirection = parseInt(document.getElementById('rotate-button').getAttribute('data-direction'), 10); 	self.placingOnGrid = true; }; // Tworzy detektory zdarzeń kliknięcia na siatce ludzkiego gracza, aby obsługiwać // umieszczenie statku po wybraniu przez użytkownika nazwy statku Game.prototype.placementListener = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		// Extract coordinates from event listener 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		 	// Nie wkręcaj kierunku, jeśli użytkownik próbuje ponownie umieścić. 		var successful = self.humanFleet.placeShip(x, y, Game.placeShipDirection, Game.placeShipType); 		if (successful) { 		// Sporządzono umieszczenie tego statku 			self.endPlacing(Game.placeShipType);  		// Usuń strzałkę pomocniczą 			if (gameTutorial.currentStep === 2) { 				gameTutorial.nextStep(); 			}  			self.placingOnGrid = false; 			if (self.areAllShipsPlaced()) { 				var el = document.getElementById('rotate-button'); 				el.addEventListener(transitionEndEventName(),(function(){ 					el.setAttribute('class', 'hidden'); 					if (gameTutorial.showTutorial) { 						document.getElementById('start-game').setAttribute('class', 'highlight'); 					} else { 						document.getElementById('start-game').removeAttribute('class');	 					} 				}),false); 				el.setAttribute('class', 'invisible'); 			} 		} 	} }; // Tworzy zdarzenia obsługi zdarzeń mouseover, które obsługują mouseover na // siatka ludzkiego gracza narysuje statek fantomowy, co oznacza, że użytkownik // można tam umieścić statek Game.prototype.placementMouseover = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		var x = parseInt(e.target.getAttribute('data-x'), 10); 		var y = parseInt(e.target.getAttribute('data-y'), 10); 		var classes; 		var fleetRoster = self.humanFleet.fleetRoster;  		for (var i = 0; i < fleetRoster.length; i++) { 			var shipType = fleetRoster[i].type;  			if (Game.placeShipType === shipType && 				fleetRoster[i].isLegal(x, y, Game.placeShipDirection)) { 				// Virtual ship 				fleetRoster[i].create(x, y, Game.placeShipDirection, true); 				Game.placeShipCoords = fleetRoster[i].getAllShipCells();  				for (var j = 0; j < Game.placeShipCoords.length; j++) { 					var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 					classes = el.getAttribute('class'); 					// Check if the substring ' grid-ship' already exists to avoid adding it twice 					if (classes.indexOf(' grid-ship') < 0) { 						classes += ' grid-ship'; 						el.setAttribute('class', classes); 					} 				} 			} 		} 	} }; // Tworzy zdarzenia detekcji zdarzeń myszy, które nie rysują statku fantomowego // na siatce ludzkiego gracza, gdy użytkownik przechodzi przez inną komórkę Game.prototype.placementMouseout = function(e) { 	var self = e.target.self; 	if (self.placingOnGrid) { 		for (var j = 0; j < Game.placeShipCoords.length; j++) { 			var el = document.querySelector('.grid-cell-' + Game.placeShipCoords[j].x + '-' + Game.placeShipCoords[j].y); 			classes = el.getAttribute('class'); // Sprawdź, czy substrat 'grid-ship' już istnieje, aby uniknąć dodawania go dwukrotnie 			if (classes.indexOf(' grid-ship') > -1) { 				classes = classes.replace(' grid-ship', ''); 				el.setAttribute('class', classes); 			} 		} 	} }; // Click handler for the Rotate Ship button Game.prototype.toggleRotation = function(e) { 	// Toggle rotation direction 	var direction = parseInt(e.target.getAttribute('data-direction'), 10); 	if (direction === Ship.DIRECTION_VERTICAL) { 		e.target.setAttribute('data-direction', '1'); 		Game.placeShipDirection = Ship.DIRECTION_HORIZONTAL; 	} else if (direction === Ship.DIRECTION_HORIZONTAL) { 		e.target.setAttribute('data-direction', '0'); 		Game.placeShipDirection = Ship.DIRECTION_VERTICAL; 	} }; // Click handler for the Start Game button Game.prototype.startGame = function(e) { 	var self = e.target.self; 	var el = document.getElementById('roster-sidebar'); 	var fn = function() {el.setAttribute('class', 'hidden');}; 	el.addEventListener(transitionEndEventName(),fn,false); 	el.setAttribute('class', 'invisible'); 	self.readyToPlay = true; // Rozwiń krok samouczek 	if (gameTutorial.currentStep === 3) { 		gameTutorial.nextStep(); 	} 	el.removeEventListener(transitionEndEventName(),fn,false); }; // Kliknij przycisk obsługi programu Restart Game Game.prototype.restartGame = function(e) { 	e.target.removeEventListener(e.type, arguments.callee); 	var self = e.target.self; 	document.getElementById('restart-sidebar').setAttribute('class', 'hidden'); 	self.resetFogOfWar(); 	self.init(); }; // Funkcja debugowania służąca do umieszczania wszystkich statków i dopiero początek Game.prototype.placeRandomly = function(e){ 	e.target.removeEventListener(e.type, arguments.callee); 	e.target.self.humanFleet.placeShipsRandomly(); 	e.target.self.readyToPlay = true; 	document.getElementById('roster-sidebar').setAttribute('class', 'hidden'); 	this.setAttribute('class', 'hidden'); }; // Zakończenie umieszczania obecnego statku Game.prototype.endPlacing = function(shipType) { 	document.getElementById(shipType).setAttribute('class', 'placed'); 	 	// Mark the ship as 'used' 	Game.usedShips[CONST.AVAILABLE_SHIPS.indexOf(shipType)] = CONST.USED;  	// Wipe out the variable when you're done with it 	Game.placeShipDirection = null; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; }; // Sprawdza, czy wszystkie statki są umieszczone // Zwraca boolean Game.prototype.areAllShipsPlaced = function() { 	var playerRoster = document.querySelectorAll('.fleet-roster li'); 	for (var i = 0; i < playerRoster.length; i++) { 		if (playerRoster[i].getAttribute('class') === 'placed') { 			continue; 		} else { 			return false; 		} 	} 	// Reset temporary variables 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = []; 	return true; }; // Zresetuje mgłę wojny Game.prototype.resetFogOfWar = function() { 	for (var i = 0; i < Game.size; i++) { 		for (var j = 0; j < Game.size; j++) { 			this.humanGrid.updateCell(i, j, 'empty', CONST.HUMAN_PLAYER); 			this.computerGrid.updateCell(i, j, 'empty', CONST.COMPUTER_PLAYER); 		} 	} 	// Reset all values to indicate the ships are ready to be placed again 	Game.usedShips = Game.usedShips.map(function(){return CONST.UNUSED;}); }; // Zresetowanie stylu CSS na pasku bocznym Game.prototype.resetRosterSidebar = function() { 	var els = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < els.length; i++) { 		els[i].removeAttribute('class'); 	}  	if (gameTutorial.showTutorial) { 		gameTutorial.nextStep(); 	} else { 		document.getElementById('roster-sidebar').removeAttribute('class'); 	} 	document.getElementById('rotate-button').removeAttribute('class'); 	document.getElementById('start-game').setAttribute('class', 'hidden'); 	if (DEBUG_MODE) { 		document.getElementById('place-randomly').removeAttribute('class'); 	} }; Game.prototype.showRestartSidebar = function() { 	var sidebar = document.getElementById('restart-sidebar'); 	sidebar.setAttribute('class', 'highlight');  	// Deregister listeners 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].removeEventListener('click', this.shootListener, false); 	} 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].removeEventListener('click', this.rosterListener, false); 	}  	var restartButton = document.getElementById('restart-game'); 	restartButton.addEventListener('click', this.restartGame, false); 	restartButton.self = this; }; // Tworzy divy HTML dla siatki dla obu graczy Game.prototype.createGrid = function() { 	var gridDiv = document.querySelectorAll('.grid'); 	for (var grid = 0; grid < gridDiv.length; grid++) { 		gridDiv[grid].removeChild(gridDiv[grid].querySelector('.no-js')); // Removes the no-js warning 		for (var i = 0; i < Game.size; i++) { 			for (var j = 0; j < Game.size; j++) { 				var el = document.createElement('div'); 				el.setAttribute('data-x', i); 				el.setAttribute('data-y', j); 				el.setAttribute('class', 'grid-cell grid-cell-' + i + '-' + j); 				gridDiv[grid].appendChild(el); 			} 		} 	} }; // inicjuje grę. Również resetuje grę, jeśli została wcześniej zainicjowana Game.prototype.init = function() { 	this.humanGrid = new Grid(Game.size); 	this.computerGrid = new Grid(Game.size); 	this.humanFleet = new Fleet(this.humanGrid, CONST.HUMAN_PLAYER); 	this.computerFleet = new Fleet(this.computerGrid, CONST.COMPUTER_PLAYER);  	this.robot = new AI(this); 	Game.stats = new Stats(); 	Game.stats.updateStatsSidebar();  	// Reset game variables 	this.shotsTaken = 0; 	this.readyToPlay = false; 	this.placingOnGrid = false; 	Game.placeShipDirection = 0; 	Game.placeShipType = ''; 	Game.placeShipCoords = [];  	this.resetRosterSidebar();  // Dodaj metodę kliknięć dla metody Grid.shoot () dla wszystkich komórek // Tylko dodaj tego słuchacza do sieci komputerowej 	var computerCells = document.querySelector('.computer-player').childNodes; 	for (var j = 0; j < computerCells.length; j++) { 		computerCells[j].self = this; 		computerCells[j].addEventListener('click', this.shootListener, false); 	} // Dodaj listener do listy	 	var playerRoster = document.querySelector('.fleet-roster').querySelectorAll('li'); 	for (var i = 0; i < playerRoster.length; i++) { 		playerRoster[i].self = this; 		playerRoster[i].addEventListener('click', this.rosterListener, false); 	}  // Dodawanie detektora kliknięć do siatki ludzkiego gracza podczas wprowadzania 	var humanCells = document.querySelector('.human-player').childNodes; 	for (var k = 0; k < humanCells.length; k++) { 		humanCells[k].self = this; 		humanCells[k].addEventListener('click', this.placementListener, false); 		humanCells[k].addEventListener('mouseover', this.placementMouseover, false); 		humanCells[k].addEventListener('mouseout', this.placementMouseout, false); 	}  	var rotateButton = document.getElementById('rotate-button'); 	rotateButton.addEventListener('click', this.toggleRotation, false); 	var startButton = document.getElementById('start-game'); 	startButton.self = this; 	startButton.addEventListener('click', this.startGame, false); 	var resetButton = document.getElementById('reset-stats'); 	resetButton.addEventListener('click', Game.stats.resetStats, false); 	var randomButton = document.getElementById('place-randomly'); 	randomButton.self = this; 	randomButton.addEventListener('click', this.placeRandomly, false); 	this.computerFleet.placeShipsRandomly(); };  // Grid object // Constructor function Grid(size) { 	this.size = size; 	this.cells = []; 	this.init(); }  // Inicjowanie i wypełnienie siatki Grid.prototype.init = function() { 	for (var x = 0; x < this.size; x++) { 		var row = []; 		this.cells[x] = row; 		for (var y = 0; y < this.size; y++) { 			row.push(CONST.TYPE_EMPTY); 		} 	} };  // Aktualizuje klasę CSS komórki w oparciu o typ przekazany Grid.prototype.updateCell = function(x, y, type, targetPlayer) { 	var player; 	if (targetPlayer === CONST.HUMAN_PLAYER) { 		player = 'human-player'; 	} else if (targetPlayer === CONST.COMPUTER_PLAYER) { 		player = 'computer-player'; 	} else { 		// Should never be called 		console.log(""There was an error trying to find the correct player's grid""); 	}  	switch (type) { 		case CONST.CSS_TYPE_EMPTY: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 		case CONST.CSS_TYPE_SHIP: 			this.cells[x+1][y+1] = CONST.TYPE_SHIP; 			break;  		case CONST.CSS_TYPE_MISS: 			this.cells[x][y] = CONST.TYPE_MISS; 			break; 		case CONST.CSS_TYPE_HIT: 			this.cells[x][y] = CONST.TYPE_HIT; 			break; 		case CONST.CSS_TYPE_SUNK: 			this.cells[x][y] = CONST.TYPE_SUNK; 			break; 		default: 			this.cells[x][y] = CONST.TYPE_EMPTY; 			break; 	} 	var classes = ['grid-cell', 'grid-cell-' + x + '-' + y, 'grid-' + type]; 	document.querySelector('.' + player + ' .grid-cell-' + x + '-' + y).setAttribute('class', classes.join(' ')); }; // Sprawdza, czy komórka zawiera nieuszkodzony statek // Zwraca boolean Grid.prototype.isUndamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_SHIP; }; // Sprawdza, czy strzał został pominięty. To jest równoważne // sprawdzenie, czy komórka zawiera kulę armatnią // Zwraca boolean Grid.prototype.isMiss = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_MISS; }; // Sprawdza, czy komórka zawiera uszkodzony statek, // uderzysz lub zatapia. // Zwraca boolean Grid.prototype.isDamagedShip = function(x, y) { 	return this.cells[x][y] === CONST.TYPE_HIT || this.cells[x][y] === CONST.TYPE_SUNK; };  // obiekt Floty // Ten obiekt służy do śledzenia portfela statków gracza // Konstruktor function Fleet(playerGrid, player) { 	this.numShips = CONST.AVAILABLE_SHIPS.length; 	this.playerGrid = playerGrid; 	this.player = player; 	this.fleetRoster = []; 	this.populate(); } // Posiada flotę Fleet.prototype.populate = function() { 	for (var i = 0; i < this.numShips; i++) { 		// loop over the ship types when numShips > Constants.AVAILABLE_SHIPS.length 		var j = i % CONST.AVAILABLE_SHIPS.length; 		this.fleetRoster.push(new Ship(CONST.AVAILABLE_SHIPS[j], this.playerGrid, this.player)); 	} }; // umieszcza statek i zwraca, czy miejsce docelowe jest skuteczne // Zwraca boolean Fleet.prototype.placeShip = function(x, y, direction, shipType) { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var shipTypes = this.fleetRoster[i].type;  		if (shipType === shipTypes && 			this.fleetRoster[i].isLegal(x, y, direction)) { 			this.fleetRoster[i].create(x, y, direction, false); 			shipCoords = this.fleetRoster[i].getAllShipCells();  			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 			} 			return true; 		} 	} 	return false; }; // Miejsca statków są losowo umieszczane na pokładzie // TODO: Unikaj umieszczania statków zbyt blisko siebie Fleet.prototype.placeShipsRandomly = function() { 	var shipCoords; 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var illegalPlacement = true; 	 		// Prevents the random placement of already placed ships 		if(this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] === CONST.USED) { 			continue; 		} 		while (illegalPlacement) { 			var randomX = Math.floor(10*Math.random()); 			var randomY = Math.floor(10*Math.random()); 			var randomDirection = Math.floor(2*Math.random()); 			 			if (this.fleetRoster[i].isLegal(randomX, randomY, randomDirection)) { 				this.fleetRoster[i].create(randomX, randomY, randomDirection, false); 				shipCoords = this.fleetRoster[i].getAllShipCells(); 				illegalPlacement = false; 			} else { 				continue; 			} 		} 		if (this.player === CONST.HUMAN_PLAYER && Game.usedShips[i] !== CONST.USED) { 			for (var j = 0; j < shipCoords.length; j++) { 				this.playerGrid.updateCell(shipCoords[j].x, shipCoords[j].y, 'ship', this.player); 				Game.usedShips[i] = CONST.USED; 			} 		} 	} }; // Znajduje statek według lokalizacji // Zwraca obiekt statku znajdujący się pod adresem (x, y) // Jeśli żaden statek nie istnieje w (x, y), zamiast tego zwraca null Fleet.prototype.findShipByCoords = function(x, y) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		var currentShip = this.fleetRoster[i]; 		if (currentShip.direction === Ship.DIRECTION_VERTICAL) { 			if (y === currentShip.yPosition && 				x >= currentShip.xPosition && 				x < currentShip.xPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} else { 			if (x === currentShip.xPosition && 				y >= currentShip.yPosition && 				y < currentShip.yPosition + currentShip.shipLength) { 				return currentShip; 			} else { 				continue; 			} 		} 	} 	return null; }; // Znajduje statek według jego typu // Param shipType to ciąg znaków // Zwraca obiekt statku, który jest typu typu shipType // Jeśli żaden statek nie istnieje, zwraca null. Fleet.prototype.findShipByType = function(shipType) { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		if (this.fleetRoster[i].type === shipType) { 			return this.fleetRoster[i]; 		} 	} 	return null; }; // Checks to see if all ships have been sunk // Returns boolean Fleet.prototype.allShipsSunk = function() { 	for (var i = 0; i < this.fleetRoster.length; i++) { 		// If one or more ships are not sunk, then the sentence ""all ships are sunk"" is false. 		if (this.fleetRoster[i].sunk === false) { 			return false; 		} 	} 	return true; };  // Ship object // Constructor function Ship(type, playerGrid, player) { 	this.damage = 0; 	this.type = type; 	this.playerGrid = playerGrid; 	this.player = player;  	switch (this.type) { 		case CONST.AVAILABLE_SHIPS[0]: 			this.shipLength = 5; 			break; 		case CONST.AVAILABLE_SHIPS[1]: 			this.shipLength = 4; 			break; 		case CONST.AVAILABLE_SHIPS[2]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[3]: 			this.shipLength = 3; 			break; 		case CONST.AVAILABLE_SHIPS[4]: 			this.shipLength = 2; 			break; 		default: 			this.shipLength = 3; 			break; 	} 	this.maxDamage = this.shipLength; 	this.sunk = false; } // Sprawdza, czy umieszczenie statku jest legalne // Zwraca boolean Ship.prototype.isLegal = function(x, y, direction) { 	// najpierw sprawdź czy statek znajduje się w sieci ... 	if (this.withinBounds(x, y, direction))  	{ 	// ... sprawdź, czy nie koliduje z innym statkiem 		for (var i = 0; i < this.shipLength; i++)  		{ 			if (direction === Ship.DIRECTION_VERTICAL)  			{ 				if (this.playerGrid.cells[x + i][y] === CONST.TYPE_SHIP || 				this.playerGrid.cells[x - i][y] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_MISS || 					this.playerGrid.cells[x + i][y] === CONST.TYPE_SUNK)  				 					{ 					return false; 				     } 			}  			else  			{ 				if (this.playerGrid.cells[x][y + i] === CONST.TYPE_SHIP || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_MISS || 					this.playerGrid.cells[x][y + i] === CONST.TYPE_SUNK)  					{ 					return false;}				 			}			 		}		 		return true; 	}  	else  		return false;	 }; // Sprawdza, czy statek znajduje się w granicach sieci // Zwraca boolean //statek mieści się w granicach gry Ship.prototype.withinBounds = function(x, y, direction) { 	if (direction === Ship.DIRECTION_VERTICAL) { 		return x + this.shipLength <= Game.size; 	} else { 		return y + this.shipLength <= Game.size; 	} }; // zwiększa licznik uszkodzeń statku // Zwraca statek Ship.prototype.incrementDamage = function() { 	this.damage++; 	if (this.isSunk()) { 		this.sinkShip(false); // Sinks the ship 	} }; // Sprawdza, czy statek jest zatopiony // Zwraca boolean Ship.prototype.isSunk = function() { 	return this.damage >= this.maxDamage; }; // Zanurzysz statek Ship.prototype.sinkShip = function(virtual) { 	this.damage = this.maxDamage; // Force the damage to exceed max damage 	this.sunk = true;  // Uczynienie klasy CSS zatopionej, ale tylko wtedy, gdy statek nie jest wirtualny 	if (!virtual) { 		var allCells = this.getAllShipCells(); 		for (var i = 0; i < this.shipLength; i++) { 			this.playerGrid.updateCell(allCells[i].x, allCells[i].y, 'sunk', this.player); 		} 	} };  Ship.prototype.getAllShipCells = function() { 	var resultObject = []; 	for (var i = 0; i < this.shipLength; i++) { 		if (this.direction === Ship.DIRECTION_VERTICAL) { 			resultObject[i] = {'x': this.xPosition + i, 'y': this.yPosition}; 		} else { 			resultObject[i] = {'x': this.xPosition, 'y': this.yPosition + i}; 		} 	} 	return resultObject; }; // Inicjuje statek o podanym współrzędnym i kierunku (łożyska). // Jeśli statek zostanie uznany za ""wirtualny"", wtedy statek zostanie zainicjowany // jego współrzędne, ale NIE umieszcza się na siatce. Ship.prototype.create = function(x, y, direction, virtual) { 	// This function assumes that you've already checked that the placement is legal 	this.xPosition = x; 	this.yPosition = y; 	this.direction = direction;  	// Jeśli statek jest wirtualny, nie dodaj go do sieci. 	if (!virtual) { 		for (var i = 0; i < this.shipLength; i++) { 			if (this.direction === Ship.DIRECTION_VERTICAL) { 				this.playerGrid.cells[x + i][y] = CONST.TYPE_SHIP; 			} else { 				this.playerGrid.cells[x][y + i] = CONST.TYPE_SHIP; 			} 		} 	} 	 }; // direction === 0 when the ship is facing north/south // direction === 1 when the ship is facing east/west Ship.DIRECTION_VERTICAL = 0; Ship.DIRECTION_HORIZONTAL = 1;  // Tutorial Object // Constructor function Tutorial() { 	this.currentStep = 0; 	// Check if 'showTutorial' is initialized, if it's uninitialized, set it to true. 	this.showTutorial = localStorage.getItem('showTutorial') !== 'false'; } // Advances the tutorial to the next step Tutorial.prototype.nextStep = function() { 	var humanGrid = document.querySelector('.human-player'); 	var computerGrid = document.querySelector('.computer-player'); 	switch (this.currentStep) { 		case 0: 			document.getElementById('roster-sidebar').setAttribute('class', 'highlight'); 			document.getElementById('step1').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 1: 			document.getElementById('roster-sidebar').removeAttribute('class'); 			document.getElementById('step1').removeAttribute('class'); 			humanGrid.setAttribute('class', humanGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step2').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 2: 			document.getElementById('step2').removeAttribute('class'); 			var humanClasses = humanGrid.getAttribute('class'); 			humanClasses = humanClasses.replace(' highlight', ''); 			humanGrid.setAttribute('class', humanClasses); 			this.currentStep++; 			break; 		case 3: 			computerGrid.setAttribute('class', computerGrid.getAttribute('class') + ' highlight'); 			document.getElementById('step3').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 4: 			var computerClasses = computerGrid.getAttribute('class'); 			document.getElementById('step3').removeAttribute('class'); 			computerClasses = computerClasses.replace(' highlight', ''); 			computerGrid.setAttribute('class', computerClasses); 			document.getElementById('step4').setAttribute('class', 'current-step'); 			this.currentStep++; 			break; 		case 5: 			document.getElementById('step4').removeAttribute('class'); 			this.currentStep = 6; 			this.showTutorial = false; 			localStorage.setItem('showTutorial', false); 			break; 		default: 			break; 	} };  // AI Object // Optimal battleship-playing AI // Constructor function AI(gameObject) { 	this.gameObject = gameObject; 	this.virtualGrid = new Grid(Game.size); 	this.virtualFleet = new Fleet(this.virtualGrid, CONST.VIRTUAL_PLAYER);  	this.probGrid = []; // Probability Grid 	this.initProbs(); 	this.updateProbs(); } AI.PROB_WEIGHT = 5000; // arbitrarily big number // jaka masa ma przynieść komórki wysokiego prawdopodobieństwa książki otwartej AI.OPEN_HIGH_MIN = 20; AI.OPEN_HIGH_MAX = 30; // ile wagi daje się średnim prawdopodobieństwom książki otwarcia AI.OPEN_MED_MIN = 15; AI.OPEN_MED_MAX = 25; // how much weight to give to the opening book's low probability cells AI.OPEN_LOW_MIN = 10; AI.OPEN_LOW_MAX = 20; // Amount of randomness when selecting between cells of equal probability AI.RANDOMNESS = 0.1; // AI's opening book. // This is the pattern of the first cells for the AI to target AI.OPENINGS = [ 	{'x': 7, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 2, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 7, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 2, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 6, 'y': 6, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 3, 'y': 3, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 5, 'y': 5, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	{'x': 4, 'y': 4, 'weight': getRandom(AI.OPEN_LOW_MIN, AI.OPEN_LOW_MAX)}, 	// {'x': 9, 'y': 5, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 0, 'y': 4, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 5, 'y': 9, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	// {'x': 4, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 0, 'y': 8, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 1, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 8, 'y': 0, 'weight': getRandom(AI.OPEN_MED_MIN, AI.OPEN_MED_MAX)}, 	{'x': 9, 'y': 1, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 9, 'y': 9, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)}, 	{'x': 0, 'y': 0, 'weight': getRandom(AI.OPEN_HIGH_MIN, AI.OPEN_HIGH_MAX)} ]; // Zrzuca siatkę w oparciu o maksymalne prawdopodobieństwo i strzela do komórki // ma największe prawdopodobieństwo zawarcia statku AI.prototype.shoot = function() { 	var maxProbability = 0; 	var maxProbCoords; 	var maxProbs = []; 	 	// Add the AI's opening book to the probability grid 	for (var i = 0; i < AI.OPENINGS.length; i++) { 		var cell = AI.OPENINGS[i]; 		if (this.probGrid[cell.x][cell.y] !== 0) { 			this.probGrid[cell.x][cell.y] += cell.weight; 		} 	}  	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			if (this.probGrid[x][y] > maxProbability) { 				maxProbability = this.probGrid[x][y]; 				maxProbs = [{'x': x, 'y': y}]; // Replace the array 			} else if (this.probGrid[x][y] === maxProbability) { 				maxProbs.push({'x': x, 'y': y}); 			} 		} 	}  	maxProbCoords = Math.random() < AI.RANDOMNESS ? 	maxProbs[Math.floor(Math.random() * maxProbs.length)] : 	maxProbs[0];  	var result = this.gameObject.shoot(maxProbCoords.x, maxProbCoords.y, CONST.HUMAN_PLAYER); 	 	// If the game ends, the next lines need to be skipped. 	if (Game.gameOver) { 		Game.gameOver = false; 		return; 	}  	this.virtualGrid.cells[maxProbCoords.x][maxProbCoords.y] = result;  	// If you hit a ship, check to make sure if you've sunk it. 	if (result === CONST.TYPE_HIT) { 		var humanShip = this.findHumanShip(maxProbCoords.x, maxProbCoords.y); 		if (humanShip.isSunk()) { 			// Remove any ships from the roster that have been sunk 			var shipTypes = []; 			for (var k = 0; k < this.virtualFleet.fleetRoster.length; k++) { 				shipTypes.push(this.virtualFleet.fleetRoster[k].type); 			} 			var index = shipTypes.indexOf(humanShip.type); 			this.virtualFleet.fleetRoster.splice(index, 1);  			// Update the virtual grid with the sunk ship's cells 			var shipCells = humanShip.getAllShipCells(); 			for (var _i = 0; _i < shipCells.length; _i++) { 				this.virtualGrid.cells[shipCells[_i].x][shipCells[_i].y] = CONST.TYPE_SUNK; 			} 		} 	} 	// Update probability grid after each shot 	this.updateProbs(); }; // Update the probability grid AI.prototype.updateProbs = function() { 	var roster = this.virtualFleet.fleetRoster; 	var coords; 	this.resetProbs(); // Prawdopodobieństwa nie są znormalizowane, aby pasowały do przedziału [0, 1] // dlatego, że jesteśmy zainteresowani maksymalną wartością.  // Działa to poprzez dopasowanie każdego statku do każdej komórki w każdej orientacji // W każdej komórce, tym bardziej legalnym sposobem, w jaki statek może przechodzić przez niego, tym bardziej // prawdopodobnie komórka ma zawierać statek. // Komórki otaczające znane ""trafienia"" otrzymują arbitralnie duże prawdopodobieństwo // tak, że AI próbuje całkowicie zatopić statek przed przejściem dalej.  // TODO: Pomyśl o bardziej efektywnej implementacji 	for (var k = 0; k < roster.length; k++) { 		for (var x = 0; x < Game.size; x++) { 			for (var y = 0; y < Game.size; y++) { 				if (roster[k].isLegal(x, y, Ship.DIRECTION_VERTICAL)) { 					roster[k].create(x, y, Ship.DIRECTION_VERTICAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var i = 0; i < coords.length; i++) { 							this.probGrid[coords[i].x][coords[i].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _i = 0; _i < coords.length; _i++) { 							this.probGrid[coords[_i].x][coords[_i].y]++; 						} 					} 				} 				if (roster[k].isLegal(x, y, Ship.DIRECTION_HORIZONTAL)) { 					roster[k].create(x, y, Ship.DIRECTION_HORIZONTAL, true); 					coords = roster[k].getAllShipCells(); 					if (this.passesThroughHitCell(coords)) { 						for (var j = 0; j < coords.length; j++) { 							this.probGrid[coords[j].x][coords[j].y] += AI.PROB_WEIGHT * this.numHitCellsCovered(coords); 						} 					} else { 						for (var _j = 0; _j < coords.length; _j++) { 							this.probGrid[coords[_j].x][coords[_j].y]++; 						} 					} 				}  				// Set hit cells to probability zero so the AI doesn't 				// target cells that are already hit 				if (this.virtualGrid.cells[x][y] === CONST.TYPE_HIT) { 					this.probGrid[x][y] = 0; 				} 			} 		} 	} }; // Initializes the probability grid for targeting AI.prototype.initProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		var row = []; 		this.probGrid[x] = row; 		for (var y = 0; y < Game.size; y++) { 			row.push(0); 		} 	} }; // Resets the probability grid to all 0. AI.prototype.resetProbs = function() { 	for (var x = 0; x < Game.size; x++) { 		for (var y = 0; y < Game.size; y++) { 			this.probGrid[x][y] = 0; 		} 	} }; AI.prototype.metagame = function() { 	// Inputs: 	// Proximity of hit cells to edge 	// Proximity of hit cells to each other 	// Edit the probability grid by multiplying each cell with a new probability weight (e.g. 0.4, or 3). Set this as a CONST and make 1-CONST the inverse for decreasing, or 2*CONST for increasing }; // Finds a human ship by coordinates // Returns Ship AI.prototype.findHumanShip = function(x, y) { 	return this.gameObject.humanFleet.findShipByCoords(x, y); }; // Checks whether or not a given ship's cells passes through // any cell that is hit. // Returns boolean AI.prototype.passesThroughHitCell = function(shipCells) { 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			return true; 		} 	} 	return false; }; // Gives the number of hit cells the ships passes through. The more // cells this is, the more probable the ship exists in those coordinates // Returns int AI.prototype.numHitCellsCovered = function(shipCells) { 	var cells = 0; 	for (var i = 0; i < shipCells.length; i++) { 		if (this.virtualGrid.cells[shipCells[i].x][shipCells[i].y] === CONST.TYPE_HIT) { 			cells++; 		} 	} 	return cells; };  // Global constant only initialized once var gameTutorial = new Tutorial();  // Start the game var mainGame = new Game(10);  })();  // Array.prototype.indexOf workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf if (!Array.prototype.indexOf) { 	Array.prototype.indexOf = function (searchElement, fromIndex) {  		var k;  		// 1. Let O be the result of calling ToObject passing 		//    the this value as the argument. 		if (this === null || this === undefined) { 			throw new TypeError('""this"" is null or not defined'); 		}  		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get 		//    internal method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If len is 0, return -1. 		if (len === 0) { 			return -1; 		}  		// 5. If argument fromIndex was passed let n be 		//    ToInteger(fromIndex); else let n be 0. 		var n = +fromIndex || 0;  		if (Math.abs(n) === Infinity) { 			n = 0; 		}  		// 6. If n >= len, return -1. 		if (n >= len) { 			return -1; 		}  		// 7. If n >= 0, then Let k be n. 		// 8. Else, n<0, Let k be len - abs(n). 		//    If k is less than 0, then let k be 0. 		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);  		// 9. Repeat, while k < len 		while (k < len) { 			var kValue; 			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the 			//    HasProperty internal method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			//    i.  Let elementK be the result of calling the Get 			//        internal method of O with the argument ToString(k). 			//   ii.  Let same be the result of applying the 			//        Strict Equality Comparison Algorithm to 			//        searchElement and elementK. 			//  iii.  If same is true, return k. 			if (k in O && O[k] === searchElement) { 				return k; 			} 			k++; 		} 		return -1; 	}; }  // Array.prototype.map workaround for IE browsers that don't support it // From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map // Production steps of ECMA-262, Edition 5, 15.4.4.19 // Reference: http://es5.github.io/#x15.4.4.19 if (!Array.prototype.map) {  	Array.prototype.map = function(callback, thisArg) {  		var T, A, k;  		if (this == null) { 			throw new TypeError("" this is null or not defined""); 		}  		// 1. Let O be the result of calling ToObject passing the |this|  		//    value as the argument. 		var O = Object(this);  		// 2. Let lenValue be the result of calling the Get internal  		//    method of O with the argument ""length"". 		// 3. Let len be ToUint32(lenValue). 		var len = O.length >>> 0;  		// 4. If IsCallable(callback) is false, throw a TypeError exception. 		// See: http://es5.github.com/#x9.11 		if (typeof callback !== ""function"") { 			throw new TypeError(callback + "" is not a function""); 		}  		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined. 		if (arguments.length > 1) { 			T = thisArg; 		}  		// 6. Let A be a new array created as if by the expression new Array(len)  		//    where Array is the standard built-in constructor with that name and  		//    len is the value of len. 		A = new Array(len);  		// 7. Let k be 0 		k = 0;  		// 8. Repeat, while k < len 		while (k < len) {  			var kValue, mappedValue;  			// a. Let Pk be ToString(k). 			//   This is implicit for LHS operands of the in operator 			// b. Let kPresent be the result of calling the HasProperty internal  			//    method of O with argument Pk. 			//   This step can be combined with c 			// c. If kPresent is true, then 			if (k in O) {  				// i. Let kValue be the result of calling the Get internal  				//    method of O with argument Pk. 				kValue = O[k];  				// ii. Let mappedValue be the result of calling the Call internal  				//     method of callback with T as the this value and argument  				//     list containing kValue, k, and O. 				mappedValue = callback.call(T, kValue, k, O);  				// iii. Call the DefineOwnProperty internal method of A with arguments 				// Pk, Property Descriptor  				// { Value: mappedValue,  				//   Writable: true,  				//   Enumerable: true,  				//   Configurable: true }, 				// and false.  				// In browsers that support Object.defineProperty, use the following: 				// Object.defineProperty(A, k, {  				//   value: mappedValue,  				//   writable: true,  				//   enumerable: true,  				//   configurable: true  				// });  				// For best browser support, use the following: 				A[k] = mappedValue; 			} 			// d. Increase k by 1. 			k++; 		}  		// 9. return A 		return A; 	}; }  // Browser compatability workaround for transition end event names. // From modernizr: http://stackoverflow.com/a/9090128 function transitionEndEventName() { 	var i, 		undefined, 		el = document.createElement('div'), 		transitions = { 			'transition':'transitionend', 			'OTransition':'otransitionend',  // oTransitionEnd in very old Opera 			'MozTransition':'transitionend', 			'WebkitTransition':'webkitTransitionEnd' 		};  	for (i in transitions) { 		if (transitions.hasOwnProperty(i) && el.style[i] !== undefined) { 			return transitions[i]; 		} 	} }  // Returns a random number between min (inclusive) and max (exclusive) function getRandom(min, max) { 	return Math.random() * (max - min) + min; }  // Toggles on or off DEBUG_MODE function setDebug(val) { 	DEBUG_MODE = val; 	localStorage.setItem('DEBUG_MODE', val); 	localStorage.setItem('showTutorial', 'false'); 	window.location.reload(); };"
"Z racji tego, że mamy już programy 500+, teraz wchodzi nowy mama 4+ co sądzicie o tym by wprowadzić równie niedorzeczny program pt. Programista 15k+? Dlaczego nam się należą te pieniądze?  programowanie to ciężka umysłowa praca pracujemy w trudnych warunkach (php, html4, stara java itp itd) nieustanne zmiany w pracy konieczność ciągłego dokształcania się użeranie się w wrednymi i głupimi klientami z wiekiem jesteśmy coraz mniej wydajni i wolniej nam przychodzi poznawanie nowych bibliotek duże ryzyko zastąpienia nas inną tanią siłą roboczą (hindusami), skończoną ilością studentów lub AI i jeszcze wiele innych by się znalazło.  Co z elektoratem? Znajdzie się - przecież mamy już dziesiątki tysięcy bootcampowców, którzy też wpompowali już masę kasy na naukę. Proponowałbym by z takiego programu mogli korzystać tylko najgorzej zarabiający programiści np poniżej 4k i na UoP - czym by to skutkowało?  większość obecnych programistów 15k zatrudniałaby się gdziekolwiek za taką stawkę i czerpała benefity z 15k+ coraz więcej studentów by kończyło studia coraz więcej bootkampów by zarabiało na ludziach (wpływy do skarbu Państwa z podatków byłyby odczuwalne) pracodawcy mogliby więcej zaoszczędzić na pracownikach (w końcu to Państwo by wypłacało omawiane 15k+) państwo by nie cierpiało na tych z b2b co pieluchy i prezerwatywy na faktury biorą (więc ukróci się kombinowanie z fakturkami)  Same plusy :) kto jest za? Jak do tego podejść pod kątem ustaw i innych takich... no cóż... od czego jest kickstarter i ""negocjacje finansowe"" z lokalnymi władzami. Zresztą, kumaci jesteśmy :) Make polish IT great at least once.... Pozdro 600+;"
"@piotrpo: (odnośnie komentarzy do powyższego posta) Bootcampowcy dorosną, się douczą, a ci obecni programiści będą lata świetlne przed nimi :) Każdego dnia tworzy się jakaś nowa nisza na rynku.  20lat temu mało kto wierzył w to, że GPS'y będą dostępne nawet dla dzieci w byle słabym telefonie. 15 lat temu mało kto by myślał, że może powstać coś takiego jak uber czy wykorzystanie AI. 10 lat temu nikt sobie nie zaprzątał głowy augumented i virtual reality 5 lat temu większość ludzi mało co wiedziała o bitcoinach.  Idąc Twoim tokiem rozumowania zakładam że za 5 lat nic nowego nie powstanie, boom na programistów zmaleje, zaleją nas hindusi, bootcampowcy i pewnie jeszcze powiesz, że AI nas zastąpi. No ciekawe. Nie jestem żadnym świeżakiem, na 4p konto mam od ponad 10 lat i widzę co się dzieje. Ty natomiast wypisujesz jakieś herezje :) Rozumiem, że prywatne linie lotnicze które umożliwią loty w kosmos, naśladując działalność Muska, zatrudnią tam tanich hindusów, a ich frontendowe stronki/sklepy do sprzedawania tego typu usług będą generowane z automatu lub przez Panią krysię z HR'ów (wix.com?) Administracji możliwe że będzie coraz mniej, bo coraz więcej instytucji przechodzi na IT - tak więc Pani Krysia zamiast latać po 4 piętrach biurowca by zebrać podpisy, wyśle jednego requesta w appce i tyle. W razie potrzeby druknie. Polecam spytać kogoś znajomego jak wygląda praca w urzędzie miejskim, to się załamiesz jak zobaczysz jaki beton siedzi tam obecnie.;"
"hm, patrzysz na ten kod w C++ i teoretycznie linijka po linijce go sobie przepisujesz.. Masz coś takiego: n = funkcja_do_wprowadzania_danych(""n:"")  for i in zasieg_od_do(1, rzutuj_mnie(n)+1):   wypisz_na_konsole(i%7)  Hint1: zastąp polskie nazwy odpowiednimi funkcjami w języku angielskim/Python i po robocie.. Hint2: możesz rzucić okiem na wpis od @Mokrowski ;);"
"O ile dobrze rozumiem, to koncepcja która stoi za C2 to ""lepsze C"". C2 wg tego co mają na stronie to rzeczywiście, ostrożne ulepszenie C, które powinno powstać w latach 80-tych. Nim z drugiej strony to nowy język który ma tyle nowości, że spokojnie może zastąpić C, Pascala, Go i Rust (wiem że brzmię trochę jak fanboy). Nim to C na miarę XXI wieku (czyli 40 lat później): https://nim-lang.org/docs/tut1.html i https://nim-by-example.github.io/getting_started/ Co mi się podoba w Nim?  obsługa łańcuchów (takich normalnych i tych z C) niemutowalne zmienne (let) kontrola efektów ubocznych  opcjonalny GC parametry nazwane własne operatory iteratory podzakresy zbiory (sets) tablice z rozmiarem tablice otwarte (bez stałego rozmiaru) wycinki (slices) tuples moduły wyjątki generyki itd...  Może obiektowość jest w tym języku słaba, ale dlatego nie wspominam o C++ ani o tym że to jest jakiś nowy najlepszy język do wszystkiego. Jest po prostu lepszym C.;"
"Studia są po to, żebyś mógł sobie poszerzyć horyzonty, porobić coś ciekawego zanim pójdziesz odbębniać dożywocie w topowych wschodnio-europejskich outsourcingach IT - jak jesteś w kole naukowym i realizujecie jakiś fajny projekt to tylko tym lepiej, jak nie to pora o jakimś pomyśleć, bo pod koniec roku pewnie będą rozpisywane granty na przyszły rok i trzeba będzie mieć z czym pójść do kierownika katedry / dziekana / prorektora etc. Przynajmniej na AGH tak było ;) Sporą wartością jest też to, że w pewnym sensie zmuszają do zajmowania się takimi rzeczami i od takiej strony, o których sam byś raczej nie pomyślał żeby zrobić - czasem na szczęście pośrednio, czasem niestety przez bezpośredni nakaz ""robienia tego i tego koniecznie w ten sposób"". No i dowiadujesz się, jak wielu rzeczy nie wiesz - czasami ludzie siedzą w swoim małym, wąskim światku i myślą, że pozjadali wszystkie rozumy - a to bardzo źle, i dla nich i dla otoczenia. Był nawet niedawno taki wątek na forum z ninja-guru-niewiadomoco w roli głównej :D A jak chcesz ""kursu programowania"", to idź na kurs programowania i tyle - teraz się reklamują na pęczki, jakie to świetne nie są i jak to nie pozwalają uchronić się przed zastąpieniem przez roboty, AI i inne współczesne straszaki na ludzi. Zero teorii i głupot ze studiów, samo klepanie kodu, prześcigają się kto szybciej robi z ludzi (wannabe) juniorów Javy czy co tam akurat tłuką na takim kursie. Tylko mam wątpliwości czy takie coś jest warte swojej ceny... @Render125  Nooo nie do końca. Jak dla kogoś studiowanie jest równoważne ze zrobieniem absolutnego ""planu minimum"" na studiach, tylko tyle żeby się prześliznąć na 3.0 i nie mieć problemów albo ew. wesprzeć się jeszcze warunkami z czego się da no to coś takiego kompletnie nie ma sensu. Jeszcze lepiej, jak taki ancymon jest totalnie niesamodzielny i co może wykuć, to wykuje, a z resztą trzeba ciągnąć za rączkę. No ale jak się to traktuje na poważnie i robi (próbuje robić - z możliwościami jest niestety różnie) coś więcej - to jakoś nie widzę co w tym złego. Tym bardziej, że studia w teorii mają polegać m.in. na samodzielnej nauce (no ale znowu, plany minimum i inne takie), a z pracą też się nie wykluczają, choć z tym bywają niezłe jaja.;"
"Cześć wszystkim! Sprowadził mnie tutaj WIELKI dylemat życiowy. Chcę, żeby wypowiedziały się osoby, które czują podobnie, jak i takie, które nie rozumieją mojego podejścia do życia. Najpierw przedstawię swoje doświadczenia, a później spostrzeżenia. O mnie / krótko-długa historia: Od 6 klasy szkoły podstawowej  (ok. 2001-02 rok) mam kontakt z programowaniem. W ten świat wprowadziła mnie książka Romana Poznańskiego pt. ""Przygody z komputerem i bez komputera"" oraz moje ukochane Commodore 64. Tak zacząłem się uczyć programować w języku BASIC. Później w gimnazjum spędzałem popołudnia u kolegi, który wybywał do dziewczyny, a ja mogłem na jego komputerze tworzyć pierwsze strony w HTMLu w notatniku, a później w Pajączku i FrontEndzie (kto jeszcze pamięta?). Kiedy w końcu rodzice kupili pierwszego PCta, byłem przeszczęśliwy, że będę mógł edytować zapisane na dyskietkach swoje strony. Oczywiście zaangażowałem się wtedy w stronę gimnazjum i drużyny harcerskiej. Liznąłem nawet Macromedia Flash i tajemny ActionScript. W liceum również byłem jedynym specjalistą od strony szkoły. Znałem już CSS, JS, PHPa. W wieku 16 lat zrobiłem swojego pierwszego CMSa, bo to była kwestia honoru. Ówczesny PHPNuke i PHPFusion nie spełniały moich oczekiwań. To były piękne czasy fascynacji technologią. Wspominam je z łezką w oku. Po liceum, czyli od 2009 roku zacząłem zawodowo zajmować się programowaniem, ale też innymi rzeczami pomiędzy zleceniami. Studia olałem po paru miesiącach, bo nie mogłem realizować swoich pomysłów, od których nie mogłem zasnąć. Postanowiłem zdobyć chociaż tytuł zawodowy informatyka o specjalizacji programisty w technikum policealnym, w końcu to tylko dwa lata, a nie 5 lat. Odbyłem w międzyczasie jakieś kursy informatyczne i programowania np. C#/WPF, RedHat. Zdobywałem zatrudnienie w różnych firmach, ale po paru miesiącach sam podejmowałem decyzję o zakończeniu współpracy, ponieważ nie odpowiadała mi atmosfera. Pracowałem w Januszpolach, Łagropolach, Korpo, na UoP i na B2B. Najdłużej pracowałem w jednym ""zakładzie pracy"" 1,5 roku. Zawsze dużo wymagałem od siebie, tworzyłem czytelny, samoopisujący się kod, według obowiązujących standardów, z zachowaniem konkretnej struktury i metodyk programowania, dokumentowałem moje postępy. Ostatnio zrezygnowałem ze współpracy w jednej ze stabilnych firm, gdzie atmosfera koleżeńska była bardzo w porządku, kasa była zawsze na czas. O odejściu zdecydowało pogarszające się zdrowie, brak kompetencji ze strony kierownictwa projektu, brak rozwoju i zbyt słabe warunki finansowe. Wnioski: Obserwując rynek z perspektywy ostatnich kilku lat kiedy to utknąłem w jakimś stacku technologicznym, widzę, że trochę się pozmieniało. Nie tylko w zakresie trendów technologicznych, terminologii, ale też namnożyło się bootcampów, które roztaczają wizję, jak to każdy może kosić hajs, kto przejdzie kurs. Poza tym docierają do mnie sygnały, że niebawem zastąpi nas AI, albo, że klient będzie w stanie sam z klocków zaprojektować cały proces zbierania i przetwarzania danych. Boję się, że programista nie będzie już tak niezbędny dla biznesu, bo będą narzędzia, które skrócą czas oczekiwania na produkt. W większości firm z którymi miałem kontakt, wyglądało to tak, jakby firma zajmowała się mówiąc obrazowo uprawianiem pola bawełny, z której powstawała tkanina i nici, projektowało się w międzyczasie ubranie, szyło t-shirta, a później okazywało się, że ma to być garnitur! Pytania: Czy to normalne, żeby często zmieniać ""pracodawców"" poszukując lepszego miejsca dla siebie? Czy to normalne, że podczas kiedy inni widzą nadzieję w programowaniu, ja odnajduję spokój i ukojenie w pracach fizycznych, gdzie widzę jak własnymi rękami kształtuję materię? Czy tylko ja uważam, że to wszystko dzieje się tak szybko i tak nieprzewidywalnie, że nawet nie wiadomo co będzie za rok? Z pewnością nie wyczerpałem tematu i będę się odnosił w komentarzach do poszczególnych wypowiedzi. Chciałbym, żebyście przedstawili swój punkt widzenia niezależnie do tego jaką rolę pełnicie w zespole.;"
"Według dr. bioinformatyki AUBREY DE GREY jest 50% szans, że w przeciągu najbliższych 15 lat naukowcy będą w stanie przenieś mózg człowieka do robota (Avatar B), a później do sztucznego ciała - http://www.2045.com/ Udało się to już zrobić na robaku http://www.sciencealert.com/watch-scientists-have-put-a-worm-s-brain-into-a-lego-robot-s-body-and-it-works O ile Avatar B jest imo fajnym przedsięwzięciem to już Avatar C i D wydaje mi się dziwnym pomysłem... ponieważ kopa czyjeś świadomości de fakto nie przedłuży czyjegoś życia. Dodatkowo według Aubrey De Grey'a w ciągu 3 dekad (150 lat) ludzkość będzie wstanie zapobiec starzeniu dzięki nanotechnologii, ale niestety my się już na to nie załapiemy... dla nas jedynym sposobem na nieśmiertelność jest Avatar B. To wszystko brzmi abstrakcyjnie, trochę jak z filmu science-fiction, ale kiedyś ludzie tak samo myśleli o podróży na księżyc. Większość tego forum jest w przedziale wiekowym 20-30 lat, więc jest duże prawdopodobieństwo że uda nam się załapać na Avatar B. Jeśli dojdzie do produkcji masowej to koszt Avatara ma wynosić równowartość samochodu, czyli mają być ogólnodostępne. Oczywiście w miarę rozwoju roboty mają być zastąpione sztucznym ciałem, więc nie jest tak źle. Druga sprawa, nauka imo szybciej by się rozwijała gdyby były prowadzone badania na większą skale i gdyby rząd wspierał finansowo takie przedsięwzięcia... ale to tak na marginesie.   avatar_milestone.jpg (86 KB) - ściągnięć: 215;"
"""A kto konkretnie sie jaral, ze metaverse jest rewolucyjny? Oprocz Cukierka i marketingu FB oczywiscie. Jakos sobie nie przypominam "" ogromna ilość ludzi jarała się metavers. Tak samo było z crypto(w 2015 roku miałeś wszędzie płacić wirtualnym pieniądzem), VR miała być przyszłość(a dalej to ciekawostka i pixelosa), w 2015 roku samochody miały nie potrzebować kierowcy i same podejmować krytyczne decyzje podczas jazdy, w drukarkach 3D miałeś sobie wydrukować 90% domowych rzeczy, roboty w Mcdonaldzie  miały całkowicie zastąpić obsługę, NFT to też miała być przyszłość. ""Za 2 lata to będzie rok produktu x, nigdy nie widziałem aby technologia tak szybko się rozwijała"" - praktycznie o każdym z powyższych produktów pisano tak samo jak teraz o chatgpt. Świat IT jest napędzany przez hype na dane produkty, to czy to jest dobry produkt to sprawa drugorzędna, najważniejsze to aby wyciągnąć kasę od inwestorów.;"
"Bardzo 'ciekawie' wyglądają ceny API(Piszę, w wątku o zwolnieniach, bo jest dużo szumu jak to zastąpi analityków danych). Zakładając, że chcesz wysłać CSV zawierający 1000 wierszy do API, to kost wejściowych tokenów wyniósłby około. (8000 * 0.06)/1000 tj.0.48$ 123,100,1683670098 -> około 8 tokenów (id, ilosc, timestamp) Nie liczę kosztu wyjściowych, bo to zależy od analizy itd. Ciekawie, jak będą wyglądały ceny 'code interpreter', bo cały Twitter już stwierdził, że to nowy analityk danych, jednak jeżeli koszty będą porównywalne z API, to wielu się zdziwi i zrozumie, że czasami oprogramowanie zbudowane do konkretnego celu daje lepszy koszt/efekt.;"
"Jeszcze dwie rzeczy trzeba było zmienić, aby projekt dało się skompilować i uruchomić na innych platformach. Natywny uchwyt okna (typu HWND) na innych platformach jest zbędny, więc trzeba go było otoczyć dyrektywami. On jest używany tylko na Windows i tylko do aktualizacji stanu progressbara przycisku na pasku zadań — ten progressbar pokazuje jaką część czasu klatki gra zużywa na jej wygenerowanie. Im krótszy pasek postępu, tym mniej czasu CPU gra wymaga do działania. No i jak zwykle zapomniałem o zastąpieniu separatorów ścieżek na wieloplatformowe. Codebase pierwszego Fairtrisa był pisany z myślą o Windows, więc separatory były hardkodowane (znaki \) — zamieniłem je na stałą DirectorySeparator, która zawiera separator natywny dla danej platformy. Pierwwze testy wykazały, że projekt się kompiluje, uruchamia się i działa poprawnie. Teraz tylko pasuje sprawdzić czy kluczowe funkcje również działają i to w sumie tyle, jeśli o portowanie chodzi — resztę ogarniają wieloplatformowe RTL, FCL, LCL i SDL.;"
"Warto iść w tym kierunku, zwłaszcza jak masz do tego smykałkę. Co do PowerBI i certyfikacji to nie przywiązuj się za bardzo do narzędzia. W końcu to tylko kawałek UI, który można zastąpić innym (Tableu, Qlick). Ważne żeby dane pod spodem były ok. Pytanie czy chcesz iść bardziej w stronę analityka danych czy inżyniera danych. Różnica jest taka, że często analityk zajmuje się zbieraniem danych, dokumentacją, katalogowaniem, a inżynier danych mięsem czyli buduje pipeline'y do przetwarzania, integracji i analizy danych korzystając z dostępnych narzędzi. Na pierwszy rzut oka wydaje mi się że celujesz w inżyniera danych, więc tutaj SQL, Python, Jupyter Notebooks, bazy relacyjne i nierelacyjne, narzędzia do ETL (Airflow, Argo, Apache Spark, Hadoop), projektowanie hurtowni danych, data lake'ów no i chmura (AWS, Azure, GCP). Dużo programowania i zabawy z infrastrukturą IT. Dużo nauki, ale też dużo funu :);"
"@lukasz21212121: Z tym zatrudnieniem drugiej osoby chodzi o to, że kiedyś w naszej firmie pracował senior z naprawdę solidnym doświadczeniem, pracował samemu, no ale coś się stało i złożył wypowiedzenie, a firma pilnie musiała znaleźć kogoś w jego miejsce, bo wszystko by stanęło... Jako że ja na swojej rozmowie rekrutacyjnej do II linii wsparcia wspominałem, że chciałbym rozwijać się w stronę baz danych, tak też zaproponowano mi możliwość zastąpienia tego kolegi - na początku było ciężko.. mega ciężko, bo jednak zaczynałem od zera po ekspresowym wprowadzeniu, ale po czasie było już okej i tak teraz szczerze myślę, że takie wrzucenie mnie na głeboką wodę było całkiem ok - bo w stresie i pod presją czasu naprawdę dużo się przez to nauczyłem Firma teraz po prawie 2 latach chce się zabezpieczyć się na ewentualny pododbny przypadek i woli mieć dwie osoby - bo jakby jedna złożyła wypowiedzenie, to przynajmniej druga nadal będzie w stanie ogarniać całość No i też drugim powodem jest to, że chcą nam pod koniec tego roku dodać zajmowanie się bazami PostgreSQL i DB2, gdzie tych pierwszych jest całkem sporo Miasto to ok 100 tysięczne, południowa polska, firma to kapitał polski, obsługujemy sporego polskiego klienta To co najczęściej robię to m.in (pisze na szybko z głowy). instalacja nowych baz, konfiguracja nowych i starych środowisk, analiza logów, rozwiązywanie problemów, realizacja zgłoszeń, migrowanie starych środowisk do nowych, monitorowanie obciążenia, testowanie, przygotowanie dokumentacji/raportów, współpraca z firmami zewnętrznymi, odpowiednie dostrajanie środowiska, recovery testy, no i ogólnie - zapewnienia ciągłości pracy - tak aby wszystko działało jak należy    Dzięki wszystkim za odpowiedź :-);"
"Zarobki pominę milczeniem W sumie wygrałeś los na loterii. Przez dwa lata mogłeś się uczyć na środowisku produkcyjnym, a tego nie zastąpi żaden  kurs czy książka Drugi człowiek jest zabezpieczeniem  w sytuacjach losowych np. wypadek, ale nie daje 100% gwarancji. Znam przypadek gdzie w tym samym czasie odeszło do konkurencji dwóch administratorów szczęściem dla firmy został jeszcze trzeci co zapobiegło naprawdę nieciekawej sytuacji.;"
"Porównanie jest bez sensu, bo nie wiadomo co porównujemy. Ktoś może wrzucać poprawki stylistyczne, a ktoś inny zaimplementuje błyskotliwy algorytm. Jeśli ktoś chce porównać efektywność zespołów to niech zrobi eksperyment polegający na podmianie danego zespołu innym. Czyli w tym przypadku byłaby to wymiana męskich zespołów programistów na żeńskie i vice versa (żeńskich na męskie). Po czymś takim, w perspektywie kilku lat, można by sprawdzić zmiany w efektywności dostarczania wysokiej jakości oprogramowania. Poza tym, jaki ma być cel takich wojen międzypłciowych, międzyrasowych, itp itd? Jakieś komunistyczne centralne sterowanie? Dotacje, parytety, bojkoty, utrudnienia czy ułatwienia mające na celu uprzywilejowanie firm zatrudniających kobiety bądź uprzywilejowanie samych kobiet są właśnie takim komunistycznym centralnym sterowaniem. Wolny rynek polega na tym, że to kupujący decyduje sam u kogo będzie kupował i co jest dla niego dobre, a nie ktoś inny. Pracodawca kupuje pracę i na wolnym rynku tylko od niego zależy komu da pracę i za ile. Pracuję w międzynarodowej korporacji i mimo, że oficjalna propaganda głosi, że ludzie wszystkich krajów są sobie równi, to jednak usłyszałem od kadry zarządzającej, że by np zastąpić dwóch Brytyjczyków trzeba zatrudnić pięciu Hindusów, by utrzymać wydajność tworzenia oprogramowania. Na tym forum też wszyscy równo leją z Hindusów, niezależnie od preferencji politycznych. Parytety mają też niespodziewane (dla ich zwolenników) konsekwencje. Mogą np mieć efekt odwrotny od oczekiwanego jak tutaj: Sweden set to scrap university gender quotas W skrócie:  w Szwecji 60% ludzi studiujących to kobiety (podobnie jak w Polsce), zastosowano parytety płci dla obu płci, kierunki ""veterinary medicine, dentistry, medicine, and psychology"" były oblegane przez wysoko wykwalifikowane kobiety, ale przez wzgląd na parytety dostali się na nie słabi mężczyźni, 95% ludzi uwalonych przez parytety to kobiety, kierunki zdominowane przez mężczyzn były mniej dotknięte parytetami, bo nie było na nich tak dużej nadpodaży kandydatów, z powodu efektu odwrotnego niż oczekiwany, parytety zostały zniesione (o ile dobrze pamiętam; było to w innym artykule),  Wniosek z tego taki, że mężczyźni to ludzie dosłownie gorszego sortu. Jeżeli jakiś program rządowy pomaga kobietom to jest wszystko cacy, ale jeśli w imię równości przypadkowo pomoże się mężczyznom to już jest dyskryminacja kobiet i trzeba z tym skończyć. No i na koniec - podobny temat już jest: Czy kobieta programistka może liczyć na ""fory"" w zmaskulinizowanym świecie IT?;"
"Moim zdaniem całkiem słusznie xD chociaż nie powiedziałabym, że absolwenci finansów są średnio rozgarnięci ;) To dość pojemne pojęcie i dużo rzeczy w to wchodzi. Moimi słowami to ta praca polega na tym, aby z dostępnych źródeł danych wyciągnąć użyteczne dla biznesu informacje, które często są potem podstawą do podejmowania ważnych decyzji w biznesie - np. na podstawie dostępnych danych projektujesz kryteria oceny i oceniasz, które agencje, z którymi współpracujemy, pracują najlepiej. Wtedy biznes może te, które pracują najgorzej albo zastąpić kimś innym, albo postraszyć, że jak nie zwiększą efektywności, to stracą zlecenia od firmy. Tak samo można oceniać wydajność pracowników, kondycję firmy albo w ogóle cokolwiek. Biznes zadaje pytanie - Ty podajesz odpowiedź. Do BI należy też scoring klientów, czyli analiza ich zdolności kredytowej. I o ile sam koncept jest wszędzie raczej ten sam, o tyle narzędzia do realizacji BI są bardzo różne. To może być mniejszy lub większy zespół analityków, którzy robią raporty w Excelu (na podstawie danych wyciągniętych z bazy za pomocą SQL), ale mogą to być też bardziej rozbudowane narzędzia, w skład których wchodzą interaktywne raporty, automatycznie generowane statystyki co jakiś czas (np. codziennie, co tydzień, co miesiąc) itp. Dlatego też zarobki mogą być bardzo różne, bo i wymagane kompetencje mogą być inne. Z tego co wiem największe są dla ludzi, którzy ogarniają duże komercyjne narzędzia, takie jak Tableu (coś jak baza danych Oracle czy SAP). My mamy autorski system napisany od postaw w oprogramowaniu open source - IMO całkiem rozbudowany. Ma wiele z tych funkcji, za które w wersji płatnej trzeba zapłacić 10 000$/msc + trochę fikuśnych funkcji nie oferowanych nigdzie indziej. Moim zdaniem Business Intelligence jest często niedoceniane - głównie przez typowych programistów, którzy w ogóle nie wiedzą co to i po co to, bo i potrzeby biznesu średnio przeciętnego programistę interesują... natomiast popyt rośnie, bo firmy zdają sobie powoli sprawę, jak dużo korzyści może przynieść posiadanie takiego działu u siebie. Natomiast z drugiej strony jest to dział trochę typu R&D, czyli IMO bardzo przydatny, ale nie niezbędny do funkcjonowania firmy, więc ze stabilnością zatrudnienia oraz zarobkami w takim sektorze może być różnie (od bardzo wysokich przez mierne, w zależności od tego, jak mocno firma chce w coś takiego zainwestować). No i przeciętnemu programiście też wydaje się często, że ""a po co to, a na co to, jak SQL można samemu sobie napisać"", a w praktyce:  programiści często zapominają, że tego typu analizy są dedykowane osobom całkowicie nietechnicznym (menedżerom), które nie wyciągną sobie same danych z bazy, a jednak potrzebują do nich dostępu, i potrzebują je mieć w przejrzystej formie jak posadzisz programistę do zrobienia analizy, to nie każdy będzie umiał to zrobić, chociaż pewnie każdemu będzie się to wydawało ""takie proste"" ;) Już raz dostaliśmy od IT wzór raportu, jaki chcą, i myślałam, że jak od IT przyjdą wymagania, to będzie super, a musieliśmy całość zaorać i zrobić samemu od podstaw, bo w ogóle nie mieli pojęcia, jak się do tego zabrać ;)  Natomiast nie uważam też, aby to, że ""pracuję w BI"" to był jakiś dobry powód do puszenia się, bo część analityków wcale pewnie nie zajmuje się żadną rocket science, a ich codzienne zadania mogą być stosunkowo łatwe / nudne. Zależy, co kto robi - poziom może być różny, od wyciągania zupełnie podstawowych statystyk za pomocą prostych SQL i wklepywania ich do Excela, po skomplikowane algorytmy uczenia maszynowego i dość złożone aplikacje prowadzące do prezentacji tych danych... Zależy, co kto robi.;"
"Ja bym wybrał Python, jest dużo łatwiejszy od Javy, do tego Django i PostgreSQL. Zarobki wcale nie małe, a z czasem Ruby i Python zastąpi wysłużone PHP.;"
"Jakość kodu nie zależy od wielkości firmy,czasu projektu czy budżetu tylko w największym stopniu od zespołu. Najlepsi programiści z Polski w większości siedzą za granicą, na rynku jest bardzo dużo młodych, niedoświadczonych koderów i trochę mniej przeciętnych. Średnio na zespół 6 osobowy przypadają 1-2 dobre osoby. Te dobre osoby nie uciągną całego projektu same i nie mają czasu poprawiać kodu po swoich mniej doświadczonych kolegach. Kolejna sprawa - pisanie od 0 to zamrożenie produkcji na N miesięcy, podczas których nie masz możliwości walczenia na rynku a całość inwestycji jest obarczona ogromnym ryzykiem (bo nikt Ci nie zagwarantuje, że jak przepiszesz połowę kodu, to będzie lepiej, a z drugiej strony masz gwarancję, że w tym czasie nie zrealizujesz nowych featureów/założeń biznesowych). Ponadto w niektórych firmach panuje takie podejście, że każdego programistę można zastąpić skończoną liczbą studentów - przy takim podejściu raczej ciężko o dobry kod.;"
"Jest bardzo źle... Co prawda AI nas nie zastąpi, ale 1/4 firm planuje zwolnienia. Tak więc jak ktoś ma dostęp to proszę niech sprawdzi kto nas zastąpi, skoro nie AI to obstawiam:  Hindusów / kraje low-cost low code / no code wezwania do wojska;"
"Trochę już pracuje w IT  i do końca nie mogę zrozumieć nagłego nasycenia rynku. Np w fintechu zeszły rok wiele banków i instytucji finansowych miało tłusty i obfity dochód ale projekty IT dalej wstrzymywali/cięli. Co jest dziwne w branży nie możesz po prostu przestać inwestować w IT bo jest wysoce kompetytywna a do tego nigdy żadna aplikacja/usługa nie jest wieczna. Potrzeba updatów, nowych alternatywnych pomysłów. Kto pamięta naszą klasę czy gadu gadu albo my space? Facebook/Meta też nie będzie wieczny to samo dotyczy OS czy frameworków. Wniosek jest taki, że rynek wiecznie nie będzie 'nasycony' chyba, że mamy zacząć się cofać w rozwoju (back to the monkey). Jakoś nie mogę uwierzyć, że rozumni ludzie liczą na to, że Devil czy inne AI wszystko zastąpi a ludzkość nareszcie będzie mogła się skupić na roli i tyraniu na pańszczyznę.;"
To panie kolego za konsultacje się płaci a nie robi jakieś udawane rekrutacje. Dodatkowo jak mam się dołożyć do stworzenia maszyny która ma zniszczyć ludzkość a przynajmniej zastąpić programistów to trzeba będzie doliczyć parę %.;
"i właściwie przez słuchanie randomów z forum robimy programistę w stylu Chat GPT, łatwego do zastąpienia tymże czatem;"
"Jest inna architektura, bo event driven w gui programach, do tego windows ma coś typu watchdog i jeśli aplikacja nie zapyta się systemu przez jakiś czas czy są nowe eventy to uznaje za zawieszony. Przychodzą eventy do odświeżenia gui, resize, wyjścia z programu, kliknięcia buttona i tu pewnie masz jakiś onClick event, który twoją funkcję wywoła, a ten śpi sleepem i nie wraca do głównej pętli to system uznaje za zawieszony. Sama konsola to jest terminal, w nim bash odpalasz i potem twoją apkę, chodź można też otworzyć to inaczej, bezpośrednio w terminalu apkę bez basha, dodatkowo są też różne sposoby otworzenia, fork i bez czyli zastąpienie procesu innym. Jest trochę inaczej bo terminal to jakby kolejna aplikacja, która przesyła wejście stdin do aplikacji i stdout wypisuje ci na ekran z niej, więc tak jakby masz dwie aplikacje, jedna która przesyła strumień danych i odbiera, a druga co je przetwarza więc jest asynchroniczne przetworzenie. W aplikacjach sterowanych eventowo nie można od tak zawiesić sobie sleepem pętli głównej bo tam się dzieją rzeczy typu odrysowanie okna, przychodzą do tej pętli zdarzenia np. naciśnięcie przycisku na klawiaturze, ruch myszką czy naciśnięcie i po prostu nie zostaną dostarczone messages głównej aplikacji zarządzającej gui całego systemu tym CSRSS.exe. Ja w debugerze wielokrotnie przechodziłem od eventa przez całą kolejkę wiadomości do danej funkcji, która ją wykonywała. Można w ten sposób i się nauczyć jak coś działa i zrozumieć funkcję, której się poszukuje tym samym ją znajdując.;"
"Ludzie mają problem napisać wymagania zrozumiałe dla drugiego człowieka, nawet po kilku callach są nadal wątpliwości a ty byś chciał żeby tak od strzała programistów zastąpić jakimś średnio udanym toolem. Ja poprosiłem ChatGPT o to żeby mi powiedział jak poszerzyć dysk fixed size w VM Box - cuda mi naopowiadał i naobiecywał :) wg mnie to narzędzie zrobi karierę w polityce, ale na pewno nie w inżynierii czy medycynie.;"
"Kilka miesięcy i ludzie o nim zapomną, cały sztuczny szum który się teraz wokół niego rozkręca jest spowodowany spowolnieniem gospodarczym i cięciem etatów w firmach z branży IT. Tak, jest to fajny tool i czasami pomocny, ale nie ma szans aby zastąpił prawdziwego programiste (czyli nie juniora) znającego technologie i domene w której pracuje.;"
"Mi się wydaje że z GPT-5,6,... biedne kraje staną się jeszcze biedniejsza a bogate jeszcze bogatsze. Już wyjaśniam: generalnie w pierwszej kolejności na automaty przesiądą się Ci którzy już poprzednio próbowali ograniczać koszta przez outsourcing. Także firmy ubezpieczeniowe, banki ogólnie sfera poza stricte IT. Jeżeli pojawi się jakiś dostawca usług IT w stylu GPT Outsourcing Poland i kod będzie porównywalny z kodem hinduskim a cena 30% to firmy zaczną korzystać po wypróbowaniu produktu na kilku ""pilotach"". Z drugiej strony zawód analityka przeżyje renesans, ktoś w końcu musi z tym GPT rozmawiać i to raczej nie będzie pan prezes bo on nie ma ochoty omawiać tych 273 branchy flow do aktywacji karty kredytowej. Zapewne przy GPT-100 ta jedna osoba zastąpi nie tyle wszystkich programistów co cały dział IT! Natomiast w bogatych krajach ludzie dosłownie rzucą się na AI. Już teraz z GPT integruje się kto tylko może. Rynek zaleje fala nowych produktów, to spowoduje wzrost gospodarczy i jeżeli za GPT pójdzie zwiększenie produktywności to wzrośnie również bogactwo tych krajów. To że jedna osoba może zrobić robotę 3 oznacza że usługa będzie tańsza, ergo zwiększy się na nią popyt. Oczywiście część ludzi straci pracę, jak dużo ciężko to teraz przewidzieć. Generalnie biznes ma to do siebie że stara się pozbyć zbyt drogich pracowników, jak programiści będą tańsi to i presja na pozbywanie się ich zmaleje.;"
"Na tym etapie - po co w ogóle kod? Jeśli AI jest takie sprytne, to niech nie tworzy kodu w języku programowania, tylko od razu niech tworzy bajtkod. No i też po co pisać input dla AI? To też bezproduktywne? Przecież można by łatwiej. Gdyby tylko zrobiono coś takiego, że dałoby się wyklikać aplikację i napisać w języku naturalnym logikę, a później AI automatycznie przerobiło by to na bajtkod! To programiści by potracili pracę jak muchy! XD Tylko... że to już było. Jeszcze niedawno się ludzie zachwycali low-code. Czy należy więc oczekiwać, że kolejna fala low-code, opierająca się na AI wreszcie zastąpi programistów? Nie sądzę. Mam wrażenie, że zataczamy ciągle koła wokół wariacji na temat tych samych dwóch idei.  zastąpienie ""trudnego"" programowania przez ""łatwe"" pisanie komend w języku naturalnym albo zbliżonym do naturalnego zastąpienie programowania przez klikanie myszą i wyklikiwanie apek (nocode, lowcode itp.)  I potem ciągle się okazuje, że ""to nie było prawdziwe AI"" albo ""klikanie nie starcza"". Tylko, że:  jeśli programowanie jest za trudne, to może potrzebujemy po prostu łatwiejszych w użyciu (tj. bardziej wysokopoziomowych) języków programowania (i lepszych bibliotek/ekosystemu i łatwiejszych w obsłudze API), a nie protezy za pomocą asystenta, który napisze kod za ciebie. Czyli może lepiej budować kompilatory, frameworki, tooling zamiast nieprzewidywalnego AI klikanie apek się sprawdza w niektórych działkach (gamedev), a w innych działkach niekoniecznie się to przyjęło;"
"A dzisiaj mój rekrutacyjny WTF! Rozmowa o OE, ponad 10k$, gamedev. Techniczna przeszla super. Niestety na końcu dostaje ZADANIE DOMOWE. Myślę sobie - gardze zadaniami i je bojkotuje. Szkoda, ze wczesniej nie mowili. Czytam to zadanie. Ze zdziwieniem stwierdzam, ze konsolówka z bazami danych i duzo algorytmów (wtf. przeciez ja pracuje w gamedevie). Jako, ze tylko gamedevu chatgpt nie ma szans zastapic to dopalam płatną subskrypcje, wrzucam zadanko, czat GPT robi brrrr.... chat, dopisz dokumentacje, git push. Dzisiaj dostaje pozytywny feedback XD. Bez chataGPT pewnie by mi zeszlo z 10-12 godzin. Tak poswiecilem pewnie z 40 minut na sklejenie tego w całość (mogłem pewnie w 20 sie wyrobic, ale nazwy niektorych zmiennych zmienilem, bo byly obciachowe.);"
"Meanwhile, GPT-4 (Ten co was zastąpi jutro) public static void main(String[] args) {         Properties props = new Properties();         props.put(""bootstrap.servers"", ""localhost:9092"");         props.put(""group.id"", ""test-group"");         props.put(""key.deserializer"", KafkaAvroDeserializer.class.getName());         props.put(""value.deserializer"", KafkaAvroDeserializer.class.getName());         props.put(""schema.registry.url"", ""http://localhost:8081"");         props.put(""specific.avro.reader"", ""true"");          KafkaConsumer<String, GenericRecord> consumer = new KafkaConsumer<>(props);         consumer.subscribe(Collections.singletonList(""topic-a""));          Properties producerProps = new Properties();         producerProps.putAll(props);         producerProps.put(""key.serializer"", KafkaAvroSerializer.class.getName());         producerProps.put(""value.serializer"", KafkaAvroSerializer.class.getName());          KafkaProducer<String, GenericRecord> producer = new KafkaProducer<>(producerProps);          while (true) {             ConsumerRecords<String, GenericRecord> records = consumer.poll(100);             for (ConsumerRecord<String, GenericRecord> record : records) {                 GenericRecord value = record.value();                  // Assuming all fields are of type String for simplicity                 value.getSchema().getFields().forEach(field -> {                     String oldValue = value.get(field.name()).toString();                     String newValue = oldValue.toUpperCase();                     value.put(field.name(), newValue);                 });                  producer.send(new ProducerRecord<>(""output-topic"", record.key(), value));             }         }     } };"
"A przepraszam, do czego niby potrzebne poparcie ulicy? Wiesz, ze w Poznaniu były protesty w amazonie? No wlasnie, ja dowiedzialem sie przez przypadek. Czy amazon jest potrzebny do życia? Sa inne sklepy, magazynierow latwo zastapić, ale... protest ma działanie wewnętrzne. Paralizuje dzialanie firmy i naraża ją na koszty pokazuje, że jezeli nie bedzie sie szanować pracowników, to zrobią (z resztą zgodnie z prawem) pod górkę. Ciekawe, o ile te cudowne akcje google, na ktore tak patrzy ten ich ceo z kraju kurkumy by spadły, gdyby w internecie pojawialy sie informacje, ze cala zaloga google zaczela strajkowac/protestować. Jeszcze raz przypominam, ze unity chcialo wprowadzic oplace, w internecie pojawil sie protest i tego samego tygodnia CEO wylecial, a firma z bończucznych zapowiedzi się wycofała, bo akcje spadły.;"
"Fajnie za Figure 01 potrafi nasladowac czlowieka. Czyli pewnie za miesiac naglowki ""Pierwszy programista AI"" zostana zastapione przez np. ""Pierwszy gwalt dokonany przez robota"". I wtedy nie tylko programisci czy np. magazynierzy ale tez przestepcy straca prace.;"
Ciekawe kiedy roboty zastapia politykow. Mysle ze niektorych Chat GPT 3 bije na glowe inteligencja juz teraz.;
"Za 2+ lat rynek się uspokoi, Chatgpt pozostanie ciekawostką jak wiele innych technologicznych rewolucji które dalej są tylko ciekawostką(Autonomiczne pojazdy, VR etc) i będzie można odsyłać młodzików którzy myślą że trzeba posiadać wielkie zdolności analityczne aby zostać programistom do wątków ""Chatgpt zastąpi programistów"" jako motywacja do dalszej nauki.;"
"Który z tych punktów odnosi się do zastąpienia programisty? Jeżeli w 4 iteracji nie jest w stanie napisać działającego kodu który rozwiązuje trywialny problem, w izolowanym środowisku, bez pomocy programisty, to kiedy będzie w stanie rozwiązać problem w szerokim kontekście bez pomocy programisty? Łatwo jest zauważyć, że jeżeli kod robi coś innego od tego jak wygląda np. async to gpt-4 się gubi i nie ma tutaj progresu od gpt 3.5. Jak niektórzy tutaj wspomnieli wynika to z faktu, że jest to model językowy a nie inżynieryjny.;"
"próbowałem,nic, chat gpt powiedział że w urls.py trzeba zastąpić funkcję patterns, funkcjami path i re_path, spróbuję w poniedziałek;"
"Oczywiście można takie proste problemy objaśniać ""ręcznie"". Ale akurat w takich przypadkach nie trzeba się fatygować i automat może zastąpić nauczyciela... https://chat.openai.com/share/27932782-d6b5-4ecf-bdea-3127fc32d47f;"
"@Nofenak: nie używałem, ale wygląda, że https://github.com/json-path/JsonPath#filter-predicates może być funkcjonalnością, o której piszesz (tj. zastąpienie stringly typed expression czymś silniejszym).;"
"Miejmy nadzieję, że czacik GPT zastąpi tych darmozjadów w ciągu kilku lat. Tylko kto zwolni tych wszystkich nepotków?;"
"Problemem XMPP w tamtych czasach było to że chcieli mieć do wszystkiego bramkę. To miało być niby tymczasowe a skończyło się tak, że nikt faktycznie nie przechodził na XMPP. Utrzymanie stanu obcych protokołów to było mega wyzwanie i skazane na porażkę, bo mało który wtedy dawał dostęp. Trzeba było robić inżynierię wsteczną... Wymiana plików była ale fakt mało który umożliwiał rozmowy głosowe. Dzisiaj to już jednak nie problem.  Jak ktoś traktuje XMPP jako bramkę do innych protokołów to tak może i jest... XMPP miało zawsze zastąpić te wszystkie legacy protokoły. Rejestrujesz się na serwerze X i masz dostęp do znajomych jak na serwerze Y. Coś jak z pocztą e-mail. Niestety dzisiaj chodzi o kasę a nie o wolność komunikacji. btw, Wracając jednak do Discorda. To wy nazywacie to serwerem 4programmers a to przecież nie jest serwerem tak jak się to normalnie rozumie jak w poczcie email czy xmpp. Macie tam tylko wydzieloną przestrzeń a nie jakby oddzielny serwer, który się łączy z innymi serwerami w Discord?;"
"Nikt nie przechodził, bo XMPP nie pozwalał na normalną komunikację. Rozmowy grupowe to była jakaś padaka, znajdowanie pokoi, zarządzanie uprawnieniami, wszystko super rozszerzalne i jednocześnie kompletnie nieużywalne. Nic dziwnego, że Fb i GTalk z tego zrezygnowały, nie miało to sensu.  No miało zastąpić, ale nie zastąpiło, bo po prostu było do niczego dla zwykłego użytkownika. Wolność komunikacji masz dalej, jak chcesz, to sobie postaw serwer i rozmawiaj w swojej bańce, tylko że tym sposobem daleko nie zajedziesz, Twojej babci nie będzie się chciało wybierać serwera, wybierać klienta, a potem rozkminiać, czy akurat jej program wspiera XEP-a od przesyłania kotków. To ma działać.  Ale XMPP wcale nie rozwiązuje tego problemu. On Ci co najwyżej rozwiąże problem rozmowy 1 do 1, chociaż jak ktoś Twojemu znajomemu ubije serwer, to potem on będzie musiał zmieniać konto, podawać wszystkim nowy adres i ogólnie ma spory problem. Chyba, że oczekujesz, że każdy z Twoich znajomych będzie miał własny serwer, ale to bez sensu. Ale jak chodzi o rozmowy grupowe, to one muszą odbywać się w jakimś pokoju hostowanym na jakimś serwerze. Co niby zrobisz, jak nagle właściciel pokoju odłączy wtyczkę? Przecież XMPP w ogóle przed tym nie chroni, a jak to się stanie, to ludzie muszą gdzieś zmigrować. To co, będziesz wtedy hostował pokój dla dziesiątek/setek ludzi? Będziesz go doglądał na wakacjach? Czy może jednak zlecisz to komuś z zewnątrz (co sugerujesz w tym temacie) i ryzykujesz, że wtedy ten ktoś znowu odłączy wtyczkę? Twoje rozwiązanie po prostu nie działa. Miało przynajmniej kilkanaście lat na sukces, w pewnym momencie miało wzięcie w postaci mocarnych graczy na rynku, ale potem Fb i GTalk poszli sobie, bo XMPP po prostu jest do niczego. Pomysł dobry tylko w teorii.  I już tak na marginesie dodam, że zarówno XMPP jak i inne federalizowane produkty cierpią na ten sam paradoks nadmiernego wyboru. Okej, dajesz ludziom wybór, dajesz i możliwość decydowania, ale tym samym zrzucasz na nich odpowiedzialność, a to w rozwijającej się cywilizacji nie działa. Ludzie nie chcą wyboru, ludzie chcą rozwiązań. Jak idziesz do lekarza, to chcesz od niego konkretnego leczenia i konkretnych efektów, a jak ten nagle zacznie Ci tłumaczyć meandry medycyny i rozpisze 10 różnych terapii, a potem każe wybrać, to zgłupiejesz. Lekarz nie może zrzucić na Ciebie odpowiedzialności, to on ma ją wziąć, bo on się kształcił, on ma wiedzę, on ma doświadczenie. Jasne, możesz wpłynąć na pewne elementy, ale zdecydowaną większość terapii ma za Ciebie sprecyzować właśnie lekarz prowadzący. Tak samo księgowy, on może dokładnie rozpisać Ci wszystkie możliwe scenariusze obliczania podatku, ale Ciebie interesuje odpowiedź na proste pytanie - ""mam tyle i tyle kosztów miesięcznie, jak to rozliczać, żeby oddać państwu jak najmniej"". Najlepsi specjaliści to właśnie ci ludzie, którzy wezmą odpowiedzialność za Ciebie i uwolnią Cię od paradoksu wyboru. Dlatego właśnie iPhone jest popularny, dlatego właśnie Windows jest popularny, dlatego właśnie XMPP umarł - bo dał ludziom wybór i zrzucił na nich odpowiedzialność.;"
"no to już prędzej ma jakiś sens, ale i tak średnio, bo sprawa się rozbija o testowanie (które by wykryło słabe punkty) i poprawę zbioru danych do uczenia maszynowego, a oprogramowanie raczej zostaje takie samo.  tak. tabuny simpów sponsorujących (pośrednio lub bezpośrednio) byle jakie kobiety. trochę rakowe przykłady. portale randkowe to są chyba skonstruowane tak, żeby wydoić maksymalnie hajs z kolesi. podobnie zresztą jak kluby nocne, gdzie faceci zawsze bulą za wstęp, a niebrzydkie panny mają nieraz wejście za darmo, albo dużo taniej. stare, sprawdzone mechanizmy. social media też są rakowe. polegają na maksymalizacji zaangażowania użytkownika, podobnie zresztą jak i  współczesne mass media nieinternetowe. do zwiększenia zaangażowania najlepsze jest np. wzbudzenie pogardy do przeciwstawnej opcji politycznej, ekonomicznej itd i ciągłe jej obsmarowywanie.  hmm, w swojej karierze programisty jeszcze ani razu nie spotkałem się z używanym na produkcji kodem, który by jakoś te różnice kulturowe obsługiwał (nie liczę timezone'ów of koz). jedyną tego typu rzeczą, która widziałem w kodzie był kalendarz świąt, brany z jakiegoś raportu, ale on i tak został zaorany i zastąpiony kalendarzem, który nie uwzględnia żadnych świąt (a więc wolne są tylko soboty i niedziele). ewentualne świąteczne kombinowanie (sztucznie duplikowane raporty itp) załatwia się za to ręcznie. p.s. eh, znowu mi schodzi długo na klepaniu postów i marnuję czas. skróciłem posta nieco.;"
"A no wielki niestety. Zajęć innych mi nie brakuje, ale konkretnie tego nie mam czym zastąpić.;"
"Trochę z mojej strony, odnośnie tego co napisał kolega:  próg wejścia do IT jest OLBRZYMI, między innymi dlatego nikt nie chce zatrudniać juniorów.. w IT zarabia się jednak więcej niż na wszystkich innych stanowiskach w firmie, poza kadrą zarządzającą to prawda, że na działalności można zarobić więcej, ale ze względu na skalę. Jak ktoś myśli, że zarobi miliony będąc fryzjerem to niech się puknie w łeb. Ale rozwijając sieć salonów fryzjerskich.. no to już coś zupełnie innego. 200 zł/g za pracę na niskim ryczałcie to NAPRAWDĘ dużo. Wiem inflacja ostatnio dojeżdża wszystkich, ale poza nieruchomościami przez ostatnie 10 lat inflacja była średnio dużo niższa niż potencjalne podwyżki boom w pandemii sprawił, że w IT zaczęło się pojawiać mnóstwo patologii. Junior po kursie na Udemy za 100zł/g, gdzie 10 lat temu tyle zarabiał senior. Brak podstawowej wiedzy dziedzinowej, jak np. jak działa hashmapa. Ogólne wpuszczenie na rynek mnóstwa 'szrotu', tylko po to aby zapełnić fikcyjne wakaty. Ci ludzie nazywali się programistami, ale tak naprawdę nic nie umieli i teraz lecą jeden, po drugim. robienie kilku projektów jednocześnie, ostatnie naprawdę częsta sprawa, kiedyś naprawdę rzadkość naiwne jest myślenie ze chat GPT akurat zastąpi programistów. Wpierw wymiecie Hindusów, klepaczy Exceli i Powerpointów brak dostosowania się do rynku. Ludzie nie chcą robić w starych projektach z legacy codem (JSF, GWT, Java EE) a z drugiej strony nie znają też chmury, kubertenessa, itp. Siłą rzeczy sami sobie robią pod górkę.  Ogólnie zarobki w IT są wysokie, ale dla tych, którzy naprawdę poświęcili dużo czasu na opanowanie rzadkich umiejętności. Jak ktoś myśli, że jeśli potrafi napisać hello world to dostanie 150 zł//g to się teraz rozczaruje..;"
"Spotkał się ktoś z Was z system szablonów który wykorzystuje samą składnie html? Załóżmy że mamy dane $data[""somevariable""]=""List of people""; $data[""usersarray""]=array(     array(""name""=>""Adam"",""age""=>30),     array(""name""=>""John"",""age""=>40) );  Natomiast szablon chciałbym aby wyglądał jak zwykły html i co najważniejsze zawierał w sobie przykładowe dane które później zostaną zastąpione <body> <text name=""somevariable"">Sample text</text> <table>     <loop name=""usersarray"">       <tr><td><item name=""name"">Mike</item></td><td><item name=""age"">50</item></td></tr>     </loop> </table> <loop> </body>  Ostatecznie tag text znika i zostaje tylko wartość zmiennej somevariable, a tag loop swoją zawartość powiela usuwając tag item i pozostawia w jego miejsce wartości z usersarray. Chodzi mi to, aby szablon można było wyświetlić w przeglądarce i aby wyglądał jak gotowa strona. Pewnie ktoś już coś takiego potrzebował, ale nie mogę nic podobnego znaleźć. Będę wdzięczny za każde sugestie.;"
"@abc To po co grafik miałby wpisaywać treść do szablonu, skoro ona i tak będzie zastąpiona? Czemu miałby nie wpisać tylko placeholdera?;"
"Jest takie rozszerzenie napisane w pythonie, które uruchamia wyskakujący kalendarz. Chciałbym go dostosować do swoich potrzeb. Normalnie ten kalendarz wyskakuje po naciśnięciu CTRL+PPM. Ja chciałbym, aby sprawdzało czy bieżący arkusz nazywa się ""druk"" i kalendarz wyskakiwał po naciśnięciu LPM tylko w wybranych komórkach (""J4"", ""D12"", ""D17"", ""F20""). Próbowałem zaprząc do tego chata GPT, ale nie dał rady. :) Oto kluczowy (chyba) fragment kodu po wprowadzeniu zmian przez GPT. Niestety, nie działa. Dużo przeróbek nie ma. Linia 13 została zastąpiona linią 15 i dodane linie od 16 do 21. Podejmie ktoś temat? class MouseClickHandler(Listener, XEnhancedMouseClickHandler):     def __init__(self, ctx, doc):         # print(""MouseClickHandler.__init__()"")         self.ctx = ctx         self.doc = doc      def mousePressed(self, e):         return True      def mouseReleased(self, e):         if not e.Target.supportsService(""com.sun.star.sheet.SheetCell""):             return True         # if (e.Buttons, e.ClickCount, e.Modifiers) == (2, 1, 2): # oryginalny wiersz         # Sprawdzenie, czy lewy przycisk myszy (LPM) został wciśnięty         if e.Buttons == 1:  # 1 oznacza lewy przycisk myszy (LPM)         # Sprawdzenie, czy aktualnie wybrany arkusz to ""druk""             current_sheet = self.doc.CurrentController.getActiveSheet()             if current_sheet.getName() == ""druk"":                 cell_address = e.Target.RangeAddress                 allowed_cells = (""J4"", ""D12"", ""D17"", ""F20"")  # Określ komórki, w których ma działać kalendarz                 if cell_address.StartAddress in allowed_cells:                     try:                         frame = self.doc.CurrentController.Frame                         ismultiselection = self.doc.CurrentSelection.queryIntersection(cell_address).Count                         if not ismultiselection:                             dispatcher = self.ctx.ServiceManager.createInstance(""com.sun.star.frame.DispatchHelper"")                             dispatcher.executeDispatch(frame, "".uno:GoToCell"", """", 0,                                                 (PropertyValue(""ToPoint"", 0, e.Target.AbsoluteName, 0),))                             calendar = Calendar(self.ctx, self.doc, e.Target)                             Y = e.Y + frame.LayoutManager.CurrentDockingArea.Height + frame.LayoutManager.CurrentDockingArea.Y + 16                             X = e.X + 31                             calendar.show(X, Y)                         return True                 except Exception:                     traceback.print_exc()         return True;"
"Jeśli senior niespełniający tych warunków pracuje jako senior w jakiejś firmie to może należałoby się zastanowić po co od niego wymagać rzeczy wymaganych na juniora. To logiczne, że junior musi znac przyziemne tematy (takie które są do zastąpienia przez gpt) bo to on finalnie klepie taski na bazie architektury, wymagań i całej otoczki wymyślonej przez jednego bądź kilku seniorów. Na prawdę nie rozumiem podniecania się kuciem na blachę tematów, które są do ogarnięcia przez byle bota. Nie sądzę by ordynator zajmował się obsługą respiratora. Mnie u seniora bardziej interesuje jak podchodzi do problemów, jak godzi ogarnianie długu technicznego vs wymogi biznesowe nowych featurow, na jakie konfy jeździ, jakie czyta książki by się rozwijać. Edit. Wymaganie pisania algorytmów to wgl iks de w dzisiejszych mocach obliczeniowych dostępnych za pół darmo. Chyba że aplikujesz do nasa lub innych rozwiązań gdzie moc jest ograniczona z różnych względów to inna sprawa. I od razu odbijam argument ""FAANG tak robi"", robi tak bo mają tysiące chętnych do bycia małpkami za setki tysięcy USD rocznie. Jak przyjdzie Google do Polski z ofertą 1mln pln rocznie to też mogę kuć i udawać, że wszystko jest różowe. No ale oni kładą 25k brutto za wymogi te same co w US. xd;"
"http://stackoverflow.com/questions/1636455/where-is-erlang-used-and-why Jeżeli używacie jabber'a to jest wielce prawdopodobne, że łączysz się z serwerem napisanym w Erlangu. Liczba ofert pracy jest powiązana z liczbą programistów. Liczba programistów też wpływa na liczbę ofert pracy + parę innych, waznych czynników. Tak. Jest to technologia nierozpropagowana (3-4 książki + jedna internetowa: http://http://learnyousomeerlang.com), niszowa wręcz. Nie moge powiedzieć, że Erlang wymarł, gdyż musiałby być żywotny na większą skalę w przeszłości. Wręcz przeciwnie - w ostanich latach jego popularność wzrosła, oczywiście nigdy do poziomu mainstreamu. Erlang jest regularnie wydawany (tak około co 4-ry miesiące powstają nowe wersje) - za pracą tych deweloperów ciągle kryje się Ericsson. To nie była nigdy technologia ""trendy"", ale wywarła wpływ na inne technologie, np. Scalę (albo biblioteka aktorów pt. Akka dla Scali i Javy). Dyskusja programistów Erlanga zasadniczo odbywa się na grupie dyskusyjnej ""erlang-questions"", bardzo przyjaznej zresztą. Mnesia nigdy nie była zaprojektowana aby zastąpić RDBMS-y - stąd też wykazuje się mało inicjatywy aby jej ograniczenia plikowe usuwać - trend jest aby używać poważnych RDBMS-ów lub dokumentowych baz danych (jak CouchDB lub Riak, jeżeli chodzi o implementacje w Erlangu). Podsumowując: patrząc na ruch na grupie dyskusyjnej, na to ile pracy się wkłada w kolejne wydania systemu nie mogę się zgodzić z terminem ""wymiera"". Ale jest na pewno niszowy.;"
"Hej. Jakiś czas temu przeżywając nieodwazejmnioną fascynację programowaniem funkcyjnym, trafiłem na jakieś porównanie, w którym jako jego zaletę prezentowaną możliwość zastąpienia wzorców projektowych taką metodyką. Może po prostu mało widziałem. Robiłem chyba dwa podejścia do Haskella i na samym początku jakoś szło, ale potem już średnio. Najłatwiej byłoby mi to zjarzyć pewnie jakby ktoś mi pokazł porównanie dwóch programów na kilkanaście modułów gdzie jeden jest napisany obiektowo z użyciem wzorców, a drugi funkcyjnie, więc jeśli gdzieś coś takiego widzieliście, to byłbym wdzięczny. Albo może jednak ktoś uprzejmy opowie o tym tak, że jednak zrozumiem. :);"
"Design pattern to nazwa na określoną klasę rozwiązań danego problemu.  A więc co do zasady pytanie jest troche malo sensowne, ale znając życie chodziło o patterny popularne w językach typu OOP - jakieś strategie, visitory itd itd. I czy w językach FP jest potrzeba stosowania ich? IIRC nie, bo np. visitora mozesz zastąpić switchem z exhaustive compile-time checkiem;"
"https://github.com/radioactiveCode/skanerTCP  Powinieneś pisać kod po angielsku Brakuje README.md dla projektu Brakuje setup.py i wydzielonego modułu Brakuje requirements.txt Nazwy metod piszesz w camelCase zamiast snake_case Zamiast wczytywać dane z input zainteresuj się argparse - https://docs.python.org/3/library/argparse.html  Spróbuj zastąpić pętlę while True: if sth: break konstrukcją while not sth: do_sth(). Generalnie nie używaj break i continue. To jest anachronizm.  skaner.py linijka 3 - # main - po co wrzucasz nic nieznaczące komentarze? Zamiast tego stwórz funkcję def main(): i ją po prostu wywołaj Brak konstrukcji if __name__ == ""__main__"":  Brak testów Zainteresuj się f-stringami zamiast zwykłym ""string"" + ""string2""   Jak to zrobisz to przyjdź po więcej.;"
"Doceniam Twój optymizm :) Jednak rynek nie jest taki ""super"" i jakoś nie narzekamy na brak CV. W zasadzie sami studenci, choć trafiają się też... ciekawe przypadki ;) Ludzie, dobra firma i fajna technologia robią swoje. Ja nie widzę na rynku potrzeby uządzania łapanek na studentów/juniorów. Zostawiam to firmom które potrafią zastąpić dowolnego architekta skończoną liczbą studentów ;) Btw1 A co złego jest w listach motywacyjnych? To nie zawsze desperacja. Z tego co wiem to nadal pisze się je choćby na Harvard czy pracy w prestiżowych firmach. Osobiście widuję je raptem raz na rok, ale nie widzę w nich nic złego. Btw2 Co masz do ludzi po 30? Znam masę ludzi którzy zrobili switch w tym wieku i są bardziej doceniani na rynku niż nie jeden wybitny student. Wbrew pozorom wcześniejsze doświadczenie poza programowaniem to często mega atut.  Spoko. Szanuję ludzi którzy są chętni poświęcić swój i pracodawcy czas na pogawędkę ze wszystkimi chętnymi. Ja wolę jednak spotkać się i porozmawiać z tymi którzy najpierw wykazali się odrobiną pracy, chęci i wiedzy.  Nic. Pracuję w niszowej technologi, doświadczenie w czymkolwiek innym daje.. doświadczenie :) Tego co my robimy i tak trzeba się nauczyć, nie jest to wiedza ogólna. Przyszedłeś z doświadczeniem? - spoko będzie Ci łatwiej lub ciężej, zależy czego się uczyłeś, jakich nawyków nabrałeś i w jaki sposób pracujesz. Na koniec dnia wszyscy są oceniani z tych samych zadań.;"
"To nie jest jego wada tylko jest to jego jedno z wielu zadań do których PHP zostało stworzone. Ludzie są negatywnie nastawieni do php, bo nie rozumieją do czego ten język służy. Podobnie jest z html i css które są świetnymi językami programowania które mają określony cel i zakres zastosowania, ale przyjdzie Ci taki śmieszek i powie, że najkrótszy żart programistyczny to programista php, a jeszcze krótszy to programista js. Na temat kilku najczęściej wyśmiewanych języków w uproszczeniu: php - język do komunikacji z serwerem, pośredniczący w komunikacji z bazą danych (bezpośrednio na bazie operujemy językiem SQL, jedną z jego popularniejszych odmian jest MySQL) html - język do tworzenia szkieletu warstwy wizualnej (dzielenie strony na kolumny, wyznaczanie gdzie są paragrafy, artykuły, linki, formularze, itd.) css - do kolorowania, formatowania szkieletu warstwy wizualnej js - js operuje na szkielecie warstwy wizualnej, może na nim wykonywać operacje, a także może go formatować, czyli jest bardzo uniwersalny. Gdy jakaś wersja jakiejś niszowej przeglądarki (np. internet explorer lub firefox) nie obsługuje jakiegoś nowego selektora css to można w js napisać 1000 linii kodu które zrobią dokładnie to co robi ten selektor. Autorowi tematu polecam zapoznanie się na razie jedynie z teorią MVC. Dopiero uczysz się programować i widzę, że ciekawe rzeczy robisz, podoba mi się to, ale musisz wiedzieć jak działa strona internetowa, a MVC jest wzorcem projektowym który według mnie idealnie definiuje i uzmysławia sposób, zasady działania strony internetowej/webaplikacji. Dlaczego? M - model, V- view (widok), C - controller (kontroler).  Co to konkretnie oznacza? Model odpowiada za operacje na bazie danych, view za wygląd strony, a controller za tzw logikę (nie lubię jak początkującym wbija się to słowo do głowy, bo nic im ono nie mówi, podobnie jak mówienie o klasach i obiektach jako formie realizacji jakiejś ""rzeczywistości"", sorry, ale osoba zielona w programowaniu nie ma pojęcia czym owa rzeczywistość tak naprawdę jest), czyli wykonywanie działań, instrukcji, operacji takich jak np wykonywanie pętli, instrukcji warunkowych, konkretnych funkcji (by nie podawać najgorszego przykładu, czyli print() lub echo() to podam trim(), czyli funkcja do usunięcia białych znaków z początku i końca ciągu znaków), tablice jedno i wielowymiarowe, klasy, obiekty, itd. Po tym jak przeczytasz artykuł albo dwa albo kilka o mvc powinieneś już dobrze wiedzieć kiedy i jak należy korzystać z js, php, a kiedy można w ogóle z nich nie korzystać i zastąpić je czymś prostszym. Do wyświetlenia słowa na stronie nie używajmy obiektu klasy HelloWorld tylko dajmy najnormalniej w świecie Hello world, ale kto k... chce używać programowania do wyświetlania napisu, programując chcemy stworzyć narzędzie które pozwoli nam wyświetlić napis jako jeden z wielu elementów naszego programu. Jak chcę wyświetlić na ekranie hello world to otwieram notatnik albo nano i w nim piszę te koszmarne ""hello world"", nawet użycie ms word/libre office writer byłoby użyciem zbyt potężnego narzędzia do wykonania zbyt prostego zadania.</p>;"
Witam potrzebuję pomocy w tworzeniu niekomercyjnej strony [(http://bociany-online.pl/i.php)] która po skończeniu miałaby zastąpić obecną  [(http://bociany-online.pl)] Mam następujące problemy:  menu zakrywa część obrazu wideo filmy z youtube zajmują w pionie dużo więcej niż sam obraz  a chciałbym bezpośrednio pod obrazem umieścić kolejne elementy jak np czat po lewej stronie.  Będę bardzo wdzięczny za pomoc i zapraszam do oglądania! :);
"//Absolutyzm oświecony	 	 	 Autor: Edward Kryściak	 Termin „absolutyzm oświecony” został wprowadzony do historii przez historyków niemieckich w połowie XIX wieku. Czym różnił się ten nowy absolutyzm od absolutyzmu narodzonego w Europie w XVII wieku? Jeśli jakiś monarcha europejski w drugiej połowie XVIII wieku zakładał manufaktury, prowadził gospodarkę opartą na zasadzie merkantylizmu, łamał przywileje stanowe rozbudowując administrację, wznosił piękne rezydencje, protegował artystów, założył jakąś akademię nauk lub szkołę rycerską, można mu było nadać miano oświeconego monarchy absolutnego. Gdybyśmy przyjęli tylko takie kryteria, Ludwika XIV można by także zaliczyć w poczet monarchów oświeconego absolutyzmu. A jednak Ludwik XIV był tylko monarchą absolutnym. Były jeszcze inne kryteria, które pozwalają bardziej dokładnie określić cechy absolutyzmu oświeceniowego. Cechą oświeceniowego absolutyzmu sekularyzacja państwa i ucywilizowanie stosunków prawnych. Monarcha rządzi z mandatu i w interesie ludu, a nie z mandatu Bożego, jak to było wcześniej. Obywatele cieszyć się mogą wolnością osobistą i cywilną. Istnieje wolność opinii, aczkolwiek ograniczona do wąskiego grona „oświeconych”. Monarchowie wprowadzają w życie prawa natury, które odkryte przez filozofów nie podlegają żadnej dyskusji. Pozbawiona religijnych namaszczeń, zeświecczona władza monarsza straciła swój pozaczasowy, wiekuisty charakter, stając się czymś historycznym i relatywnym. Władza opierała się na arystokracji. Z jednej strony monarchowie próbowali podporządkować sobie arystokrację, z drugiej strony to właśnie arystokratom zawdzięczali swoje wyniesienie. Dlatego między poglądami filozofów oświecenia a monarchami dochodziło często do napięć. Pięknie oddaje to list Katarzyny II skierowany do Diderota: z tymi waszymi wielkimi zasadami można by zrobić piękne książki, ale bardzo kiepską robotę. Wy pracujecie jedynie na papierze, a ja, biedna cesarzowa, pracuje na ludzkiej skórze, która jest dużo bardziej łaskotliwa i drażliwa. W praktyce rządowej absolutystów oświecenia widać pewne charakterystyczne tendencje: · dążność do podporządkowania Kościoła państwu, w krajach katolickich połączona z antyklerykalizmem, skierowanym szczególnie przeciwko zgromadzeniom zakonnych; · polityka tolerancji wyznaniowej, która ma doprowadzić do wygaśnięcia sporów wyznaniowych; · wprowadzanie zasad humanitaryzmu w prawie karnym, połączone najczęściej z reformą sądownictwa · reformy społeczne, które mają podnieść wydajność pracy chłopa · rozbudowa szkolnictwa o charakterze praktycystycznym Pierwszym z monarchów, o którym J.W. Goethe powiedział, iż był gwiazdą polarną, wokół której obracały się Niemcy, Europa i cały świat, był z całą pewnością Fryderyk II. Był prekursorem w dziedzinie zniesienia tortur i reformie sądownictwa. Po roku 1763 wprowadza w państwie pruskim typ średniej szkoły, która kształcić miała przede wszystkim umiejętności praktyczne – powstaje szkoła realna. W duchu praktycyzmu zreformowane zostały uniwersytety w Królewcu i we Frankfurcie. Ogłoszony został powszechny przymus szkolny. Weterani wojny siedmioletniej stali się nauczycielami, a brak umiejętności pedagogicznych nadrabiali kapralskim drylem. W programach nauczania nacisk był położony na umiejętności przydatne w życiu gospodarczym. Powstały szkoły rolnicze oraz szkoły zawodowe, przygotowujące dzieci do pracy w manufakturach. Fryderyk II popierał filozofów, o których mawiał, że uczą tego, co być powinno, a królowie istnieją jedynie po to, aby wykonywać to, co filozofowie głoszą. Fryderyk II wprowadzał w życie jedynie to co prawda, co było mu przydatne, ale dzięki głoszonym hasłom uzyskał tytuł „filozofa na tronie”. Według głoszonych bowiem zasad król był pierwszym sługa państwa. Prusy stały się krajem tolerancji religijnej, a Fryderyk II pierwszym władcą, który z jawną pogardą odnosił się do religii. Do dobrego tonu należało pokpiwanie z duchownych i religii. Fryderyk II tolerował w swym państwie wszystkie wyznania i wszystkimi pogardzał. Szczególnie wrogo odnosił się do papiestwa, zwalczał pogląd o dualizmie władzy duchowej i świeckiej. W Rzymie papieży widział główną cytadelę ciemnoty i przesądów. Przednią strażą tej cytadeli nazywał jezuitów. W testamencie swoim wskazywał jednak na pragmatyczne podejście do religii: Jest rzeczą obojętną dla polityki, czy władca ma religię, czy też jej zgoła nie posiada. Wszystkie religie, kiedy je zbadać, okazują się oparte na systemie bajecznym, mniej lub bardziej absurdalnym. Ale te przesądy, te błędy i cudowności są stworzone dla ludzi i trzeba mieć na tyle szacunku dla publiczności, aby jej nie gorszyć w kulcie, jakiejkolwiek religii by ów kult dotyczył. Drugim przykładem monarchy oświeconego absolutyzmu jest Józef II – cesarz austriacki. Władzę objął po śmierci Marii Teresy. W ciągu 9 lat samodzielnych rządów wydał Józef II ponad 6 tysięcy dekretów. Wprowadzał reformy administracyjne, społeczne, skarbowe, kościelne, gospodarcze, sądownicze i szkolne. Był zwolennikiem skrajnej centralizacji. Wszelkie instytucje administracji państwowej połączył w jedną wielka centralę, której podporządkował Galicje i Bukowinę. Łącząc urzędy centralne zredukował Józef II liczbę urzędników. Rozbudowany natomiast został system administracyjny na prowincji. Wprowadził dodatki za wysługę lat, renty dla emerytów i wdów, nakaz denucjacji zaniedbujących się w pracy kolegów. W ten sposób stworzył oddany sobie całkowicie stan urzędniczy. Ostentacyjnie zrezygnował z koronacji na króla Węgier, a koronę Stefana Węgierskiego przewiózł do Wiednia i umieścił w muzeum jako zabytek. Teren dawnych Węgier podzielony został na 10 okręgów administracyjnych. Jednocześnie z reformą administracyjną wprowadził na Węgrzech reformę sądowniczą, kościelną i szkolną. Zniósł poddaństwo osobiste chłopów. Chłopi uzyskali wolność przenoszenia się z miejsca na miejsce, wprowadzony został zakaz rugowania chłopów, ustalone odgórnie zostały powinności dworskie chłopów, uzyskali oni prawo procesowania się z panami. Kolejnym krokiem była reforma podatkowa. Dochody skarbu państwowego opierać się miały na podatku gruntowo – dochodowym. W tym celu sporządzono spisy ludności wraz z majątkami, a następnie wyznaczono, iż chłop dla państwa ma oddać 12% dochodu rocznego, dla swego pana 18%. 70% dochodu rocznego pozostawało w ręku chłopa, który z tego miał płacić na parafię i szkołę. Józef II wprowadził w 1784 roku zakaz sprowadzania do monarchii z zagranicy tych produktów, które zastąpić można było krajowymi. Kawa i czekolada ogłoszone zostały jako szkodliwe dla zdrowia. Podobnie zakazano sprowadzania wielu innych luksusowych towarów, a jeżeli kogoś przyłapano na ich sprowadzaniu, to zarekwirowany towar publicznie palono. To doprowadziło do rozwoju rodzimego przemysłu. W 1781 roku wydana została „Powszechna procedura sądowa’. Zniesiono procesy o czary, apostazję. W zasadzie zniesiono karę śmierci, likwidując szubienice i rozbudowując więzienia. Rozbudowana została sieć jednoklasowych szkół elementarnych, w miastach powiatowych powstały szkoły trzyklasowa, a w stolicy okręgu szkoły czteroklasowe. Językiem wykładowym był niemiecki, a szkoły poddane były kontroli urzędów. Powołane zostały 4 tylko uniwersytety na terenie monarchii, a liczba studentów ściśle określona, w zależności od ilości stanowisk do obsadzenia w sądownictwie i administracji. W 1781 roku wydał Józef II dekret o tolerancji dla protestantów i prawosławnych oraz o obowiązkowym przyzwoleniu cesarskim dla bulli papieskich. W styczniu 1782 roku skasowane zostały wszelkie zakony męskie i żeńskie na terenie monarchii nie zajmujące się szkolnictwem, pielęgnacja chorych i nauką. Zlikwidowano ponad 700 domów zakonnych, rozpędzając ponad 38 tysięcy zakonników i zakonnic. Budynki klasztorne zamienione zostały na spichlerze, warsztaty, magazyny. Majątki przeszły na Fundusz Religijny, z którego zakładano szpitale i szkoły oraz nowe parafie. Cesarz chciał stworzyć tak gęstą sieć parafii, aby w każdej miejscowości można było w ciągu godziny dojść do kościoła. W ciągu jednego roku utworzono ponad 800 nowych parafii, przy czym burzono kościoły, których lokalizacja nie odpowiadała zaplanowanej sieci. Proboszczowie mieli stać się urzędnikami cesarskimi. Wydawał szereg przepisów dotyczących nabożeństw, zakazywał procesji i pielgrzymek, a wzywając do oszczędności określał ile świec ma się palić na ołtarzu podczas konkretnego nabożeństwa. To wszystko przyniosło mu tytuł cesarza – zakrystianina. Polityka centralistyczna zaowocowała licznymi napięciami i powstaniami, szczególnie na Węgrzech. Nad monarchią zawisła groźba pruskiej interwencji. Będąc na łożu śmierci, Józef II odwołał wszystkie dekrety dotyczące Węgier poza dekretem tolerancyjnym i zniesieniem poddaństwa osobistego chłopów, a na swym grobie polecił umieścić napis: Tu spoczywa Józef II, który przegrał we wszystkich swoich przedsięwzięciach. Następca – Leopold II przeprowadził likwidację tych dekretów, które były głównym źródłem napięć. Żaden władca absolutny nie zdobył takiej sławy, jak Katarzyna II. Wolter modlił się do niej słowami: Te Catharinam laudamus, te dominam confitemur. Katarzyna II była mistrzynią propagandy i niezwykle inteligentna kobietą, która znakomicie potrafiła oczarować takich ludzi jak Wolter, Diderot. Odgrywała w tym wszystkim znaczną rolę hojność imperatorowej. W polityce wewnętrznej starała się Katarzyna II umocnić rządy osobiste i podporządkować sobie aparat administracyjny. Rządziła przy pomocy doradców i faworytów. Pierwsze miejsce wśród nich zajmował Potiomkin, który był jej kochankiem przez dwa lata, a później przyjacielem i stręczycielem kolejnych kochanków. W zasadzie jednak Katarzyna w ciągu swego panowania sama sprawowała rządy, a faworytyzm zaciążył przede wszystkim na finansach państwa. Dla swoich ulubieńców była bowiem cesarzowa bardzo szczodra. Potiomkin otrzymał od niej 37 tysięcy chłopów, nie licząc kosztowności. W czasie swego panowania Katarzyna II przydzieliła urzędnikom cesarstwa blisko 800 tysięcy chłopów, powstała swoista kategoria chłopów państwowych, którzy pracowali w majątkach wielkich obszarników ziemskich. Pierwszą reforma Katarzyny II była sekularyzacja dóbr kościelnych. Wszystkie dobra cerkiewne wraz z milionem poddanych przeszły do skarbu państwa. Z 900 klasztorów 500 zamknięto, pozostałe były na utrzymaniu państwa. Duchowni otrzymywali pensje państwowe, co ściśle podporządkowało ich władzy. Poza Rosją jawiła się jako protektorka prawosławia. Po zajęciu Białorusi zmusiła unitów do powrotu na prawosławie. W dziedzinie szkolnictwa powołała do życia zakłady wychowawcze dla dziewcząt i chłopców, gdzie nie uczono, lecz wychowywano na „szlachetnych obywateli” zaczynając od 4 roku życia. W sprawie chłopskiej wydała dwa dekrety. Pierwszy z 1765 roku pozwalał panom na zsyłanie chłopów na katorgę, drugi wydany dwa lata później kazał uważać każdą skargę chłopa na swego pana jako kłamliwą denuncjację, karaną dożywotnim zesłaniem. W 1767 roku powołała Komisję Kodyfikacyjną, która miała się zająć nową kodyfikacją prawa. W 1767 roku powstał dokument, który był kompilacją opartą na dziełach Monteskiusza i Beccariego, a w którym mówiono o służebnej roli monarchini, której jedynym celem jest zapewnienie szczęścia obywatelom. Dokument mówił o równości wobec prawa, humanitaryzmie i zniesieniu tortur. Katarzyna mówiła o prawie natury, które każe wszystkich ludzi obdarzyć wolnością. Komisja Kodyfikacyjna liczyła 551 członków, z czego tylko 27 znających się na prawie. Ponadto w Komisji znaleźli się przedstawiciele wszystkich stanów. Kiedy w 1768 roku wybuchła wojna, Katarzyna II komisje kodyfikacyjną rozwiązała pod pretekstem umożliwienia jej członkom dołączenia do swoich regimentów. W 1768 roku w jej miejsce Katarzyna II utworzyła Radę Cesarską, która początkowo spełniała rolę Rady Wojennej w wojnie z Turcją, a później stała się centralnym organem rządowym w rękach cesarzowej. Z jej inspiracji od roku 1769 zaczęły się ukazywać pisma satyryczne, w których ośmieszano staroświeckie przesądy.// http://historicus.pl/content/view/112/67/;"
Dział Flame powstał by przenosić tam 'gorące' wątki. Jak niby Twitter czy mikroblogi mają go zastąpić?;
Cos z Toba jest nie tak - w polowie pierwszej opowiesci zastanawialem sie skad jestes i czy nie sciagac - tak opowiesc pieknie wyglada. Jednak pod koniec nie moge uwierzyc aby 3 firmy zwolnily Cie przez jakies durne powody - mogles trafic na jedna firme z pseudo managerami ale nie na 3. Moze Twoje zdolnosci miekkie sa zbyt slabe? Dajesz sobie wchodzic na glowe? Zapominasz spodni do pracy? ;) Ustalaj wszystko wczesniej dokladnie - slownie/pisemnie i powoluj sie na to. Podziel odpowiedzialnosc. Managerowie maja zapierdalac w pracy a nie tylko rzucac zadaniami i ryzykami. Jesli wymyslaja nierealne terminy/wymagania to przyjmowac na siebie odpowiedzialnosc za ich pomysly to blad - Ty mozesz odpowiadac tylko za terminy ktore sam okresliles. Gdy ktos twierdzi ze dajesz za duze czasy niech zatrudnia kogos kto dal mniejsze i niech on ponosi odpowiedzialnosc. Wybierz jedna technologie i w nia idz - mid nie jest taki zly. Jesli naprawde sie szybko uczysz to w normalnej firmie to docenia. Pomysl o jakims szkoleniu z zarzadzaniem zespolem lub cos w tym stylu (taki strzal na slepo ale z rozmowy wynika ze tak sobie to szlo) Szkolenie z kulturalnej asertywnosci Silownia. Cwicz-jedz-spij i tak w kolko. Wydaje sie ze brak Ci spokojnej pewnosci siebie - a duzych podswiadomie ludzie nie chca denerwowac (przy odpowiedniej pracy moze zastapic punkt 5). Zakladajac ze opisales wszystko prawidlowo proponuje Ci isc do kasyna - stawiaj na jakis kolor a lepsza polowka niech stawia 2x wiecej na kolor przeciwny - przy takim pechu szybko sie dorobicie - znaczy Twoja kobieta bo czy podzieli sie z Toba po rozbiciu kasyna to nie wiem :).;
"Szczęście jest tu kluczowe ponieważ listenerArray[0] dostaje obiekt wytworzony gdzieś na stercie (za wyjątkiem przypadku użycia intern() jego adres jest zawsze inny i unikalny). To co robisz, to porównujesz czy Twój adr ma tę samą referencję co ten obiekt. Jest tylko jeden taki przypadek gdy ten warunek może być spełniony - kiedy listenerArray[0] dostanie nulla, a adr też będzie nullem. A to z kolei jest możliwe tylko wtedy kiedy równolegle dostaniesz OutOfMemoryError. Dość rzadki przypadek. :) Krótko mówiąc Twój warunek prawie nigdy nie będzie spełniony bo nie ma możliwości aby dwa niezależnie stworzone obiekty miały tę samą referencję. A nad tą stworzoną przez split nie masz żadnej kontroli. Jeżeli adr jest stringiem, to zastąp ""== adr"" przez "".equals(adr)"". Wtedy będziesz przynajmniej porównywać teksty. Jeżeli taka była intencja.;"
"Witam Mam takie pytanie - czy jest możliwość podłączenia się jako klient do czatu zrobionego w javie za pomocą delphi (np. interia itp.)? Chciałbym zrobić program, który nie będzie wymagał javy w systemie i będzie możliwość wysłania jakiegoś tekstu czy rozmawiania z użytkownikiem za pomocą mojego programu. Czy jest taka możliwość? Jeśli nie, to czy mogę zrobić program w javie, który zastąpi oryginalnego klineta moim? W jaki sposób to uczynić?;"
"Ciekawe czy dożyjemy czasów, gdy mikrofon zastąpi klawiaturę ...;"
"Daj po msg.Next Application.ProcessMessages ;) Pierwsze co powinieneś zrobić to zastąpić Timer wątkiem. Na tym etapie możesz sobie spokojnie darować bzdety typu optymalizacja bazy, procki składowe, dedykowany serwer na socketach, itd.. Narzekanie na Timer nie ma większego sensu z definicji, bo OnTimer zawsze jest wykonywane w ramach głównego wątku.;"
"Wklejam tutaj, bo w gruncie rzeczy jest to log z rozmowy :) z http://www.funiaste.net/  Dzień Dobry, Nie ukrywam, że list ten piszę aby dać upust złości, w jaką wprawił mnie jeden z produktów Waszej firmy. Chodzi o pizzę mrożoną - Ristorante Edizione Speciale Pizza Salame - jak zgaduję w edycji specjalnej. Znalazło swoje potwierdzenie. Kupiłem taką pizzę w dniu dzisiejszym (niedziela wieczór), w Warszawie, w sklepie BOMI na ul. Puławskiej róg Rakowieckiej. Miała mi posłużyć za obiado-kolację - co dużo znaczy, bo nie jadam ostatnio regularnie. Data przydatności do spożycia: 090702. Zgodnie z instrukcją wyjąłem ją z folii i piekłem pizzę na środkowym poziome ok. 15 min. Wszystko zapowiadało się dobrze, ładny zapach i tak dalej. Jednak po wyjęciu gotowej do spożycia pizzy okazało się, że jest ona ZAMIESZKAŁA!!! Mniej więcej pośrodku, między ziarenkiem kukurydzy a kawałkiem zielonej papryki leżała sobie częściowo zatopiona w ser gąsienica (czyt. robal) długości ok. 1 cm, barwy brązowej. Jestem z wykształcenia ekonomistą, więc trudno mi tu zidentyfikować gatunek. Nie przypuszczam aby ów zwierz zamieszkiwał mój piekarnik już wcześniej, podejrzewam więc, że znalazł się tam wraz z pizzą. Lista składników na opakowaniu nie zawiera niczego podobnego. Jest tam jednak hasło - Poczuj atmosferę i niepowtarzalny smak Italii - świeże, wykwintne obłożenie ze specjalnie dobranymi składnikami i charakterystycznymi włoskimi przyprawami. Nie wiem czy dobrze rozumuję, ale faktycznie robal w mojej pizzy był charakterystyczny i być może wykwintny. Czy miał niepowtarzalny smak, tego nie wiem, ale jeżeli ktoś z państwa pragnie się przekonać osobiście, z dziką rozkoszą dostarczę mu/jej tego przypieczonego biedaka do degustacji. W takim wypadku proszę o kontakt w poniedziałek przed godziną 12. Później bowiem udaję się z nim na spacer do sklepu w celu złożenia reklamacji (mam nadzieję, że nerwy mi nie puszczą). Być może firma Dr. Oetker powinna dodać znalezionego robala do składu, aby uniknąć nieporozumień. Analogicznie należałoby zweryfikować masę netto i wartości odżywcze produktu. Słowa - wykwintne obłożenie - proponuję zastąpić właściwszym według mnie sformułowaniem - wykwintna obsada. A przy okazji wykreślić zdanie o tym, że pizze - przygotowywane są ze starannie wyselekcjonowanych składników i podlegają stałej kontroli jakościowej, chyba że kontrola jakościowa polega na testowaniu długości gąsienic pod kątem - wymiaru ochronnego. Ewentualnie warto by się zastanowić nad zmianą sposobu przyrządzania (zmniejszenie temperatury i wydłużenie czasu), tak aby dać mieszkańcom pizzy czas na ucieczkę!! Jeżeli ktoś z państwa uważa, że przesadzam z reakcją, to pragnę zaznaczyć, że jest niedziela w nocy, a ja wciąż nie jadłem kolacji. Nie muszę dodawać, z czyjej winy!! Macie szczęście, że to była pizza z salami, a nie wegetariańska. Wychowanie nakazuje pozdrowić, więc pozdrawiam, PS. O co właściwie chodzi z tą kropką w Dr. Oetker? Taki doktor z kropką? I dlaczego Wasza firmowa strona www nie działa (zwłaszcza kontakty!!) Ponieważ na stronie www.oetker.pl nie działała podstrona kontakty, list ten wysłałem na ślepo na adresy typu biuro@, marketing@ oetker@ itd. Ten ostatni zadziałał, a ten przedostatni został przesłany do Niemiec do całej grupy osób. Jedna z nich odpowiedziała... Ich werde ab 18.03.2002 nicht im Büro sein. Ich kehre zurück am 15.04.2002. Bei dringenden Fällen wenden Sie sich bitte an Herrn Kostka oder Frau Ritschel inna odpowiedziała tak: Bitte senden Sie keine E-Mail mehr an meine Anschrift! Zdenerwowałem się, bo wcale do niej nie pisałem, wiec udałem głupiego (choć podobno nie musz): Dear Mr/Mz Grosda I am really sorry, but I don't know German, would you be so kind and translate your message for me? By the way, where did you get my address? Best Regards pozostało to bez odpowiedzi. Za to odezwał się oetker: Szanowny Panie Dziękujemy bardzo za konatakt z naszą firmą. Jest nam niezmiernie przykro, że produkt Pizza Ristorante Edizione Speziale nie spełnił Pana oczekiwań. W celu dokonania procedury reklamacyjnej uprzejmie prosimy o przesłanie pizzy wraz z opakowaniem za pośrednictwem kuriera TNT lub Stolicy na nasz koszt. Prosimy również o podanie Pańskiego numeru telefonu i adresu. Nasz adres: Dr. Oetker Środki Odżywcze Gdańsk-Oliwa Sp. z o.o. ul. Adm. Dickmana 14/15 80-339 Gdańsk z dopiskiem ""Serwis Konsumenta"" Z wyrazami szacunku Sławomir Tutlewski Serwis Konsumenta Pizzę wysłałem wraz z robalem, o czym zawiadomiłem: Dzień dobry, Reklamowaną pizzę wraz z jej mieszkańcem wysłałem w poniedziałek Stolicą. Do tej pory powinna do Pana dojść. Potwierdzenie dostałem po tygodniu: Szanowny Panie Dziękuję bardzo za przysłanie pizzy. Produkt został przekazany do Działu Kontroli Jakości, celem dokonania procedury reklamacyjnej oraz wyjaśnienia wszelkich okoliczności tego przykrego dla Pana incydentu. Stosowne wyjaśnienia zaistniałej sytuacji otrzyma Pan natychmiast po zakończeniu badania. Z poważaniem Sławomir Tutlewski Ponieważ oetker pozostał nieruchawy posłałem mu ponaglenie: Szanowny Pan Tutlewski, Wciąż niezmiernie ciekawi mnie wynik postępowania reklamacyjnego, które rozpocząłem przesyłając Państwu pizzę z gąsieniczką (e- mail z dnia 18 marca). Rozgoryczenie jakością oferowanych produktów właściwie już mi minęło. Z wolna jednak zastępuje je uczucie zniecierpliwienia w związku z tempem rozpatrywania mojej reklamacji. Tym bardziej, że cała sprawa wydawała mi się dość oczywista. Jak rozumiem, obecnie trwa procedura badania zasadności mojej reklamacji. Jak mniemam sam corpus delicti (tj. robal) nie przekonał Państwa. Śmiem zatem zasugerować, żeby skupić się na ustaleniu tożsamości (i gatunku) ofiary, a następnie testem DNA znaleźć jego/jej bliskich i wypytać ich o okoliczności  zaginięcia. Jeżeli to nie rzuci światła na zaistniałą sytuację, warto  pewnie byłoby, drogą sekcji, ustalić dokładną przyczynę zgonu. Domyślność moja pozwala w tym miejscu zaproponować cztery domniemane przyczyny: uraz mechaniczny na linii produkcyjnej, uduszenie w folii, nadmierne wyziębienie organizmu w chłodni, lub ostatecznie mogły to być rozległe poparzenia 3. stopnia. Jeżeli okazałoby się, że chodzi właśnie o poparzenia, czyniłoby to mnie współwinnym śmierci zwierzęcia. Wobec czego jestem gotów współpracować, aby liczyć na okoliczności łagodzące. W tym celu skłonny jestem przesłać do ekspertyzy kratkę, na której piekłem pizzę, oraz próbki gazu. W ostateczności mogę nawet przesłać -Stolicą- całą kuchenkę gazową marki Ardo, jeśli jest Pan zdania, że to znacząco przyspieszy procedurę reklamacyjną. Liczę na zrozumienie i szybkie załatwienie sprawy, Pozdrawiam, Nie otrzymałem już więcej listów, ale po jakimś czasie dostałem paczkę z gadżetami i produktami firmy z listem w którym piszą, że wciąż uważają, że nie jest możliwe aby robak dostał się na pizzę w czasie produkcji, i winny jest transport lub hurtownicy. Podziękowałem im za paczkę i na tym się skończyło.;"
"Myślę, że tu jest błąd myślowy. Po pierwsze te narzędzie nie jest w stanie zastąpić eksperta. Zauważ że eksperci są cały czas w cenie, pomimo tego, że uczelnie i bootcampy stale produkują juniorów czy wannabe. Zatem ekspert nie ma się czego bać, natomiast próg wejścia do branży wzrośnie, ponieważ będzie mniejsze zapotrzebowanie na juniorów. Po drugie nawet jeżeli ogólnie spadnie wartość tego co dowozi ekspert, to będzie mógł to dowieźć z mniejszym wsparciem juniorów. Czyli na koniec i tak zarobi tyle co do tej pory, a być może nawet więcej. Po trzecie wejście na poziom eksperta będzie jeszcze trudniejsze, ponieważ jeżeli juniora można zastąpić ChatGPT to ile powinien zarabiać junior?;"
"@Haskell:  Nie zastąpisz juniora ChatemGPT, bo rola programisty nie ogranicza się tylko do klepania kodu :P Bardziej złożony produkt, komunikacja z klientem/domain expertami, lub chociaż nawet takie przyziemne rzeczy jak debugowanie problemów. Jeżeli masz tyle tych projektów że brakuje ci czasu, to nadal będziesz potrzebował tych jr aby zajmowali się przyziemnymi rzeczami, gdy senores lata po spotkaniach i gada z chatem nt. odwracania stringa Nadal niejasne jest ile tego czasu zaoszczędzi ci chat gpt;"
"Z tym zastąpieniem juniora to skrót myślowy, chodzi o to, że tych juniorów będzie mogło być mniej i/lub może nawet nie będą musieli potrafić tego co junior jeżeli chodzi o kodowanie.;"
"Niestety będą musieli, bo będą chcieli zostać ekspertami (kiedyś) ilość ekspertów jest ograniczona, co rok ich ilość zmienia się, spada bo umierają/przechodzą na wczesną emeryturę, zakładają swój business bo ileż można kodzić albo doradzać w projektach za jakieś śmieszne 80k-100k PLN kiedy można być na swoim i cash out robić 300k miesięcznie albo i więcej :) Wracając do początku mojej myśli. Junior będzie chciał się uczyć i kodzić, bo bez tego nie zrozumie języka i jego podstaw, ChatGPT oczywiście pomoże mu w zdobyciu wiedzy ale do pewnego stopnia, bo tego co sam zakodzi nic mu nie zastąpi. Ilość firm będzie wzrastać i potrzebować obok Copilota ekspertów tak jak to piszesz ale tych ekspertów musi przybywać kiedy również ubywa. Jedynie rzeczywiście entry level będzie wyższy i obecne zespoły będzie można z 6-10 osobywych podzielić na 2-3 zespoły po 2-3 osoby z AI i więcej projektów in parallel ogarniać. Ewentualnie pozwalniać juniorów/midów i zostawić seniorów/ekspertów/architektów + AI w uciętym o 50% zespole/zespołach i zatrudniać wyłącznie kolejnych programistów z expert level jeśli firma ma chęć na agresywną ekspansję.;"
"W mojej ocenie Chat GPT nie jest i raczej nie będzie czymś co zastąpi programistę. Jest jednak narzędziem które doprowadzi do rewolucji na rynku pracy w sektorze it. Tak już się działo w przeszłości w innych branżach. Weźcie np. Inżynierów zajmujących się projektowaniem. Kiedyś to był prestiżowy i całkiem nieźle płatny fach. Działy konstrukcyjne zatrudniały po kilkuset ludzi zajmujących się projektowaniem bo robota była robiona ręcznie na deska kreślarskich. Na starych zdjęciach można zobaczyć jak wielkie były biura konstrukcyjne. Obecnie programy typu CAD/CAM sprawiły, że pracę 100 owych  projektantów zastępuje 10 inżynierów. Komputer nie zastąpił tych ludzi ale zwiększył ich wydajność w efekcie obecnie taki konstruktor nie zarabia fortuny bo popyt i podarz ustabilizowały się na neutralnym poziomi. W mojej ocenie w IT będzie podobnie. Wynagrodzenia będą spadać bo zwiększenie wydajności pracy sprawi, że na rynku będzie dostępna spora ilość wolnych zasobów chętna do podjąć zatrudnienie. Konkurencja o miejsce pracy będzie większa tym samym osoby te będą musiały zweryfikować swoje oczekiwania finansowe. Nie sądzę aby zwiększenie wydajności doprowadziło do tego, że będzie produkowana większa ilość projektów bo i po co. Ktoś musi chcieć to kupić. Co do twierdzenia, że pracy na pewno nie zabraknie dla seniorów to nie był bym tego taki pewien. Czas pokażę czy firmy będą wolały zatrudniać drogich seniorów czy w ich miejsc midów którzy z pomocą ChataGPT zrobią tą samą robotę. Osobiście gdybym był właścicielem małego SH wolał bym zatrudnić 3 mid-ów niż 1 seniora z prostego powodu. Gdy ucieknie mi senior tracę 100% mocy przerobowych. Gdy ucieknie jeden z trzech mid-ów tracę 30% i mogę jakoś działać dalej. Co do juniorów pewnie nic się nie zmieni czyli jak była wujnie tak będzie i tylko najlepsi będą się dostawać. O ile będzie jeszcze tak wielu chętnych bo jak fama pójdzie, że w IT skończyło się eldorado to ilu z nich będzie chciało się uczyć/ przekwalifikowywać;"
"Duża różnica w wynagrodzeniach między juniorem, a specjalistą jest charakterystyczna ale w IT. W innych branżach jest zupełnie odwrotnie. Czyli wchodząc do firmy jako dajmy już wspomniany Inżynier Konstruktor dostaniesz na dzień dobry 3,5k. Po pięciu latach pracy jako przeciętny specjalista z doświadczeniem będziesz miał 7k. Wchodząc do It na dzień dobry dostaniesz 3,5k, a po pięciu latach jako przeciętny specjalista na chwile obecną masz 15k. Ludzie z wspomniane przez Ciebie zawody jak Kreślarz czy ""Pomoc Księgowa""  weszli do danej branży bo byli tańsi od prawdziwego Inżyniera czy Księgowej ale jednocześnie dzięki nowym narzędziom które się pojawiły byli wstanie ich zastąpić w większości miejsc nie wymagających jakiejś mocno specjalistycznej wiedzy. Zamodelowanie jakichś powtarzalnych maszyn różniących się gabarytami lub wydajnością to nie jest jakieś rocket science, podobnie jak wklepanie do systemu typu Optima faktur przychodowych i kosztowych dla typowych JDG.;"
"Obstawiam, że rynek sam się wyreguluje, był faktycznie przez lata problem, że brakowało na rynku programistów i programista to był poszukiwany zawód. Trąbiło się o tym wszędzie. To spowodowało, że mnóstwo osób się zaczęło przekwalifikowywać, bo rynek ich chłonął. Jednak czara się przebrała i za dużo się zrobiło programistów i w sytuacji dość trudnej ekonomicznie są już zwalniani (stąd masowe layoffy). Powstało również ChatGPT i teraz się mówi o tym, że AI zastąpi programistów. Kij z tym, czy naprawdę zastąpi, ale chodzi o same nastroje społeczne - o ten apokaliptyczny ton, że za późno już, żeby zostać programistą, bo ""AI ukradnie pracę"". Dodaj do tego całą chmarę ludzi, którzy chcą zostać programistami, a nie mogą znaleźć pracy, bo za dużo się zrobiło na rynku juniorskim. Nawet nie tylko juniorskim, na wyższych szczeblach też coraz trudniej. Ogólnie nieciekawie się robi. Myślę, że ogólne ponure nastroje mogą spowodować to, że coraz mniej ludzi będzie się przekwalifikować na programistę i że wkrótce sytuacja wróci do normy i liczba osób programujących zmniejszy się do poziomu, który będzie odpowiadał rzeczywistemu zapotrzebowaniu (bo teraz jest sporo zawyżona, każdy chce dzisiaj programować, a rynek albo nie przyjmuje takich ludzi albo wypluwa z opóźnieniem, stąd layoffy).  Nie potrzeba więcej słabych programistów, tylko więcej ludzi z potencjałem, a mniej ludzi, którzy się do programowania nie nadają. Ktoś z potencjałem może być słaby technicznie, ale się wyrobi. Niestety większość osób się całkowicie do programowania nie nadaje i nawet po iluś latach zostaną słabi.;"
Fajna zabawka wymagająca jeszcze kilku poprawek. Niemniej przeciętni klepacze crudów/templatek mogą trząść portkami bo prędzej czy później zostaną zastąpieni ;);
"W dłuższej perspektywie myślę że chatGPT może zastąpić ludzi w niektórych zawodach, już teraz to narzędzie zadziwia a co będzie za 10 lat... Ja odkąd zacząłem korzystać z GPT mam mniej pracy, szybciej udaje mi się rozwiązywać zadania. Także myślę że za 10-15 lat zatrudnienie w niektórych zawodach drastycznie spadnie, może niektóre będą całkowicie zastąpione przez AI. Możliwe że będzie mniejsze zapotrzebowanie na programistów w firmach, bo będzie rosła wydajność pracowników i firmy nie będą potrzebowały zatrudniać nadmiarowych osób, być może to już się dzieje w Google, Amazon pozwalniały przecież tysiące pracowników. Na pewno przyszłościowe będą zawody których nie da się zautomatyzować, lekarz, pielęgniarka, chirurg;"
"Tak samo jak automat do robienia kawy zastąpił baristów, tak ChatGPT zastąpi programistów. Tak będzie. Nie zmyślam.;"
"Fajna zabawka, sam używam i do prostych pytań by coś teoretycznie wytłumaczył jest świetny ale do zastąpienia przez niego zwykłego programisty jeszcze dekady;"
To zastąpienie programistów będzie przed czy po upadku Javy? Pogubiłem się już w tych szurskich teoriach;
"Jest bardzo fajne do wprowadzania w temat. Chcesz poznać nową bibliotekę, język czy w ogóle coś zacząć w życiu i nie wiesz od czego zacząć to chatgpt świetnie wprowadzi i odpowie na wszystkie pytania które możesz mieć po drodze. Może już zastąpić większość korepetytorów, ale o ile podpowie dobry wzór to z liczeniem ma duże problemy i nie ufałbym jego wyliczeniom. Sam się gubi w tym co mówi, na przykład sprawdzałem czy poradzi sobie z prostą grą gdzie musi odpowiadać słowem zaczynającym się na ostatnią literę mojego słowa przesuniętą o 3 miejsca w alfabecie:  Apple Lemon why ""Lemon""? The last letter of ""apple"" is ""e"", and shifting it by 3 in the alphabet results in ""h"". Therefore, I respond with a word starting with the letter ""h"", which is ""lemon."" ""lemon"" doesn't start with ""h"" My apologies, you are correct. The word ""lemon"" does not start with the letter ""h"". A word that starts with the letter ""h"" after shifting the last letter of ""apple"" (which is ""e"") by 3 in the alphabet is ""horse"". hotel Lodge why Lodge... The last letter of ""hotel"" is ""l"", and shifting it by 3 in the alphabet results in ""o"". Therefore, I respond with a word starting with the letter ""o"", which is ""lodge"".  I tak cały czas. Niby zna swoje błędy i potrafi je poprawić ale ciągle je popełnia. Gdy próbowałem tej samej ""gry"" po polsku to robił te same błędy ale wypluwał dodatkowo nieistniejące słowa i nie dało się wyjść z trybu gry, odpowiadał wymyślonymi słowami na prośby o wytłumaczenie swojego wyboru. Co ciekawe popełnia dość ludzkie błędy - przykładowo wypluł kod gdzie modyfikuje tę samą zmienną kilka razy w tej samej funkcji i się sam w tym gubi wprowadzając buga z kodem w złej kolejności korzystającej ze zmienionej już wartości. To dokładnie ta sama pomyłka którą często popełniają ludzie i dlaczego się odradza takie pisanie kodu. Końcem Marca ma zostać zintegrowany z bingiem a to może oznaczać rewolucję w wyszukiwaniu informacji w internecie. Albo nie;"
"Właśnie się tym chwile pobawiłem i powiem tak. Fajnie narzędzie do nauki programowania czy coś. Ja nie potrzebuje w pracy czegoś co mi będzie przepisaywać język ludzki na ify bo nie widze w tym nic więcej. W realnym projekcie nie zastąpi nawet juniora. EDIT: Jeśli już gdzieś bym upatrywał zagrożenia to w tym że zagraniczne korpa przeniosą się na tańsze rynki np do Indi. EDIT_2: I fajnie że potrafi trzymać wątek, być może ma też przyszłość jako nowa wyszukiwarka, widzę tu duży potencjał żeby ten tool dawał dużo lepsze wyniki wyszukiwania od googla.;"
"Genialne narzędzie. Używam na co dzień zamiast wyszukiwarki w związku z programowaniem lub pisaniem yamli. Poza tym używam go do przygotowywania wpisów na swoje social media. Narzędzie nadaje się również do generowania artykułów, wpisów na blogu lub po prostu zaproponować tematy wpisów. Można go użyć dosłownie do wszystkiego czego się zapragnie, a jeszcze wizja automatyzacji tego to już w ogóle kosmos. Dobrze zautomatyzowane ChatGPT może zastąpić miliony pracowników biurowych, prawników, dziennikarzy, copy writerów, obsługę klienta, a nawet programistów wykonujących proste czynności. Jesteśmy jeszcze we wczesnej fazie, ale już widać potencjał, a przepowiednie wywołania masowego bezrobocia przez AI nie są w ogóle przesadzone. Myślę, że jedyny zawód który powstanie po udoskonaleniu tego narzędzia to moderator AI, a wszystkie inne będę mogły być zastąpione. Z czasem AI zastąpi również ludzi wydających polecenia AI. Aż w końcu nastąpi dzień w którym AI stwierdzi, że ludzie stanowią zagrożenie i nas zlikwiduje albo zamieni w źródło prądu.;"
